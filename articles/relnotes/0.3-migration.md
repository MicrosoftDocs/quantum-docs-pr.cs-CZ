---
title: Přehled a migrace jazyka QDK 0,3
author: beheim
uid: microsoft.quantum.relnotes.migration-0-3
ms.author: bettina.heim@microsoft.com
ms.date: 10/29/2018
ms.topic: article
ms.openlocfilehash: 6c19f31970ff5440432c5bb3d00e6a7d0eba1e80
ms.sourcegitcommit: aa5e6f4a2deb4271a333d3f1b1eb69b5bb9a7bad
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/02/2019
ms.locfileid: "73442192"
---
# <a name="qdk-03-language-release-notes-and-migration-guide"></a>Poznámky k verzi pro jazyk QDK 0,3 a Průvodce migrací

S radostí zavádíme nejnovější aktualizaci do vývojové sady pro všechna ta.  Tato stránka poskytuje přehled nových funkcí jazyka Q # a popisuje, jak [migrovat](#Migration) existující programy q # do nové syntaxe.  Úplný popis jazyka Q [# najdete v](xref:microsoft.quantum.language.intro)naší kompletní dokumentaci.


## <a name="whats-new"></a>Novinky 

Aktualizace 0,3 se dodává s řadou nových funkcí jazyka a editoru.

### <a name="overview-of-features"></a>Přehled funkcí

- Vylepšená integrace nástrojů pro vývoj pro Visual Studio a Visual Studio Code, včetně:
    - Živá kompilace a zpětná vazba při*psaní (neboli* podtržení vlnovkou).
    - Informace o přechodu myší včetně souhrnů dokumentace a signatur typů
    - Podpora pro přejít k definici.
    - Jednoduchá navigace k deklaracím oborů názvů, operací, funkcí a typů.
    - Vylepšené diagnostické zprávy.
- Vylepšení jazyka
    - Jedna qubit a inicializace řazené kolekce členů v rámci používání a výpůjčky
    - Dekonstrukce řazené kolekce členů u všech přiřazení
    - Iterace nad poli
    - Podmíněné výrazy
    - Zkratka výchozí specializace pro operace
    - Automaticky generované konstruktory typu
    - Modifikátory výrazů


## <a name="editor-features"></a>Funkce editoru

Vývojová sada pro všechna ta teď zahrnuje jazykový Server pro Q # a taky integraci klientů pro Visual Studio a Visual Studio Code.
To umožňuje novou sadu funkcí IntelliSense spolu s živou odezvou během psaní ve formě podtržení chyb a upozornění.
Konkrétně se podporuje příkaz Přejít k definici a zobrazují se informace o typu, které obsahují informace o typech a také informace z dokumentu komentáře. Kromě toho jsou k dispozici informace o symbolech definovaných oborů názvů, operacích, funkcích a typech a umožňují rychle přejít na deklarace.    
Tato aktualizace významně vylepšuje diagnostické zprávy, a to díky snadné navigaci a přesným rozsahům pro diagnostiku a dalším podrobnostem v informacích zobrazených při najetí myší. 

Pro tuto verzi 0,3 nepodporuje jazykový Server, který je součástí vývojové sady pro vytváření více pracovních prostorů.
Aby bylo možné pracovat s projektem v VS Code, otevřete kořenovou složku obsahující samotný projekt a všechny odkazované projekty.
Pokud chcete pracovat s řešením v sadě Visual Studio, musí být všechny projekty obsažené v řešení ve stejné složce jako řešení nebo v jedné z jejích podsložek.

## <a name="language-features"></a>Jazykové funkce

V souvislosti s funkcemi jazyka Tato aktualizace sjednocuje úpravu rozsahu jazykových vzorů.
Konstruktory typů, jako například, jsou generovány pro každý uživatelem definovaný typ a mohou být částečně aplikovány podobně jako jakékoli jiné funkce.
Dalším příkladem je dekonstrukce řazené kolekce členů, která je teď plně podporovaná ve všech přiřazeních. To zahrnuje nejen příkazy let-, mutable-a set-, ale také proměnnou iterace ve smyčce for-Loops a také použití-a výpůjčky-přidělení. Kromě toho jsou u aktualizace 0,3 nově podporovány částečné dekonstrukce; podtržítka v dekonstrukci označují části hodnoty, které mají být ignorovány. 

Následující kód ilustruje některé nové funkce:
```qsharp
    let tuples = [(1, 0), (0, 1)];
    mutable res = (0, 0, 0);

    // For-loops can iterate over arrays, and can destructure tuples.
    for ((i1, i2) in tuples) {

        // Mutable assignments can now destructure and ignore parts of tuples,
        // using the same syntax as let-bindings.
        mutable (r1, r2, _) = res;
        set (r1, r2) = (r1 ||| i1, r2 &&& i2);

        let (_, _, s) = res;
        // The new conditional operator can be used inside expressions, avoiding
        // the need for extraneous if-statements.
        set res = (r1, r2, r1 == r2 ? s | s + 1);
    }
```
Poslední příkaz set používá nový Ternární operátor, který je zavedený s aktualizací 0,3 k podpoře podmíněných výrazů.
Podmíněný výraz je výraz `condition ? caseTrue | caseFalse`formuláře.
Jak je vidět v příkladu výše, je teď také podporována možnost iterace nad poli.

Přidělení v rámci `using` a `borrowing` jsou nově možné pro jednotlivá qubits, qubit pole a vnořené řazené kolekce členů z nich:
```qsharp
    using (q = Qubit()) {
        // q contains a single qubit
    }

    borrowing ((cs, q) = (Qubit[3], Qubit())) {
        // cs contains an array of three qubits, and q contains a single qubit
    }
```

Kromě `auto` jsou představeny dvě nové direktivy generátoru specializace `invert` a `distribute`, aby se zvýšila kontrola nad tím, jak se generují specializace funktor.
Explicitní deklarace výchozí specializace `body` v rámci operací již není povinná.
Podobně jako funkce, příkazy mohou být přímo přidány do samotné deklarace operace, pokud v rámci operace není deklarována žádná jiná specializace.
Skript migrace je součástí vydání, který vám může pomáhat s migrací stávajícího kódu a využívat nové funkce jazyka (viz [část skriptu migrace](#MigrationScript)).

Zásadní změna způsobu, jakým jsou zpracovány uživatelsky definované typy, je součástí aktualizace 0,3. Zatímco předchozí verze ošetřené uživatelsky definovanými typy jako podtypy jejich základního typu, již tento případ nezpůsobí posun (viz také [část o přerušujících změn](#BreakingChanges)).  
V rámci této změny zavádíme modifikátory výrazů, které mohou být aplikovány na určité výrazy. "Atomické" výrazy, které modifikátory lze použít pro jsou identifikátory, výrazy položky pole a Arita-1 n-tice.
Modifikátory se sváže s větším než jakýmkoli jiným výrazem kombinátorem a zejména na těsnější úrovni, než je kombinátorem `(` výrazu volání `)`. 
`Adjoint`, `Controlled`a Nový operátor přípony "Unwrap", `!` jsou považovány za modifikátory výrazu. Ošetření `Adjoint` a `Controlled` jako modifikátory výrazu eliminují potřebu závorek pro velké množství případů. Níže uvedené výrazy jsou platné pro `Op`, jednotkovou operaci, `opArr` pole jednotkových operací a `arg` vhodného argumentu: 
```qsharp
    Adjoint Op (arg);
    Controlled opArr[i] (arg);
```
Skript migrace vynechá většinu zbytečných závorek a bude plně využívat nové funkce. Nicméně se doporučuje, aby skript neinterpretoval kód, a nebude mít za následek odlišnou interpretaci `Controlled` funktor ve výjimečných případech (týká se pouze v kombinaci s částečnými aplikacemi).

Nový modifikátor `!` přetypování uživatelsky definovaného typu na jeho nadřízený typ. Toto přetypování bylo považováno za přetypování v předchozích verzích a bylo provedeno automaticky. S novou interpretací uživatelsky definovaných typů již neplatí a přetypování je nutné provést explicitně.    
Následující příklad ukazuje, jak použít nový modifikátor: 
```qsharp
    newtype Unitary = (Qubit => Unit: Adjoint, Controlled);

    operation Foo (unitaries : Unitary[], q : Qubit) : Unit {

        for (unitary in unitaries[1 .. Length(unitaries)-1]) {
            // Each element of unitaries is an instance of the user-defined
            // type Unitary, so unitary! unwraps each element to an operation
            // type that we can call.
            unitary! (q);
            // The unwrap operator can also be used as a part of functor
            // expressions and when indexing into arrays.
            Adjoint unitary! (q);
            Adjoint unitaries[0]! (q);
        }
    }
```
Jak je vidět v příkladu, `!` váže užší, než modifikátory předpony, jako je `Controlled` a `Adjoint`.

## <a name="BreakingChanges"></a>Průlomové změny 

Aktualizace 0,3 se dodává s novým kompilátorem a obsahuje několik zásadních změn.
Pro usnadnění Aktualizace existujícího kódu kompilátor poskytuje také možnost formátování, která zkompiluje platný nebo neplatný kód a generuje formátovaný kód Q # na základě sestavené kompilace.
Všechny změny syntaxe budou automaticky zpracovány poskytnutým nástrojem. Nicméně změny v tom, jak je interpretován platný kód (sémantické změny) může být nutné provést ručně. 

Kromě níže uvedených změn je vzor `__*__` WHERE * jakákoli sekvence neprázdných znaků je vyhrazena pro interní použití a nemůže být použita jako název symbolu.  

## <a name="syntax-changes"></a>Změny syntaxe 

- Od verze 0,3 položky pole již nejsou odděleny středníkem, ale jsou odděleny čárkami.
- Po deklaraci direktivy specializace se vyžaduje středník na straně druhé.
- Podmínky v klauzulích if-, elif-a klauzule on musí být zapouzdřeny v závorkách. 

Pro všechny ostatní změny syntaxe kompilátor jednoduše vygeneruje upozornění, pokud je použita stará syntaxe.     
Jeden příklad pro takovou změnu je řazená kolekce členů symbolů v uživatelsky definovaných specializacích. Zatímco v předchozích verzích byla deklarace specializace řízená nebo řízená-sousedící-, která byla zadána jako jeden argument symbolu, počínaje 0,3, doporučujeme poskytnout takovému záznamu řazené kolekce členů pro veškerou specializaci s `...`, což znamená, že kompilátor v případě potřeby by měly být migrovány symboly z deklarace s přívolatelné. 

## <a name="semantic-changes"></a>Sémantické změny 

Největší dopad na vyzkoušení verze 0,3 je způsob, jakým jsou uživatelsky definované typy integrovány do systému typů. V předchozích verzích byly uživatelsky definované typy považovány za podtype svého nadřízeného typu. V této verzi se už nejedná o případ. Uživatelsky definované typy se nyní považují za vlastní odlišný typ a neexistuje žádné automatické přetypování mezi uživatelem definovaným typem a jeho nadřazeným typem. Všechna přetypování je nutné provést explicitně prostřednictvím operátoru "Unwrap" `!`a přetypování je potřeba zejména pro přístup k obsahu objektu definovaného uživatelem.  

Úpravy systému typů také zahrnují chování odchylky polí a zpracování parametrizovaných objektů. Počínaje 0,3 jsou proměnlivá i neměnný pole invariantní. Argumenty předané do možného pokusu navíc nelze zadat parametrizovaně. V těchto případech musí být argumenty typu předány spolu s identifikátorem.

Předchozí verze kompilátoru Q # umožňovaly poskytnout hodnotu funkce, kde byla očekávána hodnota operace, pokud má hodnota funkce správné vstupní a výstupní typy. Nejedná se o nezamýšlené chování, které není zadáno ve specifikaci jazyka Q #.
V kompilátoru 0,3 jsme toto chování odebrali, takže hodnoty funkcí již nejsou považovány za hodnoty operací.
Abychom minimalizovali přerušení stávajícího kódu, který se na tuto chybu spoléhal, Přidali jsme funkci ToOperation do oboru názvů Microsoft. Canon, který explicitně převede funkci na operaci se stejnými vstupními a výstupními typy.

Následující příklad ukazuje, jak použít funkci `ToOperation` ke změně funkce `Square` na operaci `op`: 
```qsharp
namespace Microsoft.Quantum.Tests {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    function Square(x : Int) : Int {
        return x * x;
    }

    operation ApplyOp<'T, 'U>(op : ('T => 'U), input : 'T) : 'U {
        return op(input);
    }

    operation ToOperationTest() : Unit {
        let op = ToOperation(Square);
        AssertIntEqual(ApplyOp(op, 3), 9, "ToOperation failed with Square.");
    }
}
```

## <a name="requirements"></a>Požadavky 

Verze je podporována v aplikaci Visual Studio 2017 verze 15,8 nebo novější pro systém Windows 10 a v Visual Studio Code verze 1.27.2 nebo novější pro systémy Windows 10, macOS a Linux.

Vývojová sada pro všechna ta používá .NET Core SDK (2,0 nebo novější).

## <a name="installation"></a>Instalace  

Postupujte podle pokynů k [instalaci.](../install-guide/index.md)

Můžou se zobrazit upozornění ("nalezené konflikty mezi různými verzemi" System. Reflection. metadata ", která se nedala přeložit.") Pokud vaše aktuální verze .NET Core SDK není aktuální.  Pokud ale používáte .NET Core SDK (2,0 nebo novější), můžou se tato upozornění ignorovat.


- Verze je k dispozici spolu s několika různými ukázkami, které ukazují, jak používat stávající funkce pro vývojová prostředí pro plnění a nové funkce, které jsou k dispozici v této verzi. Tyto ukázky můžete najít na GitHubu v úložišti [Microsoft/](https://github.com/Microsoft/Quantum) pro každé z nich.


## <a name="Migration"></a>Migrace stávajících projektů na Q # 0,3 

Pokud máte existující projekty Q # ze verze 0,2 sady pro vývoj pro každé z nich, postupujte podle kroků pro migraci těchto projektů na nejnovější verzi. Poskytujeme také [migrační skript](#MigrationScript) , který vám pomůžeme s procesem.

> [!NOTE]
> Projekty je potřeba upgradovat postupně. Pokud máte řešení s více projekty, aktualizujte každý projekt v pořadí, na které se odkazuje.


1. Z příkazového řádku spusťte příkaz `dotnet clean`, abyste odebrali všechny existující binární a přechodné soubory.
2. V textovém editoru upravte soubor. csproj tak, aby se změnila verze všech `PackageReference` "Microsoft. prohlášené" na verzi 0.3.1811.2802-Preview, například:
```xml
    <PackageReference Include="Microsoft.Quantum.Canon" Version="0.3.1811.2802" />
    <PackageReference Include="Microsoft.Quantum.Development.Kit" Version="0.3.1811.2802" />
```
4. Z příkazového řádku použijte nástroj formátování integrovaný do příkazového řádku kompilátoru pro řešení všech změn syntaxe spuštěním tohoto příkazu: `dotnet msbuild /t:qsharpformat`  
    - Vaše soubory budou migrovány na místě. Záloha všech původních souborů bude zkopírována do `obj\qsharp\.backup`
    - Nástroj formátování zkompiluje projekt ignorováním všech chyb kompilace a generuje formátovaný kód Q # na základě kompilace sestavení. 
       Libovolný nerozpoznaný symbol (např. nedefinovaný název proměnné) nahradí zástupný text, který se musí po formátování nahradit ručně. V tomto případě je formátování úspěšné a generuje upozornění pro ovlivněný soubor.     
    - Formátování a zejména prázdné znaky v souboru budou ve vygenerovaném kódu změněny. Komentáře budou zachovány.   
5. Po spuštění může být stále nutné ručně adresovat sémantické změny v případech, kdy došlo ke změně sémantického výkladu kódu. Všechny tyto chyby budou vykazovány technologií IntelliSense v aplikaci Visual Studio nebo Visual Studio Code.
    - Otevřete kořenovou složku projektu nebo obsahující řešení v aplikaci Visual Studio 2017 nebo Visual Studio Code.
    - Po otevření souboru .qs v editoru by se měl výstup rozšíření jazyka Q# zobrazit v okně výstupu.
    - Po úspěšném načtení projektu (indikovaném v okně výstupu) otevřete jednotlivé soubory a vyřešte všechny zbývající problémy.


> [!NOTE]
> * Pro vydání 0,3 nepodporuje jazykový Server, který je součástí vývojové sady pro vytváření více pracovních prostorů.
> * Pokud chcete pracovat s projektem v editoru Visual Studio Code, otevřete kořenovou složku obsahující vlastní projekt a všechny odkazované projekty.   
> * Pokud chcete pracovat s řešením v sadě Visual Studio, musí být všechny projekty obsažené v řešení ve stejné složce jako řešení nebo v jedné z jejích podsložek.  
> * Odkazy mezi projekty migrované na 0,3 a vyšší a projekty **, které používají** starší verze balíčků, se nepodporují.




## <a name="MigrationScript"></a>Skript migrace 

Za účelem usnadnění migrace projektu je k dispozici skript PowerShellu, který lze stáhnout [zde](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1).
Tento skript pomáhá migrovat projekty z verze 0,2 vývojové sady pro plnění z provozu na používání verze 0,3.

> [!NOTE]
> Skript pro migraci vyžaduje spuštění prostředí Windows PowerShell nebo prostředí PowerShell Core.
> Prostředí Windows PowerShell je dodáváno předem s Windows 10.
> Stáhněte si PowerShell Core pro Windows, macOS nebo Linux na https://github.com/PowerShell/PowerShell.

Skript provede následující čtyři kroky:

- Projekt je sestavený s předchozí verzí vývojové sady pro plnění do provozu, aby bylo zajištěno, že migrace bude nejspíš úspěšná. Tento krok se dá přeskočit pomocí parametru `-Force` skriptu.
- Jsou nainstalovány nové šablony projektů.
- Projekt se aktualizuje tak, aby používal aktuální verzi vývojové sady pro plnění.
- Nástroj pro formátování, který je součástí verze 0,3 sady nástrojů pro plnění, se použije k automatickému vyřešení nejdůležitějších změn, které jsou popsané výše.

Po dokončení těchto čtyř kroků může docházet k nějakým problémům s migrací, které je třeba zpracovat ručně.
Pomocí nejnovější verze rozšíření pro vývojová prostředí pro sadu Visual Studio 2017 a Visual Studio Code může pomoci tyto problémy snadno najít.

Dokumentaci ke skriptu lze získat spuštěním jednoho z následujících příkazů ve složce, ve které je umístěn skript:

```powershell
Get-Help ./qdk-migrate.ps1
Get-Help -Online ./qdk-migrate.ps1
```

> [!NOTE]
> Ve výchozím nastavení systém Windows zabraňuje spuštění všech skriptů v rámci bezpečnostního opatření.
> Aby bylo možné spouštět skripty jako `qdk-migrate.ps1` pro spuštění ve Windows, může být nutné změnit zásady spouštění.
> Uděláte to tak, že spustíte příkaz `Set-ExecutionPolicy`:
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope Process
> ```
> Zásady spouštění se pak po ukončení PowerShellu vrátí.
> Pokud chcete uložit zásady spouštění, použijte jinou hodnotu pro `-Scope`:
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
> ```

