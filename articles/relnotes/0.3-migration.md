---
title: Přehled a migrace jazyka QDK 0,3
description: 'Popisuje nové funkce v Microsoft Quantum Development Kit 0,3 a postup migrace existujících programů Q #.'
author: beheim
uid: microsoft.quantum.relnotes.migration-0-3
ms.author: bettina.heim@microsoft.com
ms.date: 10/29/2018
ms.topic: article
ms.openlocfilehash: a715185059e37e3805caf48e7fae6f5ed3372dba
ms.sourcegitcommit: 2317473fdf2b80de58db0f43b9fcfb57f56aefff
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/15/2020
ms.locfileid: "83426792"
---
# <a name="qdk-03-language-release-notes-and-migration-guide"></a><span data-ttu-id="7841e-103">Poznámky k verzi pro jazyk QDK 0,3 a Průvodce migrací</span><span class="sxs-lookup"><span data-stu-id="7841e-103">QDK 0.3 language release notes and migration guide</span></span>

<span data-ttu-id="7841e-104">S radostí zavádíme nejnovější aktualizaci do vývojové sady pro všechna ta.</span><span class="sxs-lookup"><span data-stu-id="7841e-104">We are excited to introduce the newest update to the Quantum Development Kit.</span></span>  <span data-ttu-id="7841e-105">Tato stránka poskytuje přehled nových funkcí jazyka Q # a popisuje, jak [migrovat](#Migration) existující programy q # do nové syntaxe.</span><span class="sxs-lookup"><span data-stu-id="7841e-105">This page gives an overview of the new Q# language features and describes how to [migrate](#Migration) existing Q# programs to the new syntax.</span></span>  <span data-ttu-id="7841e-106">Úplný popis jazyka Q [# najdete v](xref:microsoft.quantum.guide.basics)naší kompletní dokumentaci.</span><span class="sxs-lookup"><span data-stu-id="7841e-106">See our complete documentation for the full description of the Q# language [here](xref:microsoft.quantum.guide.basics).</span></span>


## <a name="whats-new"></a><span data-ttu-id="7841e-107">Co je nového?</span><span class="sxs-lookup"><span data-stu-id="7841e-107">What's New</span></span> 

<span data-ttu-id="7841e-108">Aktualizace 0,3 se dodává s řadou nových funkcí jazyka a editoru.</span><span class="sxs-lookup"><span data-stu-id="7841e-108">The 0.3 update comes with a range of new language and editor features.</span></span>

### <a name="overview-of-features"></a><span data-ttu-id="7841e-109">Přehled funkcí</span><span class="sxs-lookup"><span data-stu-id="7841e-109">Overview of Features</span></span>

- <span data-ttu-id="7841e-110">Vylepšená integrace nástrojů pro vývoj pro Visual Studio a Visual Studio Code, včetně:</span><span class="sxs-lookup"><span data-stu-id="7841e-110">Enhanced development tool integration for Visual Studio and Visual Studio Code, including:</span></span>
    - <span data-ttu-id="7841e-111">Živá kompilace a zpětná vazba při*psaní (neboli*</span><span class="sxs-lookup"><span data-stu-id="7841e-111">Live compilation and feedback on typing (*a.k.a.*</span></span> <span data-ttu-id="7841e-112">podtržení vlnovkou).</span><span class="sxs-lookup"><span data-stu-id="7841e-112">squiggly underlining).</span></span>
    - <span data-ttu-id="7841e-113">Informace o přechodu myší včetně souhrnů dokumentace a signatur typů</span><span class="sxs-lookup"><span data-stu-id="7841e-113">Hover information including documentation summaries and type signatures.</span></span>
    - <span data-ttu-id="7841e-114">Podpora pro přejít k definici.</span><span class="sxs-lookup"><span data-stu-id="7841e-114">Support for go to definition.</span></span>
    - <span data-ttu-id="7841e-115">Jednoduchá navigace k deklaracím oborů názvů, operací, funkcí a typů.</span><span class="sxs-lookup"><span data-stu-id="7841e-115">Easy navigation to namespace, operation, function, and type declarations.</span></span>
    - <span data-ttu-id="7841e-116">Vylepšené diagnostické zprávy.</span><span class="sxs-lookup"><span data-stu-id="7841e-116">Improved diagnostic messages.</span></span>
- <span data-ttu-id="7841e-117">Vylepšení jazyka</span><span class="sxs-lookup"><span data-stu-id="7841e-117">Language improvements</span></span>
    - <span data-ttu-id="7841e-118">Jedna qubit a inicializace řazené kolekce členů v rámci používání a výpůjčky</span><span class="sxs-lookup"><span data-stu-id="7841e-118">Single qubit and tuple initializations within using and borrowing</span></span>
    - <span data-ttu-id="7841e-119">Dekonstrukce řazené kolekce členů u všech přiřazení</span><span class="sxs-lookup"><span data-stu-id="7841e-119">Tuple deconstruction on all assignments</span></span>
    - <span data-ttu-id="7841e-120">Iterace nad poli</span><span class="sxs-lookup"><span data-stu-id="7841e-120">Iteration over arrays</span></span>
    - <span data-ttu-id="7841e-121">Podmíněné výrazy</span><span class="sxs-lookup"><span data-stu-id="7841e-121">Conditional expressions</span></span>
    - <span data-ttu-id="7841e-122">Zkratka výchozí specializace pro operace</span><span class="sxs-lookup"><span data-stu-id="7841e-122">Default-specialization abbreviation for operations</span></span>
    - <span data-ttu-id="7841e-123">Automaticky generované konstruktory typu</span><span class="sxs-lookup"><span data-stu-id="7841e-123">Auto-generated type constructors</span></span>
    - <span data-ttu-id="7841e-124">Modifikátory výrazů</span><span class="sxs-lookup"><span data-stu-id="7841e-124">Expression modifiers</span></span>


## <a name="editor-features"></a><span data-ttu-id="7841e-125">Funkce editoru</span><span class="sxs-lookup"><span data-stu-id="7841e-125">Editor Features</span></span>

<span data-ttu-id="7841e-126">Vývojová sada pro všechna ta teď zahrnuje jazykový Server pro Q # a taky integraci klientů pro Visual Studio a Visual Studio Code.</span><span class="sxs-lookup"><span data-stu-id="7841e-126">The Quantum Development Kit now includes a language server for Q#, as well as the client integrations for Visual Studio and Visual Studio Code.</span></span>
<span data-ttu-id="7841e-127">To umožňuje novou sadu funkcí IntelliSense spolu s živou odezvou během psaní ve formě podtržení chyb a upozornění.</span><span class="sxs-lookup"><span data-stu-id="7841e-127">This enables a new set of IntelliSense features along with live feedback on typing in form of squiggly underlinings of errors and warnings.</span></span>
<span data-ttu-id="7841e-128">Konkrétně se podporuje příkaz Přejít k definici a zobrazují se informace o typu, které obsahují informace o typech a také informace z dokumentu komentáře.</span><span class="sxs-lookup"><span data-stu-id="7841e-128">In particular, go to definition is now supported and hover information is displayed containing type information as well as information from documenting comments.</span></span> <span data-ttu-id="7841e-129">Kromě toho jsou k dispozici informace o symbolech definovaných oborů názvů, operacích, funkcích a typech a umožňují rychle přejít na deklarace.</span><span class="sxs-lookup"><span data-stu-id="7841e-129">Additionally, symbol information about defined namespaces, operations, functions, and types is available and allows to quickly navigate to declarations.</span></span>    
<span data-ttu-id="7841e-130">Tato aktualizace významně vylepšuje diagnostické zprávy, a to díky snadné navigaci a přesným rozsahům pro diagnostiku a dalším podrobnostem v informacích zobrazených při najetí myší.</span><span class="sxs-lookup"><span data-stu-id="7841e-130">This update greatly improves diagnostic messages in general, with easy navigation to and precise ranges for diagnostics and additional details in the displayed hover information.</span></span> 

<span data-ttu-id="7841e-131">Pro tuto verzi 0,3 nepodporuje jazykový Server, který je součástí vývojové sady pro vytváření více pracovních prostorů.</span><span class="sxs-lookup"><span data-stu-id="7841e-131">For this 0.3 release, the language server included with the Quantum Development Kit does not support multiple workspaces.</span></span>
<span data-ttu-id="7841e-132">Aby bylo možné pracovat s projektem v VS Code, otevřete kořenovou složku obsahující samotný projekt a všechny odkazované projekty.</span><span class="sxs-lookup"><span data-stu-id="7841e-132">In order to work with a project in VS Code, open the root folder containing the project itself and all referenced projects.</span></span>
<span data-ttu-id="7841e-133">Pokud chcete pracovat s řešením v sadě Visual Studio, musí být všechny projekty obsažené v řešení ve stejné složce jako řešení nebo v jedné z jejích podsložek.</span><span class="sxs-lookup"><span data-stu-id="7841e-133">In order to work with a solution in Visual Studio, all projects contained in the solution need to be in the same folder as the solution or in one of its subfolders.</span></span>

## <a name="language-features"></a><span data-ttu-id="7841e-134">kompatibility značek (mc:)</span><span class="sxs-lookup"><span data-stu-id="7841e-134">Language Features</span></span>

<span data-ttu-id="7841e-135">V souvislosti s funkcemi jazyka Tato aktualizace sjednocuje úpravu rozsahu jazykových vzorů.</span><span class="sxs-lookup"><span data-stu-id="7841e-135">In terms of language features, this update unifies the treatment of a range of language patterns.</span></span>
<span data-ttu-id="7841e-136">Konstruktory typů, jako například, jsou generovány pro každý uživatelem definovaný typ a mohou být částečně aplikovány podobně jako jakékoli jiné funkce.</span><span class="sxs-lookup"><span data-stu-id="7841e-136">Type constructors, as an example, are generated for each user defined type and can be partially applied much like any other function.</span></span>
<span data-ttu-id="7841e-137">Dalším příkladem je dekonstrukce řazené kolekce členů, která je teď plně podporovaná ve všech přiřazeních.</span><span class="sxs-lookup"><span data-stu-id="7841e-137">Another example is tuple deconstruction, which is now fully supported within all assignments.</span></span> <span data-ttu-id="7841e-138">To zahrnuje nejen příkazy let-, mutable-a set-, ale také proměnnou iterace ve smyčce for-Loops a také použití-a výpůjčky-přidělení.</span><span class="sxs-lookup"><span data-stu-id="7841e-138">This includes not only let-, mutable-, and set-statements, but also the iteration variable in for-loops as well as using- and borrowing-allocations.</span></span> <span data-ttu-id="7841e-139">Kromě toho jsou u aktualizace 0,3 nově podporovány částečné dekonstrukce; podtržítka v dekonstrukci označují části hodnoty, které mají být ignorovány.</span><span class="sxs-lookup"><span data-stu-id="7841e-139">Additionally, partial deconstructions are newly supported with the 0.3 update; underscores in deconstructions indicate parts of the value that are to be ignored.</span></span> 

<span data-ttu-id="7841e-140">Následující kód ilustruje některé nové funkce:</span><span class="sxs-lookup"><span data-stu-id="7841e-140">The following code illustrates some of the new features:</span></span>
```qsharp
    let tuples = [(1, 0), (0, 1)];
    mutable res = (0, 0, 0);

    // For-loops can iterate over arrays, and can destructure tuples.
    for ((i1, i2) in tuples) {

        // Mutable assignments can now destructure and ignore parts of tuples,
        // using the same syntax as let-bindings.
        mutable (r1, r2, _) = res;
        set (r1, r2) = (r1 ||| i1, r2 &&& i2);

        let (_, _, s) = res;
        // The new conditional operator can be used inside expressions, avoiding
        // the need for extraneous if-statements.
        set res = (r1, r2, r1 == r2 ? s | s + 1);
    }
```
<span data-ttu-id="7841e-141">Poslední příkaz set používá nový Ternární operátor, který je zavedený s aktualizací 0,3 k podpoře podmíněných výrazů.</span><span class="sxs-lookup"><span data-stu-id="7841e-141">The last set statement uses a new ternary operator that is introduced with the 0.3 update to support conditional expressions.</span></span>
<span data-ttu-id="7841e-142">Podmíněný výraz je výrazem formuláře `condition ? caseTrue | caseFalse` .</span><span class="sxs-lookup"><span data-stu-id="7841e-142">A conditional expression is an expression of the form `condition ? caseTrue | caseFalse`.</span></span>
<span data-ttu-id="7841e-143">Jak je vidět v příkladu výše, je teď také podporována možnost iterace nad poli.</span><span class="sxs-lookup"><span data-stu-id="7841e-143">As can be seen from the example above, iteration over arrays is now also supported.</span></span>

<span data-ttu-id="7841e-144">Alokace v rámci `using` a `borrowing` jsou nově možné pro jednotlivá qubits, qubit pole a vnořené řazené kolekce členů této služby:</span><span class="sxs-lookup"><span data-stu-id="7841e-144">Allocations within `using` and `borrowing` are newly possible for single qubits, qubit arrays, and nested tuples thereof:</span></span>
```qsharp
    using (qubit = Qubit()) {
        // qubit contains a single qubit
    }

    borrowing ((qubits, qubit) = (Qubit[3], Qubit())) {
        // qubits contains an array of three qubits, and qubit contains a single qubit
    }
```

<span data-ttu-id="7841e-145">Dvě nové direktivy generátoru specializace `invert` a `distribute` kromě `auto` nich jsou zavedené ke zvýšení kontroly nad tím, jak se generují specializace funktor.</span><span class="sxs-lookup"><span data-stu-id="7841e-145">Two new specialization generator directives `invert` and `distribute` in addition to `auto` are introduced to increase control over how functor specializations are generated.</span></span>
<span data-ttu-id="7841e-146">Explicitní deklarace výchozí `body` specializace v rámci operací již není povinná.</span><span class="sxs-lookup"><span data-stu-id="7841e-146">An explicit declaration of the default `body` specialization within operations is no longer mandatory.</span></span>
<span data-ttu-id="7841e-147">Podobně jako funkce, příkazy mohou být přímo přidány do samotné deklarace operace, pokud v rámci operace není deklarována žádná jiná specializace.</span><span class="sxs-lookup"><span data-stu-id="7841e-147">Similar to functions, statements may be directly added to the operation declaration itself if no other specialization is declared within the operation.</span></span>
<span data-ttu-id="7841e-148">Skript migrace je součástí vydání, který vám může pomáhat s migrací stávajícího kódu a využívat nové funkce jazyka (viz [část skriptu migrace](#MigrationScript)).</span><span class="sxs-lookup"><span data-stu-id="7841e-148">A migration script is included in the release to help migrating existing code and taking advantage of new language features (see the [section on the migration script](#MigrationScript)).</span></span>

<span data-ttu-id="7841e-149">Zásadní změna způsobu, jakým jsou zpracovány uživatelsky definované typy, je součástí aktualizace 0,3.</span><span class="sxs-lookup"><span data-stu-id="7841e-149">A major change in how user-defined types are treated comes with the 0.3 update.</span></span> <span data-ttu-id="7841e-150">Zatímco předchozí verze ošetřené uživatelsky definovanými typy jako podtypy jejich základního typu, již tento případ nezpůsobí posun (viz také [část o přerušujících změn](#BreakingChanges)).</span><span class="sxs-lookup"><span data-stu-id="7841e-150">While prior releases treated user defined types as subtypes of their underlying type, this is no longer the case going forward (see also the [section on breaking changes](#BreakingChanges)).</span></span>  
<span data-ttu-id="7841e-151">V rámci této změny zavádíme modifikátory výrazů, které mohou být aplikovány na určité výrazy.</span><span class="sxs-lookup"><span data-stu-id="7841e-151">As part of this change we introduce expression modifiers that can be applied to certain expressions.</span></span> <span data-ttu-id="7841e-152">"Atomické" výrazy, které modifikátory lze použít pro jsou identifikátory, výrazy položky pole a Arita-1 n-tice.</span><span class="sxs-lookup"><span data-stu-id="7841e-152">The "atomic" expressions that modifiers can be applied to are identifiers, array item expressions, and arity-1 tuples.</span></span>
<span data-ttu-id="7841e-153">Modifikátory sváže užší než jakýkoli jiný výraz kombinátorem a zejména v těsném výrazu, než je kombinátorem výrazu volání `(` `)` .</span><span class="sxs-lookup"><span data-stu-id="7841e-153">Modifiers bind tighter than any other expression combinator, and in particular tighter than the call-expression combinator `(` `)`.</span></span> 
<span data-ttu-id="7841e-154">`Adjoint`, `Controlled` a nové příponový operátor Unwrap `!` je považován za modifikátory výrazu.</span><span class="sxs-lookup"><span data-stu-id="7841e-154">`Adjoint`, `Controlled`, and a new "unwrap" postfix operator `!` are treated as expression modifiers.</span></span> <span data-ttu-id="7841e-155">Ošetření `Adjoint` a `Controlled` jako modifikátory výrazů eliminují potřebu závorek pro velké množství případů.</span><span class="sxs-lookup"><span data-stu-id="7841e-155">Treating `Adjoint` and `Controlled` as expression modifiers eliminates the need for parenthesis for a lot of cases.</span></span> <span data-ttu-id="7841e-156">Níže uvedené výrazy jsou platné pro účely přechodu na `Op` určitou, jednotnou operaci, `opArr` pole jednotkových operací a `arg` vhodný argument:</span><span class="sxs-lookup"><span data-stu-id="7841e-156">The expressions below for example are valid going forward for `Op`, a unitary operation, `opArr` an array of unitary operations, and `arg` a suitable argument:</span></span> 
```qsharp
    Adjoint Op (arg);
    Controlled opArr[i] (arg);
```
<span data-ttu-id="7841e-157">Skript migrace vynechá většinu zbytečných závorek a bude plně využívat nové funkce.</span><span class="sxs-lookup"><span data-stu-id="7841e-157">The migration script will drop most of the unnecessary parenthesis and take full advantage of the new features.</span></span> <span data-ttu-id="7841e-158">Nicméně se doporučuje, aby skript neinterpretoval kód, a nebude mít za následek jiný výklad `Controlled` funktor ve výjimečných případech (týká se pouze v kombinaci s částečnými aplikacemi).</span><span class="sxs-lookup"><span data-stu-id="7841e-158">However, be advised that the script does not interpret the code, and will not account for the different interpretation of the `Controlled` functor in rare cases (only relevant in combination with partial applications).</span></span>

<span data-ttu-id="7841e-159">Nový modifikátor `!` přetypování uživatelsky definovaného typu na jeho nadřízený typ.</span><span class="sxs-lookup"><span data-stu-id="7841e-159">The new modifier `!` casts a user-defined type to its underlying type.</span></span> <span data-ttu-id="7841e-160">Toto přetypování bylo považováno za přetypování v předchozích verzích a bylo provedeno automaticky.</span><span class="sxs-lookup"><span data-stu-id="7841e-160">This cast has been considered an upcast in previous releases and was executed automatically.</span></span> <span data-ttu-id="7841e-161">S novou interpretací uživatelsky definovaných typů již neplatí a přetypování je nutné provést explicitně.</span><span class="sxs-lookup"><span data-stu-id="7841e-161">With the new interpretation of user defined types this is no longer the case and the cast needs to be made explicit.</span></span>    
<span data-ttu-id="7841e-162">Následující příklad ukazuje, jak použít nový modifikátor:</span><span class="sxs-lookup"><span data-stu-id="7841e-162">The following example illustrates how to use the new modifier:</span></span> 
```qsharp
    newtype Unitary = (Qubit => Unit: Adjoint, Controlled);

    operation Foo (unitaries : Unitary[], qubit : Qubit) : Unit {

        for (unitary in unitaries[1 .. Length(unitaries)-1]) {
            // Each element of unitaries is an instance of the user-defined
            // type Unitary, so unitary! unwraps each element to an operation
            // type that we can call.
            unitary! (qubit);
            // The unwrap operator can also be used as a part of functor
            // expressions and when indexing into arrays.
            Adjoint unitary! (qubit);
            Adjoint unitaries[0]! (qubit);
        }
    }
```
<span data-ttu-id="7841e-163">Jak je možné vidět z příkladu, `!` váže užší, než modifikátory předpony, jako `Controlled` a `Adjoint` .</span><span class="sxs-lookup"><span data-stu-id="7841e-163">As can be seen from the example, `!` binds tighter than prefix modifiers, like `Controlled` and `Adjoint`.</span></span>

## <a name="breaking-changes"></a><a name="BreakingChanges"></a><span data-ttu-id="7841e-164">Průlomové změny</span><span class="sxs-lookup"><span data-stu-id="7841e-164">Breaking Changes</span></span> 

<span data-ttu-id="7841e-165">Aktualizace 0,3 se dodává s novým kompilátorem a obsahuje několik zásadních změn.</span><span class="sxs-lookup"><span data-stu-id="7841e-165">The 0.3 update comes with a new compiler and contains a handful of breaking changes.</span></span>
<span data-ttu-id="7841e-166">Pro usnadnění Aktualizace existujícího kódu kompilátor poskytuje také možnost formátování, která zkompiluje platný nebo neplatný kód a generuje formátovaný kód Q # na základě sestavené kompilace.</span><span class="sxs-lookup"><span data-stu-id="7841e-166">To facilitate updating existing code, the compiler also provides a formatting option that compiles valid or invalid code and emits formatted Q# code based on the built compilation.</span></span>
<span data-ttu-id="7841e-167">Všechny změny syntaxe budou automaticky zpracovány poskytnutým nástrojem.</span><span class="sxs-lookup"><span data-stu-id="7841e-167">All syntax changes will be processed automatically by the provided tool.</span></span> <span data-ttu-id="7841e-168">Nicméně změny v tom, jak je interpretován platný kód (sémantické změny) může být nutné provést ručně.</span><span class="sxs-lookup"><span data-stu-id="7841e-168">However, changes in how valid code is interpreted (semantic changes) may need to be made manually.</span></span> 

<span data-ttu-id="7841e-169">Kromě níže uvedených změn je vzor, `__*__` kde \* je jakákoli sekvence neprázdných znaků, vyhrazena pro interní použití a nemůže být použit jako název symbolu.</span><span class="sxs-lookup"><span data-stu-id="7841e-169">In addition to the changes listed below, the pattern `__*__` where \* is any sequence of non-whitespace characters is reserved for internal use and cannot be used as a symbol name.</span></span>  

## <a name="syntax-changes"></a><span data-ttu-id="7841e-170">Změny syntaxe</span><span class="sxs-lookup"><span data-stu-id="7841e-170">Syntax Changes</span></span> 

- <span data-ttu-id="7841e-171">Od verze 0,3 položky pole již nejsou odděleny středníkem, ale jsou odděleny čárkami.</span><span class="sxs-lookup"><span data-stu-id="7841e-171">Starting with the version 0.3, array items are no longer separated by semicolons, but are separated by commas instead.</span></span>
- <span data-ttu-id="7841e-172">Po deklaraci direktivy specializace se vyžaduje středník na straně druhé.</span><span class="sxs-lookup"><span data-stu-id="7841e-172">A semicolon on the other hand is required after an auto-generation directive for specialization declarations.</span></span>
- <span data-ttu-id="7841e-173">Podmínky v klauzulích if-, elif-a klauzule on musí být zapouzdřeny v závorkách.</span><span class="sxs-lookup"><span data-stu-id="7841e-173">Conditions in if-, elif-, and until-clauses need to be encapsulated in parenthesis.</span></span> 

<span data-ttu-id="7841e-174">Pro všechny ostatní změny syntaxe kompilátor jednoduše vygeneruje upozornění, pokud je použita stará syntaxe.</span><span class="sxs-lookup"><span data-stu-id="7841e-174">For all other syntax changes the compiler will simply generate a warning if the old syntax is used.</span></span>     
<span data-ttu-id="7841e-175">Jeden příklad pro takovou změnu je řazená kolekce členů symbolů v uživatelsky definovaných specializacích.</span><span class="sxs-lookup"><span data-stu-id="7841e-175">One example for such a change is the symbol tuple in user-defined specializations.</span></span> <span data-ttu-id="7841e-176">V předchozích verzích byla deklarace specializace řízená nebo řízená-sousedící-se zadaným jedním argumentem symbolu, počínaje 0,3, doporučujeme poskytnout takové záznamy řazené kolekce členů pro všechny specializace s `...` označením, že kompilátor by měl v případě potřeby migrovat symboly z deklarace, která se dá volat.</span><span class="sxs-lookup"><span data-stu-id="7841e-176">While in previous releases a controlled or controlled-adjoint specialization declaration specified a single symbol argument, starting in 0.3 it is encouraged to provide such a symbol tuple for all specialization with `...` indicating that the compiler should migrate the symbols from the callable declaration if needed.</span></span> 

## <a name="semantic-changes"></a><span data-ttu-id="7841e-177">Sémantické změny</span><span class="sxs-lookup"><span data-stu-id="7841e-177">Semantic Changes</span></span> 

<span data-ttu-id="7841e-178">Největší dopad na vyzkoušení verze 0,3 je způsob, jakým jsou uživatelsky definované typy integrovány do systému typů.</span><span class="sxs-lookup"><span data-stu-id="7841e-178">The most impactful breaking for the 0.3 release is how user-defined types are integrated into the type system.</span></span> <span data-ttu-id="7841e-179">V předchozích verzích byly uživatelsky definované typy považovány za podtype svého nadřízeného typu.</span><span class="sxs-lookup"><span data-stu-id="7841e-179">In prior releases user defined types were considered to be a subtype of their underlying type.</span></span> <span data-ttu-id="7841e-180">V této verzi se už nejedná o případ.</span><span class="sxs-lookup"><span data-stu-id="7841e-180">With this release and going forward this is no longer the case.</span></span> <span data-ttu-id="7841e-181">Uživatelsky definované typy se nyní považují za vlastní odlišný typ a neexistuje žádné automatické přetypování mezi uživatelem definovaným typem a jeho nadřazeným typem.</span><span class="sxs-lookup"><span data-stu-id="7841e-181">User defined types are now considered to be their own distinct type, and no automatic cast between a user defined type and its underlying type exists.</span></span> <span data-ttu-id="7841e-182">Všechna přetypování je nutné provést explicitně prostřednictvím operátoru "Unwrap" `!` a přetypování je potřeba zejména pro přístup k obsahu objektu definovaného uživatelem.</span><span class="sxs-lookup"><span data-stu-id="7841e-182">All casts need to be made explicit via an "unwrap" operator `!`, and a cast is needed in particular to access the content of a object of user defined type.</span></span>  

<span data-ttu-id="7841e-183">Úpravy systému typů také zahrnují chování odchylky polí a zpracování parametrizovaných objektů.</span><span class="sxs-lookup"><span data-stu-id="7841e-183">The modifications to the type system also include the variance behavior of arrays, and the treatment of type parameterized objects.</span></span> <span data-ttu-id="7841e-184">Počínaje 0,3 jsou proměnlivá i neměnný pole invariantní.</span><span class="sxs-lookup"><span data-stu-id="7841e-184">Starting in 0.3, both mutable and immutable arrays are invariant.</span></span> <span data-ttu-id="7841e-185">Argumenty předané do možného pokusu navíc nelze zadat parametrizovaně.</span><span class="sxs-lookup"><span data-stu-id="7841e-185">Additionally, arguments passed to a callable cannot be type parameterized.</span></span> <span data-ttu-id="7841e-186">V těchto případech musí být argumenty typu předány spolu s identifikátorem.</span><span class="sxs-lookup"><span data-stu-id="7841e-186">In these cases, type arguments must be passed along with the identifer.</span></span>

<span data-ttu-id="7841e-187">Předchozí verze kompilátoru Q # umožňovaly poskytnout hodnotu funkce, kde byla očekávána hodnota operace, pokud má hodnota funkce správné vstupní a výstupní typy.</span><span class="sxs-lookup"><span data-stu-id="7841e-187">Previous releases of the Q# compiler allowed a function value to be provided where an operation value was expected, as long as the function value had the correct input and output types.</span></span> <span data-ttu-id="7841e-188">Nejedná se o nezamýšlené chování, které není zadáno ve specifikaci jazyka Q #.</span><span class="sxs-lookup"><span data-stu-id="7841e-188">This was unintended behavior that is not specified in the Q# language specification.</span></span>
<span data-ttu-id="7841e-189">V kompilátoru 0,3 jsme toto chování odebrali, takže hodnoty funkcí již nejsou považovány za hodnoty operací.</span><span class="sxs-lookup"><span data-stu-id="7841e-189">In the 0.3 compiler, we have removed this behavior so that function values are no longer considered operation values.</span></span>
<span data-ttu-id="7841e-190">Abychom minimalizovali přerušení stávajícího kódu, který se na tuto chybu spoléhal, Přidali jsme funkci ToOperation do oboru názvů Microsoft.. Canon, který explicitně převede funkci na operaci se stejnými vstupními a výstupními typy.</span><span class="sxs-lookup"><span data-stu-id="7841e-190">To minimize the disruption to existing code that relied on this bug, we have added the ToOperation function in the Microsoft.Quantum.Canon namespace that will explicitly convert a function into an operation with the same input and output types.</span></span>

<span data-ttu-id="7841e-191">Následující příklad ukazuje, jak použít `ToOperation` funkci ke změně funkce `Square` na operaci `op` :</span><span class="sxs-lookup"><span data-stu-id="7841e-191">The following example illustrates how to use the `ToOperation` function to change a function `Square` to an operation `op`:</span></span> 
```qsharp
namespace Microsoft.Quantum.Tests {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    function Square(x : Int) : Int {
        return x * x;
    }

    operation ApplyOp<'T, 'U>(op : ('T => 'U), input : 'T) : 'U {
        return op(input);
    }

    operation ToOperationTest() : Unit {
        let op = ToOperation(Square);
        AssertIntEqual(ApplyOp(op, 3), 9, "ToOperation failed with Square.");
    }
}
```

## <a name="requirements"></a><span data-ttu-id="7841e-192">Požadavky</span><span class="sxs-lookup"><span data-stu-id="7841e-192">Requirements</span></span> 

<span data-ttu-id="7841e-193">Verze je podporována v aplikaci Visual Studio 2017 verze 15,8 nebo novější pro systém Windows 10 a v Visual Studio Code verze 1.27.2 nebo novější pro systémy Windows 10, macOS a Linux.</span><span class="sxs-lookup"><span data-stu-id="7841e-193">The release is supported on Visual Studio 2017 version 15.8 or later for Windows 10, and on Visual Studio Code version 1.27.2 or later for Windows 10, macOS, and Linux.</span></span>

<span data-ttu-id="7841e-194">Vývojová sada pro všechna ta používá .NET Core SDK (2,0 nebo novější).</span><span class="sxs-lookup"><span data-stu-id="7841e-194">The Quantum Development Kit uses the .NET Core SDK (2.0 or later).</span></span>

## <a name="installation"></a><span data-ttu-id="7841e-195">Instalace</span><span class="sxs-lookup"><span data-stu-id="7841e-195">Installation</span></span>  

<span data-ttu-id="7841e-196">Postupujte podle pokynů k [instalaci.](../install-guide/index.md)</span><span class="sxs-lookup"><span data-stu-id="7841e-196">Follow the installation instructions [here](../install-guide/index.md).</span></span>

<span data-ttu-id="7841e-197">Můžou se zobrazit upozornění ("nalezené konflikty mezi různými verzemi" System. Reflection. metadata ", která se nedala přeložit.") Pokud vaše aktuální verze .NET Core SDK není aktuální.</span><span class="sxs-lookup"><span data-stu-id="7841e-197">You may see warnings ("Found conflicts between different versions of "System.Reflection.Metadata" that could not be resolved.") if your current version of .NET Core SDK is not up to date.</span></span>  <span data-ttu-id="7841e-198">Pokud ale používáte .NET Core SDK (2,0 nebo novější), můžou se tato upozornění ignorovat.</span><span class="sxs-lookup"><span data-stu-id="7841e-198">However, if you are using .NET Core SDK (2.0 or later), these warnings may be ignored.</span></span>


- <span data-ttu-id="7841e-199">Verze je k dispozici spolu s několika různými ukázkami, které ukazují, jak používat stávající funkce pro vývojová prostředí pro plnění a nové funkce, které jsou k dispozici v této verzi.</span><span class="sxs-lookup"><span data-stu-id="7841e-199">The release is provided along with a number of different samples showing how to use both existing features of the Quantum Development Kit, and the new features available with this release.</span></span> <span data-ttu-id="7841e-200">Tyto ukázky můžete najít na GitHubu v úložišti [Microsoft/](https://github.com/Microsoft/Quantum) pro každé z nich.</span><span class="sxs-lookup"><span data-stu-id="7841e-200">These samples can be can be found on GitHub at the [Microsoft/Quantum](https://github.com/Microsoft/Quantum) repository.</span></span>


## <a name="migrating-existing-projects-to-q-03"></a><a name="Migration"></a><span data-ttu-id="7841e-201">Migrace stávajících projektů na Q # 0,3</span><span class="sxs-lookup"><span data-stu-id="7841e-201">Migrating Existing Projects to Q# 0.3</span></span> 

<span data-ttu-id="7841e-202">Pokud máte existující projekty Q # ze verze 0,2 sady pro vývoj pro každé z nich, postupujte podle kroků pro migraci těchto projektů na nejnovější verzi.</span><span class="sxs-lookup"><span data-stu-id="7841e-202">If you have existing Q# projects from version 0.2 of the Quantum Development Kit, the following are the steps to migrate those projects to the newest version.</span></span> <span data-ttu-id="7841e-203">Poskytujeme také [migrační skript](#MigrationScript) , který vám pomůžeme s procesem.</span><span class="sxs-lookup"><span data-stu-id="7841e-203">We also provide a [migration script](#MigrationScript) to help you with the process.</span></span>

> [!NOTE]
> <span data-ttu-id="7841e-204">Projekty je potřeba upgradovat postupně.</span><span class="sxs-lookup"><span data-stu-id="7841e-204">Projects need to be upgraded in order.</span></span> <span data-ttu-id="7841e-205">Pokud máte řešení s více projekty, aktualizujte každý projekt v pořadí, na které se odkazuje.</span><span class="sxs-lookup"><span data-stu-id="7841e-205">If you have a solution with multiple projects update each project in the order they are referenced.</span></span>


1. <span data-ttu-id="7841e-206">Z příkazového řádku spusťte příkaz `dotnet clean`, abyste odebrali všechny existující binární a přechodné soubory.</span><span class="sxs-lookup"><span data-stu-id="7841e-206">From a command line, Run `dotnet clean` to remove all existing binaries and intermediate files.</span></span>
2. <span data-ttu-id="7841e-207">V textovém editoru upravte soubor. csproj tak, aby se změnila verze všech společností "Microsoft. `PackageReference` prohlášené" na verzi 0.3.1811.2802-Preview, například:</span><span class="sxs-lookup"><span data-stu-id="7841e-207">In a text editor, edit the .csproj file to change the version of all the "Microsoft.Quantum" `PackageReference` to version 0.3.1811.2802-preview, for example:</span></span>
```xml
    <PackageReference Include="Microsoft.Quantum.Canon" Version="0.3.1811.2802" />
    <PackageReference Include="Microsoft.Quantum.Development.Kit" Version="0.3.1811.2802" />
```
4. <span data-ttu-id="7841e-208">Z příkazového řádku použijte formátovací nástroj integrovaný do příkazového řádku kompilátoru pro řešení všech změn syntaxe spuštěním tohoto příkazu:`dotnet msbuild /t:qsharpformat`</span><span class="sxs-lookup"><span data-stu-id="7841e-208">From the command line, use the formatting tool integrated into the command line compiler to address all syntax changes by running this command: `dotnet msbuild /t:qsharpformat`</span></span>  
    - <span data-ttu-id="7841e-209">Vaše soubory budou migrovány na místě.</span><span class="sxs-lookup"><span data-stu-id="7841e-209">Your files will be migrated in-place.</span></span> <span data-ttu-id="7841e-210">Záloha všech původních souborů bude zkopírována do`obj\qsharp\.backup`</span><span class="sxs-lookup"><span data-stu-id="7841e-210">A backup of all the original files will be copied to `obj\qsharp\.backup`</span></span>
    - <span data-ttu-id="7841e-211">Nástroj formátování zkompiluje projekt ignorováním všech chyb kompilace a generuje formátovaný kód Q # na základě kompilace sestavení.</span><span class="sxs-lookup"><span data-stu-id="7841e-211">The formatting tool will compile the project ignoring all compilation errors and generate formatted Q# code based on the build compilation.</span></span> 
       <span data-ttu-id="7841e-212">Libovolný nerozpoznaný symbol (např. nedefinovaný název proměnné) nahradí zástupný text, který se musí po formátování nahradit ručně.</span><span class="sxs-lookup"><span data-stu-id="7841e-212">Any unrecognized symbol (e.g. an undefined variable name) will be replaced by a placeholder text that needs to be replaced manually after formatting.</span></span> <span data-ttu-id="7841e-213">V tomto případě je formátování úspěšné a generuje upozornění pro ovlivněný soubor.</span><span class="sxs-lookup"><span data-stu-id="7841e-213">In this case, the formatting succeeds while generating a warning for the affected file.</span></span>     
    - <span data-ttu-id="7841e-214">Formátování a zejména prázdné znaky v souboru budou ve vygenerovaném kódu změněny.</span><span class="sxs-lookup"><span data-stu-id="7841e-214">The formatting and in particular any white space in the file will be changed in the emitted code.</span></span> <span data-ttu-id="7841e-215">Komentáře budou zachovány.</span><span class="sxs-lookup"><span data-stu-id="7841e-215">Comments will be preserved.</span></span>   
5. <span data-ttu-id="7841e-216">Po spuštění může být stále nutné ručně adresovat sémantické změny v případech, kdy došlo ke změně sémantického výkladu kódu.</span><span class="sxs-lookup"><span data-stu-id="7841e-216">After running this, you might still need to manually address semantic changes in cases where the semantic interpretation of the code has changed.</span></span> <span data-ttu-id="7841e-217">Všechny tyto chyby budou vykazovány technologií IntelliSense v aplikaci Visual Studio nebo Visual Studio Code.</span><span class="sxs-lookup"><span data-stu-id="7841e-217">All these errors will be reported by IntelliSense in Visual Studio or Visual Studio Code.</span></span>
    - <span data-ttu-id="7841e-218">Otevřete kořenovou složku projektu nebo obsahující řešení v aplikaci Visual Studio 2017 nebo Visual Studio Code.</span><span class="sxs-lookup"><span data-stu-id="7841e-218">Open the root folder of the project or the containing solution in Visual Studio 2017 or Visual Studio Code.</span></span>
    - <span data-ttu-id="7841e-219">Po otevření souboru .qs v editoru by se měl výstup rozšíření jazyka Q# zobrazit v okně výstupu.</span><span class="sxs-lookup"><span data-stu-id="7841e-219">After opening a .qs file in the editor, you should see the output of the Q# language extension in the output window.</span></span>
    - <span data-ttu-id="7841e-220">Po úspěšném načtení projektu (indikovaném v okně výstupu) otevřete jednotlivé soubory a vyřešte všechny zbývající problémy.</span><span class="sxs-lookup"><span data-stu-id="7841e-220">After the project has loaded successfully (indicated in the output window) open each file and manually to address all remaining issues.</span></span>


> [!NOTE]
> * <span data-ttu-id="7841e-221">Pro vydání 0,3 nepodporuje jazykový Server, který je součástí vývojové sady pro vytváření více pracovních prostorů.</span><span class="sxs-lookup"><span data-stu-id="7841e-221">For the 0.3 release, the language server included with the Quantum Development Kit does not support multiple workspaces.</span></span>
> * <span data-ttu-id="7841e-222">Pokud chcete pracovat s projektem v editoru Visual Studio Code, otevřete kořenovou složku obsahující vlastní projekt a všechny odkazované projekty.</span><span class="sxs-lookup"><span data-stu-id="7841e-222">In order to work with a project in Visual Studio Code, open the root folder containing the project itself and all referenced projects.</span></span>   
> * <span data-ttu-id="7841e-223">Pokud chcete pracovat s řešením v sadě Visual Studio, musí být všechny projekty obsažené v řešení ve stejné složce jako řešení nebo v jedné z jejích podsložek.</span><span class="sxs-lookup"><span data-stu-id="7841e-223">In order to work with a solution in Visual Studio, all projects contained in the solution need to be in the same folder as the solution or in one of its subfolders.</span></span>  
> * <span data-ttu-id="7841e-224">Odkazy mezi projekty migrované na 0,3 a vyšší a projekty **, které používají** starší verze balíčků, se nepodporují.</span><span class="sxs-lookup"><span data-stu-id="7841e-224">References between projects migrated to 0.3 and higher and projects using older package versions are **not** supported.</span></span>




## <a name="migration-script"></a><a name="MigrationScript"></a><span data-ttu-id="7841e-225">Skript migrace</span><span class="sxs-lookup"><span data-stu-id="7841e-225">Migration script</span></span> 

<span data-ttu-id="7841e-226">Za účelem usnadnění migrace projektu je k dispozici skript PowerShellu, který lze stáhnout [zde](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1).</span><span class="sxs-lookup"><span data-stu-id="7841e-226">In order to facilitate project migration, a PowerShell script is provided that can be downloaded [here](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1).</span></span>
<span data-ttu-id="7841e-227">Tento skript pomáhá migrovat projekty z verze 0,2 vývojové sady pro plnění z provozu na používání verze 0,3.</span><span class="sxs-lookup"><span data-stu-id="7841e-227">This script helps migrate projects from version 0.2 of the Quantum Development Kit to use version 0.3.</span></span>

> [!NOTE]
> <span data-ttu-id="7841e-228">Skript pro migraci vyžaduje spuštění prostředí Windows PowerShell nebo prostředí PowerShell Core.</span><span class="sxs-lookup"><span data-stu-id="7841e-228">The migration script requires Windows PowerShell or PowerShell Core to run.</span></span>
> <span data-ttu-id="7841e-229">Prostředí Windows PowerShell je dodáváno předem s Windows 10.</span><span class="sxs-lookup"><span data-stu-id="7841e-229">Windows PowerShell comes pre-installed with Windows 10.</span></span>
> <span data-ttu-id="7841e-230">Stáhněte si PowerShell Core pro Windows, macOS nebo Linux na https://github.com/PowerShell/PowerShell .</span><span class="sxs-lookup"><span data-stu-id="7841e-230">Download PowerShell Core for Windows, macOS, or Linux at https://github.com/PowerShell/PowerShell.</span></span>

<span data-ttu-id="7841e-231">Skript provede následující čtyři kroky:</span><span class="sxs-lookup"><span data-stu-id="7841e-231">The script executes the following four steps:</span></span>

- <span data-ttu-id="7841e-232">Projekt je sestavený s předchozí verzí vývojové sady pro plnění do provozu, aby bylo zajištěno, že migrace bude nejspíš úspěšná.</span><span class="sxs-lookup"><span data-stu-id="7841e-232">The project is built with the previous version of the Quantum Development Kit to ensure that migration is likely to succeed.</span></span> <span data-ttu-id="7841e-233">Tento krok se dá přeskočit pomocí `-Force` parametru ke skriptu.</span><span class="sxs-lookup"><span data-stu-id="7841e-233">This step can be skipped by using the `-Force` parameter to the script.</span></span>
- <span data-ttu-id="7841e-234">Jsou nainstalovány nové šablony projektů.</span><span class="sxs-lookup"><span data-stu-id="7841e-234">New project templates are installed.</span></span>
- <span data-ttu-id="7841e-235">Projekt se aktualizuje tak, aby používal aktuální verzi vývojové sady pro plnění.</span><span class="sxs-lookup"><span data-stu-id="7841e-235">The project is updated to use the current version of the Quantum Development Kit.</span></span>
- <span data-ttu-id="7841e-236">Nástroj pro formátování, který je součástí verze 0,3 sady nástrojů pro plnění, se použije k automatickému vyřešení nejdůležitějších změn, které jsou popsané výše.</span><span class="sxs-lookup"><span data-stu-id="7841e-236">The formatting tool provided with version 0.3 of the Quantum Development Kit is applied to automatically address most of the breaking changes documented above.</span></span>

<span data-ttu-id="7841e-237">Po dokončení těchto čtyř kroků může docházet k nějakým problémům s migrací, které je třeba zpracovat ručně.</span><span class="sxs-lookup"><span data-stu-id="7841e-237">After these four steps complete, there may be some remaining migration issues which must be handled manually.</span></span>
<span data-ttu-id="7841e-238">Pomocí nejnovější verze rozšíření pro vývojová prostředí pro sadu Visual Studio 2017 a Visual Studio Code může pomoci tyto problémy snadno najít.</span><span class="sxs-lookup"><span data-stu-id="7841e-238">Using the latest version of the Quantum Development Kit extensions for Visual Studio 2017 and Visual Studio Code can help find these issues easily.</span></span>

<span data-ttu-id="7841e-239">Dokumentaci ke skriptu lze získat spuštěním jednoho z následujících příkazů ve složce, ve které je umístěn skript:</span><span class="sxs-lookup"><span data-stu-id="7841e-239">The documentation for the script can be obtained by running one of the following commands in the folder where the script is located:</span></span>

```powershell
Get-Help ./qdk-migrate.ps1
Get-Help -Online ./qdk-migrate.ps1
```

> [!NOTE]
> <span data-ttu-id="7841e-240">Ve výchozím nastavení systém Windows zabraňuje spuštění všech skriptů v rámci bezpečnostního opatření.</span><span class="sxs-lookup"><span data-stu-id="7841e-240">By default, Windows prevents the execution of any scripts as a security measure.</span></span>
> <span data-ttu-id="7841e-241">Aby bylo možné spouštět skripty, jako je například `qdk-migrate.ps1` spouštění v systému Windows, může být nutné změnit zásady spouštění.</span><span class="sxs-lookup"><span data-stu-id="7841e-241">To allow scripts such as `qdk-migrate.ps1` to run on Windows, you may need to change the execution policy.</span></span>
> <span data-ttu-id="7841e-242">Uděláte to tak, že spustíte `Set-ExecutionPolicy` příkaz:</span><span class="sxs-lookup"><span data-stu-id="7841e-242">To do so, run the `Set-ExecutionPolicy` command:</span></span>
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope Process
> ```
> <span data-ttu-id="7841e-243">Zásady spouštění se pak po ukončení PowerShellu vrátí.</span><span class="sxs-lookup"><span data-stu-id="7841e-243">The execution policy will then be reverted when you exit PowerShell.</span></span>
> <span data-ttu-id="7841e-244">Pokud chcete uložit zásady spouštění, použijte jinou hodnotu pro `-Scope` :</span><span class="sxs-lookup"><span data-stu-id="7841e-244">If you would like to save the execution policy, use a different value for `-Scope`:</span></span>
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
> ```

