---
title: Q# Principy návrhu rozhraní API
description: Q# Principy návrhu rozhraní API
author: cgranade
ms.author: chgranad
ms.date: 3/9/2020
ms.topic: contributor-guide
uid: microsoft.quantum.contributing.api-design
no-loc:
- Q#
- $$v
ms.openlocfilehash: 452b32141dc660acbe8ef28530f1430e5acff9aa
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/26/2021
ms.locfileid: "98856703"
---
# <a name="no-locq-api-design-principles"></a><span data-ttu-id="dfd7c-103">Q# Principy návrhu rozhraní API</span><span class="sxs-lookup"><span data-stu-id="dfd7c-103">Q# API Design Principles</span></span>

## <a name="introduction"></a><span data-ttu-id="dfd7c-104">Úvod</span><span class="sxs-lookup"><span data-stu-id="dfd7c-104">Introduction</span></span>

<span data-ttu-id="dfd7c-105">Jako jazyk a jako platforma Q# umožňuje uživatelům psát, spouštět, rozumět a prozkoumat aplikace s využitím více procesorů.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-105">As a language and as a platform, Q# empowers users to write, run, understand, and explore quantum applications.</span></span>
<span data-ttu-id="dfd7c-106">Aby bylo možné uživatele při návrhu Q# knihoven, pořiďte si sadu principů návrhu rozhraní API, které vám pomohou s návrhy a pomáhat při vytváření použitelných knihoven pro komunita pro vývoj všech stavů.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-106">In order to empower users, when we design Q# libraries, we follow a set of API design principles to guide our designs and to help us make usable libraries for the the quantum development community.</span></span>
<span data-ttu-id="dfd7c-107">Tento článek obsahuje seznam těchto principů a popisuje příklady, které vám pomůžou při navrhování Q# rozhraní API použít.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-107">This article lists these principles, and gives examples to help guide how to apply them when designing Q# APIs.</span></span>

> [!TIP]
> <span data-ttu-id="dfd7c-108">Toto je poměrně podrobný dokument, který je určený k tomu, aby usnadnil vývoj knihovny a podrobné příspěvky knihoven.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-108">This is a fairly detailed document that's intended to help guide library development and in-depth library contributions.</span></span>
> <span data-ttu-id="dfd7c-109">Je pravděpodobné, že je to nejužitečnější, pokud píšete vlastní knihovny v nástroji Q# , nebo pokud přispíváte do [ Q# úložiště knihoven](https://github.com/microsoft/QuantumLibraries)větší funkce.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-109">You'll probably find it most useful if you're writing your own libraries in Q#, or if you're contributing larger features to the [Q# libraries repository](https://github.com/microsoft/QuantumLibraries).</span></span>
>
> <span data-ttu-id="dfd7c-110">Na druhé straně, pokud se naučíte, jak přispívat do vývojové sady pro práci s více společnostmi obecně, doporučujeme začít s [průvodcem pro příspěvky](xref:microsoft.quantum.contributing).</span><span class="sxs-lookup"><span data-stu-id="dfd7c-110">On the other hand, if you're looking to learn how to contribute to the Quantum Development Kit more generally, we suggest starting with the [contribution guide](xref:microsoft.quantum.contributing).</span></span>
> <span data-ttu-id="dfd7c-111">Pokud hledáte obecnější informace o tom, jak kód Doporučujeme formátovat Q# , může vás zajímat [Průvodce stylem](xref:microsoft.quantum.contributing.style).</span><span class="sxs-lookup"><span data-stu-id="dfd7c-111">If you're looking for more general information about how we recommend formatting your Q# code, you may be interested in checking out the [style guide](xref:microsoft.quantum.contributing.style).</span></span>

## <a name="general-principles"></a><span data-ttu-id="dfd7c-112">Obecné zásady</span><span class="sxs-lookup"><span data-stu-id="dfd7c-112">General Principles</span></span>

<span data-ttu-id="dfd7c-113">**Princip klíče:** Zveřejňujte rozhraní API, která umístí fokus na aplikace.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-113">**Key principle:** Expose APIs that places the focus on quantum applications.</span></span>

- <span data-ttu-id="dfd7c-114">✅**Vyberte název** operace a funkce, který odráží strukturu algoritmů a aplikací vysoké úrovně.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-114">✅ **DO** choose operation and function names that reflect the   high-level structure of algorithms and applications.</span></span>
- <span data-ttu-id="dfd7c-115">⛔️  nezveřejňujte rozhraní API, která se zaměřují hlavně na podrobnosti implementace nízké úrovně.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-115">⛔️ **DON'T** expose APIs that focus primarily on low-level   implementation details.</span></span>

<span data-ttu-id="dfd7c-116">**Princip klíče:** Spusťte jednotlivé návrhy rozhraní API s použitím ukázkových případů použití, abyste zajistili, že je rozhraní API intuitivní.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-116">**Key principle:** Start each API design with sample use cases to ensure that APIs are intuitive to use.</span></span>

- <span data-ttu-id="dfd7c-117">✅**Zajistěte, aby každá** součást veřejného rozhraní API měla odpovídající případ použití, nikoli pokusit se navrhovat všechna možná použití od začátku.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-117">✅ **DO** ensure that each component of a public API has a corresponding use case, rather than trying to design for all possible uses from the start.</span></span>
    <span data-ttu-id="dfd7c-118">Nepoužívejte jiné, nezaveďte veřejná rozhraní API pro případ, že jsou užitečná, ale ujistěte se, že každá část rozhraní API má *konkrétní* příklad, ve kterém bude užitečná.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-118">Put differently, don't introduce public APIs in case they are useful, but make sure that each part of an API has a *concrete* example in which it will be useful.</span></span>

  <span data-ttu-id="dfd7c-119">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-119">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-120">@"microsoft.quantum.canon.applytoeachca" dá se použít jako `ApplyToEachCA(H, _)` pro přípravu registrů v jednotném stavu, což je běžný úkol v mnoha algoritmech pro každé z nich.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-120">@"microsoft.quantum.canon.applytoeachca" can be used as `ApplyToEachCA(H, _)` to prepare registers in a uniform superposition state, a common task in many quantum algorithms.</span></span> <span data-ttu-id="dfd7c-121">Stejnou operaci lze také použít pro mnoho dalších úloh v rámci přípravy, čísel a algoritmů založených na Oracle.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-121">The same operation can also be used for many other tasks in preparation, numerics, and oracle-based algorithms.</span></span>

- <span data-ttu-id="dfd7c-122">✅Nové návrhy rozhraní API pro **pracovní debatu** a workshop vám umožní dvakrát ověřit, jestli jsou intuitivní a splňují navržené případy použití.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-122">✅ **DO** brainstorm and workshop new API designs to double-check   that they are intuitive and meet proposed use cases.</span></span>

  <span data-ttu-id="dfd7c-123">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-123">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-124">Zkontrolujte aktuální kód Q a \# Zjistěte, jak by nové návrhy rozhraní API mohly zjednodušit a objasnit stávající implementace.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-124">Inspect current Q\# code to see how new API designs could   simplify and clarify existing implementations.</span></span>
  - <span data-ttu-id="dfd7c-125">Projděte si návrhy navržených rozhraní API se zástupci primárních cílových skupin.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-125">Review proposed API designs with representatives of primary   audiences.</span></span>

<span data-ttu-id="dfd7c-126">**Princip klíče:** Navrhněte rozhraní API pro podporu a podporu čitelného kódu.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-126">**Key principle:** Design APIs to support and encourage readable code.</span></span>

- <span data-ttu-id="dfd7c-127">✅**Zajistěte, aby byl** kód čitelný odborníky v doméně a znalci bez expertů.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-127">✅ **DO** ensure that code is readable by domain experts and   non-experts alike.</span></span>
- <span data-ttu-id="dfd7c-128">✅ Zaměřte se na účinky jednotlivých operací a funkcí v rámci algoritmu vysoké úrovně, a to pomocí dokumentace, která bude v případě potřeby podrobná v podrobnostech implementace.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-128">✅ **DO** place the focus on the effects of each operation and   function within the high-level algorithm, using documentation to   delve into implementation details as appropriate.</span></span>
- <span data-ttu-id="dfd7c-129">✅Pokaždé, když **je to možné, postupujte podle** návodu pro běžný [ \# styl Q](xref:microsoft.quantum.contributing.style) .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-129">✅ **DO** follow the common [Q\# style guide](xref:microsoft.quantum.contributing.style) whenever applicable.</span></span>

<span data-ttu-id="dfd7c-130">**Princip klíče:** Navrhněte rozhraní API, aby byly stabilní a poskytovaly dopředné kompatibility.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-130">**Key principle:** Design APIs to be stable and to provide forward compatibility.</span></span>

- <span data-ttu-id="dfd7c-131">✅Když **se vyžadují zásadní** změny, neúčtují stará rozhraní API korektně.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-131">✅ **DO** deprecate old APIs gracefully when breaking changes are   required.</span></span>

- <span data-ttu-id="dfd7c-132">✅**Poskytněte operace** "Shim" a funkce, které umožňují správné fungování stávajícího uživatelského kódu během vyřazení.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-132">✅ **DO** provide "shim" operations and functions that allow   existing user code to operate correctly during deprecation.</span></span>

  <span data-ttu-id="dfd7c-133">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-133">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-134">Při přejmenování operace, která je volána `EstimateExpectation` na   `EstimateAverage` , zaveďte novou operaci   `EstimateExpectation` s názvem, která volá původní operaci na svém novém názvu, aby existující kód mohl nadále fungovat správně.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-134">When renaming an operation called `EstimateExpectation` to   `EstimateAverage`, introduce a new operation called   `EstimateExpectation` that calls the original operation at   its new name, so that existing code can continue to work   correctly.</span></span>

- <span data-ttu-id="dfd7c-135">✅**Použijte** @"microsoft.quantum.core.deprecated" atribut pro komunikaci nepoužívaných uživatelů.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-135">✅ **DO** use the @"microsoft.quantum.core.deprecated" attribute to communicate deprecations to the user.</span></span>

- <span data-ttu-id="dfd7c-136">✅ Při přejmenování operace nebo **funkce zadejte nový** název jako vstup řetězce do `@Deprecated` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-136">✅ When renaming an operation or function, **DO** provide the new   name as a string input to `@Deprecated`.</span></span>

- <span data-ttu-id="dfd7c-137">pro podporované verze **se ⛔️ neodstraňují** stávající funkce ani operace, aniž by byla doba zastaralosti aspoň šest měsíců pro verze Preview nebo aspoň dva roky.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-137">⛔️ **DON'T** remove existing functions or operations without a   deprecation period of at least six months for preview releases,   or at least two years for supported releases.</span></span>

## <a name="functions-and-operations"></a><span data-ttu-id="dfd7c-138">Funkce a operace</span><span class="sxs-lookup"><span data-stu-id="dfd7c-138">Functions and Operations</span></span>

<span data-ttu-id="dfd7c-139">**Klíčový princip:** Ujistěte se, že všechny funkce a operace mají v rámci rozhraní API jeden dobře definovaný účel.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-139">**Key principle:** ensure that every function and operation has a single well-defined purpose within the API.</span></span>

- <span data-ttu-id="dfd7c-140">⛔️  nezveřejňujte funkce a operace, které provádějí více nesouvisejících úloh.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-140">⛔️ **DON'T** expose functions and operations that perform multiple   unrelated tasks.</span></span>

<span data-ttu-id="dfd7c-141">**Klíčový princip:** návrh funkcí a operací, které se mají co možná nejvíce použít, a pro předvídání budoucích potřeb.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-141">**Key principle:** design functions and operations to be as reusable as possible, and to anticipate future needs.</span></span>

- <span data-ttu-id="dfd7c-142">✅**Udělejte** návrh funkcí a operací, abyste mohli dobře začínat dalšími funkcemi a operacemi ve stejném rozhraní API i v dříve existujících knihovnách.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-142">✅ **DO** design functions and operations to compose well with other   functions and operations, both in the same API and in previously   existing libraries.</span></span>

  <span data-ttu-id="dfd7c-143">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-143">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-144">@"microsoft.quantum.canon.delay"Operace vytváří minimální předpoklady o jeho vstupu, takže se dá použít ke zpoždění aplikací obou operací v rámci Q# standardní knihovny nebo definované uživateli.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-144">The @"microsoft.quantum.canon.delay" operation makes minimal assumptions about its input, and thus can be used to delay applications of either operations across the Q# standard library or as defined by users.</span></span>
    <!-- TODO: define bad example. -->

- <span data-ttu-id="dfd7c-145">✅**Vystavte** čistě deterministické klasický Logic jako funkce namísto operací.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-145">✅ **DO** expose purely deterministic classical logic as   as functions rather than operations.</span></span>

  <span data-ttu-id="dfd7c-146">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-146">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-147">Podprogram, který má čtverce vstupu s plovoucí desetinnou čárkou, se dá napsat deterministickému, takže by měl být uživateli vystaven jako `Squared : Double -> Double` místo operace `Square : Double => Double` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-147">A subroutine which squares its floating-point input can be written deterministically, and so should be exposed to the user as `Squared : Double -> Double` rather than as an operation `Square : Double => Double`.</span></span> <span data-ttu-id="dfd7c-148">To umožňuje, aby podrutina byla volána na více místech (například uvnitř jiných funkcí) a poskytovala užitečné informace o optimalizaci kompilátoru, který může ovlivnit výkon a optimalizace.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-148">This allows for the subroutine to be called in more places (e.g.: inside of other functions), and provides useful optimization information to the compiler that can affect performance and optimizations.</span></span>
  - <span data-ttu-id="dfd7c-149">`ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` a `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` liší se zárukami provedenými v souvislosti s determinismem; obě jsou užitečné v různých případech.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-149">`ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` and `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` differ in the guarantees made with respect to   determinism; both are useful in different circumstances.</span></span>
  - <span data-ttu-id="dfd7c-150">Rutiny rozhraní API, které transformují použití operací s více poli, je často možné provádět deterministickým způsobem, takže je možné je zpřístupnit jako funkce, jako je   `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-150">API routines that transform the application of quantum   operations can often be carried out in a deterministic     fashion and hence can be made available as functions such as   `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)`.</span></span>

- <span data-ttu-id="dfd7c-151">✅**Proveďte** generalizaci vstupního typu tak, jak je to pro každou funkci a operaci přijatelné, podle potřeby pomocí parametrů typu.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-151">✅ **DO** generalize the input type as much as reasonable for each   function and operation, using type parameters as needed.</span></span>

  <span data-ttu-id="dfd7c-152">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-152">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-153">`ApplyToEach` má typ `<'T>(('T => Unit), 'T[]) => Unit` místo konkrétního typu nejběžnější aplikace, `((Qubit => Unit), Qubit[]) => Unit` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-153">`ApplyToEach` has type `<'T>(('T => Unit), 'T[]) => Unit` rather than the specific type of its most common   application, `((Qubit => Unit), Qubit[]) => Unit`.</span></span>

> [!TIP]
> <span data-ttu-id="dfd7c-154">Je důležité, abyste předpokládali budoucí potřeby, ale je také důležité řešit konkrétní problémy pro uživatele.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-154">It is important to anticipate future needs, but it is also important to solve concrete problems for your users.</span></span>
> <span data-ttu-id="dfd7c-155">Na základě tohoto klíčového principu vždy vyžaduje pečlivé zvážení a vyrovnávání, aby nedocházelo k vývoji rozhraní API "jenom v případě".</span><span class="sxs-lookup"><span data-stu-id="dfd7c-155">Acting on this key principle thus always requires careful consideration and balancing to avoid developing APIs "just in case."</span></span>

<span data-ttu-id="dfd7c-156">**Princip klíče:** vyberte vstupní a výstupní typy pro funkce a operace, které jsou předvídatelné a které komunikují účel, který je možné volat.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-156">**Key principle:** choose input and output types for functions and operations that are predictable, and that communicate the purpose of a callable.</span></span>

- <span data-ttu-id="dfd7c-157">✅**Použijte typy** řazené kolekce členů k logickému seskupení vstupů a výstupů, které jsou významné pouze při zvážení.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-157">✅ **DO** use tuple types to logically group inputs and outputs that are only significant when considered together.</span></span> <span data-ttu-id="dfd7c-158">V těchto případech zvažte použití uživatelsky definovaného typu.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-158">Consider using a user-defined type in these cases.</span></span>

  <span data-ttu-id="dfd7c-159">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-159">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-160">Funkce pro výstup místního minima jiné funkce může být potřeba přebírat meze intervalu hledání jako vstup, což `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` může být vhodný podpis.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-160">A function to output the local minima of another function   may need to take bounds of a search interval as input, such   that `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` may be an appropriate signature.</span></span>
  - <span data-ttu-id="dfd7c-161">Operace pro odhad odvozeného objektu třídění strojového učení pomocí metody posunu parametru může vyžadovat, aby se jako vstupy převzaly vektorové a neposunuté parametry.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-161">An operation to estimate a derivative of a machine learning classifier using the parameter shift technique may need to take both the shifted and unshifted parameter vectors as inputs.</span></span> <span data-ttu-id="dfd7c-162">`(unshifted : Double[], shifted : Double[])`V tomto případě může být vhodný vstup podobný tomuto.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-162">An input similar to `(unshifted : Double[], shifted : Double[])` may be appropriate in this case.</span></span>

- <span data-ttu-id="dfd7c-163">✅**Seřazení položek** ve vstupních a výstupních řazených kolekcích členů konzistentně napříč různými funkcemi a operacemi.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-163">✅ **DO** order items in input and output tuples consistently   across different functions and operations.</span></span>

  <span data-ttu-id="dfd7c-164">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-164">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-165">Při zvažování dvou nebo funkcí nebo operací, které každý z nich přebírají úhel otočení a cílový qubit jako vstup, se ujistěte, že jsou seřazené stejně v každé vstupní řazené kolekci členů.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-165">If considering two or functions or operations that each take a rotation angle and a target qubit as inputs, ensure that they are ordered the same in each input tuple.</span></span> <span data-ttu-id="dfd7c-166">To znamená, preferovat `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` a `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` a `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-166">That is, prefer `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` and `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` to `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` and `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)`.</span></span>

<span data-ttu-id="dfd7c-167">**Klíčový princip:** návrh funkcí a operací pro správnou spolupráci s funkcemi jazyka Q, jako \# je například částečná aplikace.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-167">**Key principle:** design functions and operations to work well with Q\# language features such as partial application.</span></span>

- <span data-ttu-id="dfd7c-168">✅**Seřazení položek** ve vstupních řazených kolekcích členů tak, aby nejčastěji používané vstupy probíhaly jako první (tj.: tak, aby částečné aplikace fungují podobně jako procesu curryfikace).</span><span class="sxs-lookup"><span data-stu-id="dfd7c-168">✅ **DO** order items in input tuples such that the most commonly   applied inputs occur first (i.e.: so that partial application   acts similarly to currying).</span></span>

  <span data-ttu-id="dfd7c-169">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-169">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-170">Operace `ApplyRotation` , která přebírá číslo s plovoucí desetinnou čárkou a qubit, může být často částečně aplikována se vstupem s plovoucí desetinnou čárkou pro použití s operacemi, které očekávají zadání typu `Qubit => Unit` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-170">An operation `ApplyRotation` that takes a floating-point number and a qubit as inputs may often be partially applied with the floating-point input first for use with operations that expect an input of type `Qubit => Unit`.</span></span> <span data-ttu-id="dfd7c-171">Proto signatura `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`</span><span class="sxs-lookup"><span data-stu-id="dfd7c-171">Thus, a signature of `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`</span></span>
      <span data-ttu-id="dfd7c-172">bude fungovat konzistentně s částečnou aplikací.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-172">would work most consistently with partial application.</span></span>
  - <span data-ttu-id="dfd7c-173">Obvykle tento návod znamená umístění všech klasických dat před všemi qubits ve vstupních řazených kolekcích členů, ale má dobré rozhodnutí a kontroluje, jak se rozhraní API volá v praxi.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-173">Typically, this guidance means placing all classical data   before all qubits in input tuples, but use good judgment and   examine how your API is called in practice.</span></span>

## <a name="user-defined-types"></a><span data-ttu-id="dfd7c-174">Typy User-Defined</span><span class="sxs-lookup"><span data-stu-id="dfd7c-174">User-Defined Types</span></span>

<span data-ttu-id="dfd7c-175">**Klíčový princip:** použití uživatelsky definovaných typů, které usnadňují použití rozhraní API pro lepší a pohodlné používání.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-175">**Key principle:** use user-defined types to help make APIs more expressive and convenient to use.</span></span>

- <span data-ttu-id="dfd7c-176">✅**Zaveďte nové** uživatelsky definované typy a poskytněte tak užitečné zkratky pro dlouhé a/nebo komplikované typy.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-176">✅ **DO** introduce new user-defined types to provide helpful   shorthand for long and/or complicated types.</span></span>

  <span data-ttu-id="dfd7c-177">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-177">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-178">V případech, kdy typ operace se třemi vstupy qubit pole se obvykle považuje za vstup nebo vrácený jako výstup, který poskytuje UDT jako `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`</span><span class="sxs-lookup"><span data-stu-id="dfd7c-178">In cases where an operation type with three qubit array inputs is commonly taken as an input or returned as an output, providing a UDT such as `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`</span></span>
      <span data-ttu-id="dfd7c-179">vám může pomoct zajistit užitečnou zkrácený tvar.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-179">can help provide a useful shorthand.</span></span>

- <span data-ttu-id="dfd7c-180">✅Zaveďte nové uživatelsky definované typy k **označení toho,** že daný základní typ by měl být použit pouze v velmi konkrétním smyslu.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-180">✅ **DO** introduce new user-defined types to indicate that a given   base type should only be used in a very particular sense.</span></span>

  <span data-ttu-id="dfd7c-181">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-181">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-182">Operace, která by měla být interpretována speciálně jako operace, která kóduje klasická data do registru, může být vhodná pro označení uživatelem definovaným typem `newtype InputEncoder = (Apply : (Qubit[] => Unit))` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-182">An operation that should be interpreted specifically as an   operation that encodes classical data into a quantum   register may be appropriate to label with a user-defined   type `newtype InputEncoder = (Apply : (Qubit[] => Unit))`.</span></span>

- <span data-ttu-id="dfd7c-183">✅**Zaveďte nové** uživatelsky definované typy pomocí pojmenovaných položek, které umožňují budoucí rozšíření (např.: strukturu výsledků, která může v budoucnu obsahovat další pojmenované položky).</span><span class="sxs-lookup"><span data-stu-id="dfd7c-183">✅ **DO** introduce new user-defined types with named items that   allow for future extensibility (e.g.: a results structure that   may contain additional named items in the future).</span></span>

  <span data-ttu-id="dfd7c-184">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-184">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-185">Když operace `TrainModel` zveřejňuje velký počet možností konfigurace, vystavení těchto možností jako nového   `TrainingOptions` UDT a zadání nové funkce   `DefaultTrainingOptions : Unit -> TrainingOptions` umožní uživatelům přepsat konkrétní pojmenované položky v TRAININGOPTIONS hodnotách UDT a zároveň umožnit vývojářům knihovny PŘIDÁVAT nové položky UDT podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-185">When an operation `TrainModel` exposes a large number of   configuration options, exposing these options as a new   `TrainingOptions` UDT and providing a new function   `DefaultTrainingOptions : Unit -> TrainingOptions` allows   users to override specific named items in TrainingOptions   UDT values while still allowing library developers to add   new UDT items as appropriate.</span></span>

- <span data-ttu-id="dfd7c-186">✅**Deklarujte** pojmenované položky pro nové uživatelsky definované typy v předvolbách, aby vyžadovaly, aby uživatelé znali správné rozstavbu řazené kolekce členů.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-186">✅ **DO** declare named items for new user-defined types in   preference to requiring users to know the correct tuple   deconstruction.</span></span>

  <span data-ttu-id="dfd7c-187">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-187">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-188">Když představuje komplexní číslo v jeho polárním rozkladu, dávají přednost   `newtype ComplexPolar = (Magnitude: Double, Argument: Double)`   `newtype ComplexPolar = (Double, Double)` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-188">When representing a complex number in its polar   decomposition, prefer   `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` to   `newtype ComplexPolar = (Double, Double)`.</span></span>

<span data-ttu-id="dfd7c-189">**Klíčový princip:** použití uživatelsky definovaných typů způsobem, jak omezit zátěžové zatížení a které nevyžadují, aby se uživatel dozvěděl o dalších konceptech a nomenklatuře.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-189">**Key principle:** use user-defined types in ways reduce  cognitive load and that don't require the user to learn additional concepts and nomenclature.</span></span>

- <span data-ttu-id="dfd7c-190">⛔️  nezavádí uživatelsky definované typy, které vyžadují, aby uživatel mohl často používat operátor rozbalení ( `!` ), nebo který obvykle vyžaduje více úrovní rozbalení.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-190">⛔️ **DON'T** introduce user-defined types that require the user to make frequent use of the unwrap operator (`!`), or that commonly require multiple levels of unwrapping.</span></span> <span data-ttu-id="dfd7c-191">Mezi možné strategie zmírňování patří:</span><span class="sxs-lookup"><span data-stu-id="dfd7c-191">Possible mitigation strategies include:</span></span>

  - <span data-ttu-id="dfd7c-192">Při vystavení uživatelsky definovaného typu s jednou položkou zvažte definování názvu pro tuto položku.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-192">When exposing a user-defined type with a single item, consider defining a name for that item.</span></span> <span data-ttu-id="dfd7c-193">Zvažte například `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` v Předvolby na `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-193">For instance, consider `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` in preference to `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)`.</span></span>

  - <span data-ttu-id="dfd7c-194">Zajištění, že jiné funkce a operace mohou přijímat "zabalené" instance UDT přímo.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-194">Ensuring that other functions and operations can accept   "wrapped" UDT instances directly.</span></span>

- <span data-ttu-id="dfd7c-195">⛔️  nezavádět nové uživatelsky definované typy, které duplikují předdefinované typy bez poskytnutí dalších expresivity.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-195">⛔️ **DON'T** introduce new user-defined types that duplicate   built-in types without providing additional expressiveness.</span></span>

  <span data-ttu-id="dfd7c-196">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-196">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-197">UDT `newtype QubitRegister = Qubit[]` neposkytuje žádné další expresivity nad `Qubit[]` a je proto těžší ho použít bez discernable výhody.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-197">A UDT `newtype QubitRegister = Qubit[]` provides no   additional expressiveness over `Qubit[]`, and is thus harder   to use with no discernable benefit.</span></span>
  - <span data-ttu-id="dfd7c-198">UDT `newtype LittleEndian = Qubit[]` popisuje, jak se má použít a interpretovat základní registr, a poskytuje tak další expresivity nad svým základním typem.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-198">A UDT `newtype LittleEndian = Qubit[]` documents how the   underlying register is to be used and interpreted, and thus   provides additional expressiveness over its base type.</span></span>

- <span data-ttu-id="dfd7c-199">⛔️ nezavádět funkce přistupujícího objektu, **Pokud není potřeba** striktně;   v tomto případě silně preferovat pojmenované položky.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-199">⛔️ **DON'T** introduce accessor functions unless strictly required;   strongly prefer named items in this case.</span></span>

  <span data-ttu-id="dfd7c-200">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-200">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-201">Při seznámení s `newtype Complex = (Double, Double)` rozhraním UDT preferovat změnu definice na   `newtype Complex = (Real : Double, Imag : Double)` k představení funkcí `GetReal : Complex -> Double` a   `GetImag : Complex -> Double` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-201">When introducing a UDT `newtype Complex = (Double, Double)`,   prefer modifying the definition to   `newtype Complex = (Real : Double, Imag : Double)` to introducing   functions `GetReal : Complex -> Double` and   `GetImag : Complex -> Double`.</span></span>

## <a name="namespaces-and-organization"></a><span data-ttu-id="dfd7c-202">Obory názvů a organizace</span><span class="sxs-lookup"><span data-stu-id="dfd7c-202">Namespaces and Organization</span></span>

<span data-ttu-id="dfd7c-203">**Klíčový princip:** vyberte názvy oborů názvů, které jsou předvídatelné a které jasně sdělují účel funkcí, operací a uživatelsky definovaných typů v jednotlivých oborech názvů.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-203">**Key principle:** choose namespace names that are predictable and that clearly communicate the purpose of functions, operations, and user-defined types in each namespace.</span></span>

- <span data-ttu-id="dfd7c-204">✅**Jmenujte obory názvů jako** `Publisher.Product.DomainArea` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-204">✅ **DO** name namespaces as `Publisher.Product.DomainArea`.</span></span>

  <span data-ttu-id="dfd7c-205">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-205">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-206">Funkce, operace a UDT publikované Microsoftem jako součást funkce simulace doby provozu v rámci prostředí pro vývoj provozu po částech se nacházejí v   `Microsoft.Quantum.Simulation` oboru názvů.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-206">Functions, operations, and UDTs published by Microsoft as a   part of the quantum simulation feature of the Quantum   Development Kit are placed in the   `Microsoft.Quantum.Simulation` namespace.</span></span>
  - <span data-ttu-id="dfd7c-207">`Microsoft.Quantum.Math` představuje obor názvů publikovaný společností Microsoft jako součást prostředí pro vývoj všech stavů, které se týká matematické oblasti domény.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-207">`Microsoft.Quantum.Math` represents a namespace   published by Microsoft as part of the Quantum Development   Kit pertaining to the mathematics domain area.</span></span>

- <span data-ttu-id="dfd7c-208">✅**Založte operace** , funkce a uživatelsky definované typy, které se používají pro konkrétní funkce, do oboru názvů, který popisuje tyto funkce, a to i v případě, že se tato funkce používá v různých doménách problému.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-208">✅ **DO** place operations, functions, and user-defined types used   for specific functionality into a namespace that describes that   functionality, even when that functionality is used across   different problem domains.</span></span>

  <span data-ttu-id="dfd7c-209">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-209">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-210">Rozhraní API pro přípravu stavu publikovaná Microsoftem jako součást vývojové sady pro všechna ta budou umístěna do   `Microsoft.Quantum.Preparation` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-210">State preparation APIs published by Microsoft as a part of   the Quantum Development Kit would be placed into   `Microsoft.Quantum.Preparation`.</span></span>
  - <span data-ttu-id="dfd7c-211">Rozhraní API pro simulaci nedostatku doby publikovaná společností Microsoft jako součást vývojové sady pro plnění do více částí budou umístěna do   `Microsoft.Quantum.Simulation` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-211">Quantum simulation APIs published by Microsoft as a part of the Quantum   Development Kit would be placed into   `Microsoft.Quantum.Simulation`.</span></span>

- <span data-ttu-id="dfd7c-212">✅**Založte operace** , funkce a uživatelsky definované typy používané pouze v rámci konkrétních domén do oborů názvů, které označují jejich doménu nástroje.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-212">✅ **DO** place operations, functions, and user-defined types used only within specific domains into namespaces indicating their domain of utility.</span></span> <span data-ttu-id="dfd7c-213">V případě potřeby použijte podobory názvů k označení úkolů s fokusem v rámci každého oboru názvů specifického pro doménu.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-213">If needed, use subnamespaces to indicate focused tasks within each domain-specific namespace.</span></span>

  <span data-ttu-id="dfd7c-214">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-214">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-215">Služba Machine Learning, která je publikovaná společností Microsoft, je v podstatě umístěna do @"microsoft.quantum.machinelearning" oboru názvů, ale ukázkové datové sady jsou poskytovány @"microsoft.quantum.machinelearning.datasets"   oborem názvů.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-215">The quantum machine learning library published by Microsoft is largely   placed into the @"microsoft.quantum.machinelearning" namespace, but example   datasets are provided by the @"microsoft.quantum.machinelearning.datasets"   namespace.</span></span>
  - <span data-ttu-id="dfd7c-216">Množství pro každé z nich stanoví rozhraní API, která jsou publikovaná Microsoftem jako součást vývojové sady pro všechna využívání `Microsoft.Quantum.Chemistry` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-216">Quantum chemistry APIs published by Microsoft as a part of the Quantum Development Kit should be placed into `Microsoft.Quantum.Chemistry`.</span></span> <span data-ttu-id="dfd7c-217">Funkce specifické pro implementaci Wigneru na úrovni Jordánska se můžou umístit do `Microsoft.Quantum.Chemistry.JordanWigner` , takže primární rozhraní pro chemii stavové oblasti v doméně se netýká implementací.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-217">Functionality specific to implementing the Jordan--Wigner decomposition may be placed in `Microsoft.Quantum.Chemistry.JordanWigner`, so that the primary interface for the quantum chemistry domain area is not concerned with implementations.</span></span>

<span data-ttu-id="dfd7c-218">**Princip klíče:** K úmyslnému využití plochy rozhraní API uživatelům a ke skrytí vnitřních podrobností souvisejících s implementací a testováním vašich rozhraní API používejte modifikátory oborů názvů a přístupu.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-218">**Key principle:** Use namespaces and access modifiers together to be intentional about the API surface exposed to users, and to hide internal details related to implementation and testing of your APIs.</span></span>

- <span data-ttu-id="dfd7c-219">✅ Kdykoli **je to vhodné, umístěte všechny** funkce a operace potřebné k implementaci rozhraní API do stejného oboru názvů, jako je implementované rozhraní API, ale označená "soukromá" nebo "interní" klíčová slova, která označují, že nejsou součástí veřejného prostoru rozhraní API pro knihovnu.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-219">✅ Whenever reasonable, **DO** place all functions and operations needed to implement an API into the same namespace as the API being implemented, but marked with the "private" or "internal" keywords to indicate that they are not part of the public API surface for a library.</span></span> <span data-ttu-id="dfd7c-220">Použijte název začínající podtržítkem ( `_` ) k vizuálnímu odlišení privátních a interních operací a funkcí od veřejných volat.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-220">Use a name beginning with an underscore (`_`) to visually distinguish private and internal operations and functions from public callables.</span></span>

  <span data-ttu-id="dfd7c-221">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-221">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-222">Název operace `_Features` označuje funkci, která je soukromá pro daný obor názvů a sestavení a měla by být doprovázena `internal` klíčovým slovem.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-222">The operation name `_Features` indicates a function that is   private to a given namespace and assembly, and should be   accompanied by either the `internal` keyword.</span></span>

- <span data-ttu-id="dfd7c-223">✅ V případě, že je k implementaci rozhraní API pro daný obor názvů potřeba použít rozsáhlou sadu privátních funkcí nebo operací, **umístěte je** do nového oboru názvů, který odpovídá implementovanému oboru názvů a končí `.Private` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-223">✅ In the rare case that an extensive set of private functions or operations are needed to implement the API for a given namespace, **DO** place them in a new namespace matching the namespace being implemented and ending in `.Private`.</span></span>

- <span data-ttu-id="dfd7c-224">✅Všechny testy **jednotek umístěte do** oborů názvů, které odpovídají oboru názvů pod testem a končí `.Tests` .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-224">✅ **DO** place all unit tests into namespaces matching the     namespace under test and ending in `.Tests`.</span></span>

## <a name="naming-conventions-and-vocabulary"></a><span data-ttu-id="dfd7c-225">Konvence pojmenování a slovník</span><span class="sxs-lookup"><span data-stu-id="dfd7c-225">Naming Conventions and Vocabulary</span></span>

<span data-ttu-id="dfd7c-226">**Princip klíče:** Vyberte názvy a terminologii, které jsou jasné, přístupné a čitelné v rámci nejrůznějších cílových skupin, včetně toho, co se jedná i o odborníky.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-226">**Key principle:** Choose names and terminology that are clear, accessible, and readable across a diverse range of audiences, including both quantum novices and experts.</span></span>

- <span data-ttu-id="dfd7c-227">⛔️ **nepoužívejte diskriminační** nebo vyloučení názvů identifikátorů, ani terminologie v dokumentaci k dokumentaci k rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-227">⛔️ **DON'T** use discriminatory or exclusionary identifier names,   nor terminology in API documentation comments.</span></span>

- <span data-ttu-id="dfd7c-228">✅**Použijte komentáře** k dokumentaci k rozhraní API k poskytnutí relevantního kontextu, příkladů a odkazů, zejména pro obtížnější koncepty.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-228">✅ **DO** use API documentation comments to provide relevant   context, examples, and references, especially for more difficult   concepts.</span></span>

- <span data-ttu-id="dfd7c-229">⛔️  Nepoužívejte názvy identifikátorů, které jsou zbytečně esoteričtějším nebo které vyžadují významné znalosti algoritmů pro čtení.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-229">⛔️ **DON'T** use identifier names that are unnecessarily esoteric,   or that require significant quantum algorithms knowledge to   read.</span></span>

  <span data-ttu-id="dfd7c-230">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-230">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-231">Preferovat "iteraci zesílení amplitud" na "Grover iterace"</span><span class="sxs-lookup"><span data-stu-id="dfd7c-231">Prefer "amplitude amplification iteration" to "Grover   iteration."</span></span>

- <span data-ttu-id="dfd7c-232">✅**Vyberte operace** a názvy funkcí, které jasně sdělují zamýšlený účinek, který lze volat, a nikoli jeho implementaci.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-232">✅ **DO** choose operations and function names that clearly communicate the intended effect of a callable, and not its implementation.</span></span> <span data-ttu-id="dfd7c-233">Všimněte si, že implementace může a měla by se zdokumentovat v [dokumentaci k dokumentaci k rozhraní API](xref:microsoft.quantum.qsharp.comments#documentation-comments).</span><span class="sxs-lookup"><span data-stu-id="dfd7c-233">Note that the implementation can and should be documented in [API documentation comments](xref:microsoft.quantum.qsharp.comments#documentation-comments).</span></span>

  <span data-ttu-id="dfd7c-234">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-234">*Examples:*</span></span>
  - <span data-ttu-id="dfd7c-235">Preferovat "odhad překrytí" na "Hadamard test", protože ten pak komunikuje s implementací bývalého.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-235">Prefer "estimate overlap" to "Hadamard test," as the latter   communicates how the former is implemented.</span></span>

- <span data-ttu-id="dfd7c-236">✅**Používejte slova** konzistentním způsobem napříč všemi \# rozhraními API Q:</span><span class="sxs-lookup"><span data-stu-id="dfd7c-236">✅ **DO** use words in a consistent fashion across all Q\# APIs:</span></span>

  - <span data-ttu-id="dfd7c-237">**Příkazy**</span><span class="sxs-lookup"><span data-stu-id="dfd7c-237">**Verbs:**</span></span>

    - <span data-ttu-id="dfd7c-238">**Assert**: Ověřte, jestli předpoklad týkající se stavu cílového počítače a jeho qubits obsahuje, možná pomocí nefyzických prostředků.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-238">**Assert**: Check that an assumption about the state of a target machine and its qubits holds, possibly by using unphysical resources.</span></span> <span data-ttu-id="dfd7c-239">Operace používající tuto operaci by měly být vždy bezpečně vyměnitelná bez vlivu na funkce knihoven a spustitelných programů.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-239">Operations using this verb should always be safely removable without affecting the functionality of libraries and executable programs.</span></span> <span data-ttu-id="dfd7c-240">Všimněte si, že na rozdíl od faktů mohou být kontrolní výrazy obecně závislé na externím stavu, jako je například stav registru qubit, prostředí pro spuštění nebo tak dále.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-240">Note that unlike facts, assertions may, in general, depend on external state, such as the state of a qubit register, the run environment or so forth.</span></span> <span data-ttu-id="dfd7c-241">Protože závislost na externím stavu je druh vedlejšího účinku, kontrolní výrazy musí být vystavené jako operace, nikoli funkce.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-241">As dependency on external state is a kind of side effect, assertions must be exposed as operations rather than functions.</span></span>

    - <span data-ttu-id="dfd7c-242">**Odhad**: použití jednoho nebo více možných opakovaných měření, odhadem klasického množství z výsledků měření.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-242">**Estimate**: Using one or more possibly repeated   measurements, estimate a classical quantity from   measurement results.</span></span>

      <span data-ttu-id="dfd7c-243">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-243">*Examples:*</span></span>
      - @"microsoft.quantum.characterization.estimatefrequency"
      - @"microsoft.quantum.characterization.estimateoverlapbetweenstates"

    - <span data-ttu-id="dfd7c-244">**Příprava**: použití operace nebo posloupnosti operací na jeden nebo více qubits předpokládá, že se spustí v konkrétním počátečním stavu (obvykle $ \ket{00\cdots 0} $), což způsobí, že se stav těchto qubits bude vyvíjet do požadovaného koncového stavu.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-244">**Prepare**: Apply a quantum operation or sequence of operations to one or more qubits assumed to start in a particular initial state (typically $\ket{00\cdots 0}$), causing the state of those qubits to evolve to a desired end state.</span></span> <span data-ttu-id="dfd7c-245">Obecně platí, že v případě jiných států, než je zadaný počáteční stav, **může** dojít k nedefinované jednotkové transformaci, ale **je třeba** zachovat tuto operaci a její sousední akci "zrušit výstup" a použít možnost No-op.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-245">In general, acting on states other than the given starting state **MAY** result in an undefined unitary transformation, but **SHOULD** still preserve that an operation and its adjoint "cancel out" and apply a no-op.</span></span>

      <span data-ttu-id="dfd7c-246">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-246">*Examples:*</span></span>
      - @"microsoft.quantum.preparation.preparearbitrarystate"
      - @"microsoft.quantum.preparation.prepareuniformsuperposition"

    - <span data-ttu-id="dfd7c-247">**Measure**: použijte operaci nebo sekvenci operací na jeden nebo více qubits a přečtěte si klasická data zpět.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-247">**Measure**: Apply a quantum operation or sequence of   operations to one or more qubits, reading classical data   back out.</span></span>

      <span data-ttu-id="dfd7c-248">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-248">*Examples:*</span></span>
      - @"Microsoft.Quantum.Intrinsic.Measure"
      - @"microsoft.quantum.arithmetic.measurefxp"
      - @"microsoft.quantum.arithmetic.measureinteger"

    - <span data-ttu-id="dfd7c-249">**Apply**: použijte operaci nebo sekvenci operací na jeden nebo více qubits, což způsobí, že se stav těchto qubits mění souvislým způsobem.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-249">**Apply**: Apply a quantum operation or sequence of operations to one or more qubits, causing the state of those qubits to change in a coherent fashion.</span></span> <span data-ttu-id="dfd7c-250">Tato operace je nejobecnější sloveso v \# nomenklatuře Q a **neměla by být** použita, pokud je konkrétnější příkaz přímo relevantní.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-250">This verb is the most general verb in Q\# nomenclature, and **SHOULD NOT BE** used when a more specific verb is more directly relevant.</span></span>

  - <span data-ttu-id="dfd7c-251">**Podstatná jména**:</span><span class="sxs-lookup"><span data-stu-id="dfd7c-251">**Nouns**:</span></span>

    - <span data-ttu-id="dfd7c-252">**Fakt**: logická podmínka, která závisí jenom na svých vstupech, a ne na stavu cílového počítače, jeho prostředí nebo stavu qubits počítače.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-252">**Fact**: A Boolean condition which depends only on its inputs and not on the state of a target machine, its environment, or the state of the machine's qubits.</span></span> <span data-ttu-id="dfd7c-253">Na rozdíl od kontrolního výrazu je fakt jenom citlivý na *hodnoty* , které jsou pro tuto skutečnost k dispozici.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-253">By contrast with an assertion, a fact is only sensitive to the *values* provided to that fact.</span></span> <span data-ttu-id="dfd7c-254">Příklad:</span><span class="sxs-lookup"><span data-stu-id="dfd7c-254">For example:</span></span>

      <span data-ttu-id="dfd7c-255">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-255">*Examples:*</span></span>
      - <span data-ttu-id="dfd7c-256">@"microsoft.quantum.diagnostics.equalityfacti": představuje fakt rovnosti o dvou celočíselných vstupech; celá čísla zadaná jako vstup jsou rovna sobě navzájem, nebo nejsou závislá na jakémkoli jiném stavu programu.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-256">@"microsoft.quantum.diagnostics.equalityfacti": represents an equality fact about two integer inputs; either the integers provided as input are equal to each other, or they are not, independent of any other program state.</span></span>

    - <span data-ttu-id="dfd7c-257">**Možnosti:** Typ UDT obsahující několik pojmenovaných položek, které mohou sloužit jako nepovinné argumenty pro funkci nebo operaci.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-257">**Options:** A UDT containing several named items that can act as "optional arguments" to a function or operation.</span></span> <span data-ttu-id="dfd7c-258">Příklad:</span><span class="sxs-lookup"><span data-stu-id="dfd7c-258">For example:</span></span>

      <span data-ttu-id="dfd7c-259">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-259">*Examples:*</span></span>
      - <span data-ttu-id="dfd7c-260">@"microsoft.quantum.machinelearning.trainingoptions"Parametr UDT zahrnuje pojmenované položky pro studijní kurzy, velikost minibatch a další konfigurovatelné parametry pro školení ml.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-260">The @"microsoft.quantum.machinelearning.trainingoptions" UDT includes named items for learning rate, minibatch size, and other configurable parameters for ML training.</span></span>

  - <span data-ttu-id="dfd7c-261">**Přídavná jména**:</span><span class="sxs-lookup"><span data-stu-id="dfd7c-261">**Adjectives**:</span></span>

    - <span data-ttu-id="dfd7c-262">⛔️ **novinka**: Tento adjektivum by se neměl používat, protože se **nemusíte** používat jako sloveso v řadě programovacích jazyků (například C++, C#, Java, TypeScript, PowerShell).</span><span class="sxs-lookup"><span data-stu-id="dfd7c-262">⛔️ **New**: This adjective **SHOULD NOT** be used, as to avoid confusion   with its usage as a verb in many   programming languages (e.g.: C++, C#, Java, TypeScript, PowerShell).</span></span>

  - <span data-ttu-id="dfd7c-263">**Předpozice:** V některých případech je možné použít předpozice k dalšímu jednoznačnému nebo objasnění rolí podstatných jmen a operací v názvech funkcí a operací.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-263">**Prepositions:** In some cases, prepositions can be used to further disambiguate or clarify the roles of nouns and verbs in function and operation names.</span></span> <span data-ttu-id="dfd7c-264">K tomu by se mělo dbát opatrně a konzistentně, ale</span><span class="sxs-lookup"><span data-stu-id="dfd7c-264">Care should be taken to do so sparingly and consistently, however.</span></span>

    - <span data-ttu-id="dfd7c-265">**Jako:** Představuje, že vstup a výstup funkce funkce představují stejné informace, ale výstup představuje tyto informace **jako** *X* namísto původní reprezentace.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-265">**As:** Represents that a function's input and output represent the same information, but that the output represents that information **as** an *X* instead of its original representation.</span></span> <span data-ttu-id="dfd7c-266">To je zvláště běžné pro funkce pro převod typů.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-266">This is especially common for type conversion functions.</span></span>

      <span data-ttu-id="dfd7c-267">*Příklady:*</span><span class="sxs-lookup"><span data-stu-id="dfd7c-267">*Examples:*</span></span>
      - <span data-ttu-id="dfd7c-268">`IntAsDouble(2)` označuje, že vstup ( `2` ) i výstup ( `2.0` ) reprezentují stejné informace, ale používají k tomu různé \# typy dat Q.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-268">`IntAsDouble(2)` indicates that both the input (`2`) and the output (`2.0`)   represent qualitatively the same information, but using   different Q\# data types to do so.</span></span>

    - <span data-ttu-id="dfd7c-269">**Od:** Aby se zajistila konzistence, tato předpozice   **by se neměla** používat k označení funkcí pro převod typu nebo jakéhokoli jiného případu **, pokud je to vhodné** .</span><span class="sxs-lookup"><span data-stu-id="dfd7c-269">**From:** To ensure consistency, this preposition   **SHOULD NOT** be used to indicate type conversion   functions or any other case where **As** is appropriate.</span></span>

    - <span data-ttu-id="dfd7c-270">⛔️ **na:** tato Předpozice **by se neměla** používat, protože se vyhnete nejasnostem při použití jako operace v mnoha programovacích jazycích.</span><span class="sxs-lookup"><span data-stu-id="dfd7c-270">⛔️ **To:** This preposition **SHOULD NOT** be used, as to   avoid confusion with its usage as a verb in many   programming languages.</span></span>
