---
title: 'Q # standardní knihovny – popis | Microsoft Docs'
description: 'Q # standardní knihovny – popis'
author: QuantumWriter
uid: microsoft.quantum.libraries.characterization
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 51124dc78feedf6d5c85fe224898e66a1c5ed459
ms.sourcegitcommit: ca5015fed409eaf0395a89c2e4bc6a890c360aa2
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/29/2020
ms.locfileid: "76870344"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="099aa-103">Charakterizace a statistika stavových stavů</span><span class="sxs-lookup"><span data-stu-id="099aa-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="099aa-104">Je důležité být schopné charakterizovat účinky operací, aby bylo možné vyvíjet užitečné algoritmy pro plnění.</span><span class="sxs-lookup"><span data-stu-id="099aa-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="099aa-105">To je náročné, protože každé měření systému doby využívání hodnot vychází z více bitů informací.</span><span class="sxs-lookup"><span data-stu-id="099aa-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="099aa-106">Aby se zjistilo, že se eigenvalue sám, může se stát, že se výsledky mnoha měření spojí dohromady, aby uživatel mohl glean spoustu informací potřebných k reprezentaci těchto konceptů.</span><span class="sxs-lookup"><span data-stu-id="099aa-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="099aa-107">Stavy nestavových stavů jsou obzvláště Vexing, protože [věta bez klonování](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) znamená, že neexistuje žádný způsob, jak zjistit libovolný stav z jedné kopie stavu, protože by to vedlo k vytváření kopií stavu.</span><span class="sxs-lookup"><span data-stu-id="099aa-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="099aa-108">Toto zmatení stavu nečinnosti od uživatele se projeví ve skutečnosti, že Q # nevystavuje nebo dokonce nedefinuje, k čemu *dochází* v programu.</span><span class="sxs-lookup"><span data-stu-id="099aa-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="099aa-109">Přiblížíme se k charakterizaci stavových polí tím, že se operace a stavy považují za černé. Tento přístup sdílí mnohem společné s experimentální praxí charakterizace, ověřování a ověřování (QCVV).</span><span class="sxs-lookup"><span data-stu-id="099aa-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="099aa-110">Popis je odlišný od mnoha dalších výše popsaných knihoven.</span><span class="sxs-lookup"><span data-stu-id="099aa-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="099aa-111">Účelem tohoto cíle je méně informací o klasickém informování o systému, a ne provádět jednotnou transformaci na vektoru stavu.</span><span class="sxs-lookup"><span data-stu-id="099aa-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="099aa-112">Tyto knihovny musí proto prolnout klasické i výpočetní zpracování informací.</span><span class="sxs-lookup"><span data-stu-id="099aa-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="099aa-113">Odhad iterační fáze</span><span class="sxs-lookup"><span data-stu-id="099aa-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="099aa-114">Zobrazení doby plnění v programování v souvislosti s popisem doby použitelnosti naznačuje užitečnou alternativu k odhadu fáze.</span><span class="sxs-lookup"><span data-stu-id="099aa-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="099aa-115">To znamená, že místo přípravy $n $-qubit registrovat, aby obsahovala binární reprezentaci fáze ve fázi odhadu doby plnění, můžeme zobrazit odhad fáze jako proces, při kterém se *klasický* agent seznámí s vlastnostmi systému v inventáři pomocí měření.</span><span class="sxs-lookup"><span data-stu-id="099aa-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="099aa-116">V případě použití fáze Kickback se podíváme na velká a malá písmena, aby se v případě neznámého úhlu přepnuly aplikace černého pole na rotace. tím se ale změří ancilla qubit, který v každém kroku otočíte hned po otočení.</span><span class="sxs-lookup"><span data-stu-id="099aa-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="099aa-117">To má výhodu, že pro provedení fáze kickbacku, která je popsaná v případě případu, potřebujeme jenom jeden další qubit, jak se pak postupně učí fáze z výsledků měření v jednotlivých krocích.</span><span class="sxs-lookup"><span data-stu-id="099aa-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="099aa-118">Každá z metod navrhovaných níže používá jinou strategii pro navrhování experimentů a různé metody zpracování dat pro učení fáze.</span><span class="sxs-lookup"><span data-stu-id="099aa-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="099aa-119">Každá z nich má jedinečné výhody od dodržování přísných chybových vazeb, k schopnostem začlenit předchozí informace, tolerovat chyby nebo spouštět na paměťově limitted klasických počítačích.</span><span class="sxs-lookup"><span data-stu-id="099aa-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="099aa-120">V diskuzi za iterativní fázi odhad budeme uvažovat o $U $, který je zadaný jako operace s černým polem.</span><span class="sxs-lookup"><span data-stu-id="099aa-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="099aa-121">Jak je popsáno v části pro Oracle v [datových strukturách](xref:microsoft.quantum.libraries.data-structures), Q # Canon odkazuje na operace <xref:microsoft.quantum.oracles.discreteoracle> uživatelsky definovaného typu, který je definovaný typem řazené kolekce členů `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span><span class="sxs-lookup"><span data-stu-id="099aa-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:microsoft.quantum.oracles.discreteoracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="099aa-122">Pokud `U : DiscreteOracle`, `U(m)` implementuje $U ^ m $ pro `m : Int`.</span><span class="sxs-lookup"><span data-stu-id="099aa-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="099aa-123">V rámci této definice každý krok iterativní fáze odhadování pokračuje tím, že se připraví pomocná qubit ve stavu $ \ket{+} $ spolu s počátečním stavem $ \ket{\phi} $, který předpokládáme, je [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) $U (m) $, tj. $U (m) \ket{\phi} = e ^ {im\phi} \ KET {\ fí} $.</span><span class="sxs-lookup"><span data-stu-id="099aa-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="099aa-124">Pak se použije řízená aplikace `U(m)`, která připraví stav $ \left (R\_1 (m \phi) \ket{+} \right) \ket{\phi} $.</span><span class="sxs-lookup"><span data-stu-id="099aa-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="099aa-125">Stejně jako u případných jader je účinek kontrolované aplikace `U(m)` Oracle přesně stejný jako účinek použití $R _1 $ pro neznámou fázi na $ \ket{+} $, takže můžeme jednodušším způsobem popsat účinky $U $.</span><span class="sxs-lookup"><span data-stu-id="099aa-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="099aa-126">Volitelně algoritmus poté otočí ovládací prvek qubit pomocí $R _1 (-m\theta) $ k získání stavu $ \ket{\psi} = \left (R\_1 (m [\phi-\theta]) \ket{+} \right) \ket{\phi} $ $.</span><span class="sxs-lookup"><span data-stu-id="099aa-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="099aa-127">Pomocný qubit použitý jako ovládací prvek pro `U(m)` se pak měří v $X $ a získá jednu klasický `Result`.</span><span class="sxs-lookup"><span data-stu-id="099aa-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="099aa-128">V tomto okamžiku je rekonstrukce fáze z hodnot `Result` získaných pomocí iterativní fáze odhadu klasický problém při odvozování.</span><span class="sxs-lookup"><span data-stu-id="099aa-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="099aa-129">Hledání hodnoty $m $, která získala získané informace, s ohledem na pevnou odvozenou metodu, je jednoduše problémem ve statistice.</span><span class="sxs-lookup"><span data-stu-id="099aa-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="099aa-130">Zdůrazňujeme to stručně popisující odhad iterativní fáze na teoretické úrovni v parametru bayesovského rozhodování, který se odhaduje formalitou před tím, než budete pokračovat v popisu statistických algoritmů, které jsou k dispozici v Q # Canon pro řešení problému s klasickým odvozem.</span><span class="sxs-lookup"><span data-stu-id="099aa-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="099aa-131">Odhad iterační fáze bez Eigenstates</span><span class="sxs-lookup"><span data-stu-id="099aa-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="099aa-132">Pokud je k dispozici vstupní stav, který není eigenstate, což znamená, že pokud $U (m) \ket{\phi\_j} = e ^ {im\phi\_j} $, proces odhadu fáze se nedeterministickém způsobem přesměruje na stav s jednou energií eigenstate.</span><span class="sxs-lookup"><span data-stu-id="099aa-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="099aa-133">Eigenstate, na který se nakonec konverguje, je eigenstate, který nejpravděpodobněji vyprodukuje pozorovanou `Result`.</span><span class="sxs-lookup"><span data-stu-id="099aa-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="099aa-134">Konkrétně jeden krok PE provádí následující nejednotnou transformaci stavu \begin{align} \ sum_j \sqrt{\Pr (\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac {\ sqrt {\ PR (\phi\_j)} \sqrt{\Pr (\text{Result} | \phi\_j)} \ket{\phi\_j}} {\sqrt{\Pr (\phi\_j) \sum\_j \Pr (\text{Result} | \phi\_j)}}.</span><span class="sxs-lookup"><span data-stu-id="099aa-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}.</span></span>
<span data-ttu-id="099aa-135">\end{align} v případě, že se tento proces projde více hodnotami `Result`, eigenstates, které nemají maximální hodnoty $ \ prod_k \Pr (\text{Result}\_k | \phi\_j) $, budou exponenciálně potlačeny.</span><span class="sxs-lookup"><span data-stu-id="099aa-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="099aa-136">V důsledku toho proces odvození bude v úmyslu v případě, že jsou experimenty zvoleni správně, sblížen do stavů s jediným eigenvalue.</span><span class="sxs-lookup"><span data-stu-id="099aa-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="099aa-137">Bayes ' věta dále navrhuje, že stav, který je výsledkem odhadu fáze, je zapsán ve tvaru \begin{align} \frac{\sqrt{\Pr (\phi\_j)} \sqrt{\Pr (\text{Result} | \phi\_j)} \ket{\phi\_j}} {\sqrt{\Pr (\phi\_j) \sum\_j \Pr (\text{Result} | \phi\_j)} = \ sum_j \sqrt{\Pr (\phi\_j | \text{Result})} \ket{\phi\_j}.</span><span class="sxs-lookup"><span data-stu-id="099aa-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="099aa-138">\end{align} sem $ \Pr (\phi\_j | \text{Result}) $ může být interpretted jako pravděpodobnost, že by jedna z předpokladů znamenala daný eigenstates:</span><span class="sxs-lookup"><span data-stu-id="099aa-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="099aa-139">znalosti stavu nestavení před měřením,</span><span class="sxs-lookup"><span data-stu-id="099aa-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="099aa-140">znalosti eigenstates $U $ a,</span><span class="sxs-lookup"><span data-stu-id="099aa-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="099aa-141">znalosti o eigenvalues $U $.</span><span class="sxs-lookup"><span data-stu-id="099aa-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="099aa-142">Učení těchto tří věcí je často exponenciálně pevně na klasickém počítači.</span><span class="sxs-lookup"><span data-stu-id="099aa-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="099aa-143">Nástroj odhadu fáze vzniká bez jakýchkoli malých rozsahů od faktu, že může provádět takovou úlohu učení s více částmi, aniž by bylo nutné znát jejich činnost.</span><span class="sxs-lookup"><span data-stu-id="099aa-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="099aa-144">Odhad fáze z tohoto důvodu se zobrazí v rámci řady algoritmů doby, které poskytují exponenciální urychlení.</span><span class="sxs-lookup"><span data-stu-id="099aa-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="099aa-145">Odhad fáze bayesovského rozhodování</span><span class="sxs-lookup"><span data-stu-id="099aa-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="099aa-146">Další podrobnosti o odhadu fáze bayesovského rozhodování v praxi najdete v ukázce [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation) .</span><span class="sxs-lookup"><span data-stu-id="099aa-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="099aa-147">Odhad fáze bayesovského rozhodování je jednoduchý.</span><span class="sxs-lookup"><span data-stu-id="099aa-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="099aa-148">Shromáždíte statistiku měření z protokolu odhadu fáze a potom výsledky zpracujete pomocí odvození bayesovského rozhodování a zadáním odhadu parametru.</span><span class="sxs-lookup"><span data-stu-id="099aa-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="099aa-149">Toto zpracování vám poskytne odhad eigenvalue a také nejistotu v tomto odhadu.</span><span class="sxs-lookup"><span data-stu-id="099aa-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="099aa-150">Umožňuje také provádět adaptivní experimenty a využívat předchozí informace.</span><span class="sxs-lookup"><span data-stu-id="099aa-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="099aa-151">Princip "principu" metod je, že je výpočetně náročný.</span><span class="sxs-lookup"><span data-stu-id="099aa-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="099aa-152">Chcete-li pochopit, jak tento proces odvození bayesovského rozhodování funguje, vezměte v úvahu případ zpracování jednoho `Zero`ho výsledku.</span><span class="sxs-lookup"><span data-stu-id="099aa-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="099aa-153">Všimněte si, že $X = \ket{+} \bra{+}-\ket{-}\bra{-}$, což znamená, že $ \ket{+} $ je jediným kladným eigenstateem $X $ odpovídajících `Zero`.</span><span class="sxs-lookup"><span data-stu-id="099aa-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="099aa-154">Pravděpodobnost pozorování `Zero` pro [`PauliX` měření](xref:microsoft.quantum.concepts.pauli) u prvního qubitu s ohledem na vstupní stav $ \ket{\psi}\ket{\phi} $ je tedy \begin{Equation} \Pr (\texttt{Zero} | \psi) = \left | \braket{+ | \psi} \right | ^ 2.</span><span class="sxs-lookup"><span data-stu-id="099aa-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="099aa-155">\end{Equation} v případě odhadu iterativní fáze máme to $ \ket{\psi} = R_1 (m [\phi-\theta]) \ket{+} $, například \begin{align} \Pr (\texttt{Zero} | \phi; m, \theta) & = \left | \braket{+ | R_1 (m [\phi-\theta]) | +} \right | ^ 2 \\\\ & = \left | \frac12 \left (\bra{0} + \bra{1} \right) \left (\ket{0} + e ^ {i m [\phi-\theta]} \ket{1} \right) \right | ^ 2 \\\\ & = \left | \frac{1 + e ^ {i m [\phi-\theta]}}{2} \right | ^ 2 \\\\ & = \cos ^ 2 (m [\phi-\theta]/2) \tag{★} \label{EQ: fáze-Est-pravděpodobnost}.</span><span class="sxs-lookup"><span data-stu-id="099aa-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="099aa-156">\end{align}, že odhad iterační fáze se skládá z učení četnosti kmitání funkce sinusovým, která umožňuje překlopit mince s posunem daným sinusoid.</span><span class="sxs-lookup"><span data-stu-id="099aa-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="099aa-157">Následující tradiční klasická terminologie volá $ \eqref{EQ: fáze-Est-pravděpodobnost} $ *pravděpodobnost* pro odhad iterativní fáze.</span><span class="sxs-lookup"><span data-stu-id="099aa-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="099aa-158">Zjistili jsme `Result` z pravděpodobnosti odhadu iterační fáze, můžeme pak použít pravidlo Bayes a určit, co by se mělo domnívat, že se má fáze sledovat.</span><span class="sxs-lookup"><span data-stu-id="099aa-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="099aa-159">Betonně \begin{Equation} \Pr (\phi | d) = \frac{\Pr (d | \phi) \Pr (\phi)} {\int \Pr (d | \phi) \Pr (\phi) {\mathrm d} \phi} \Pr (\phi), \end{Equation} kde $d \in \\{\texttt{Zero}, \texttt{One}\\} $ je `Result`a WHERE $ \Pr (\phi) $ popisuje náš předchozí přesvědčení o $ \phi $.</span><span class="sxs-lookup"><span data-stu-id="099aa-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="099aa-160">To pak provede iterativní povýšení iterativní fáze odhadu, jako bezprostřední distribuce $ \Pr (\phi | d) $ popisuje naše přesvědčení hned po našem sledování dalšího `Result`.</span><span class="sxs-lookup"><span data-stu-id="099aa-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceeding our observation of the next `Result`.</span></span>

<span data-ttu-id="099aa-161">V jakémkoli okamžiku tohoto postupu můžeme ohlásit fázi $ \hat{\phi} $ odvozenou klasickým kontrolérem jako \begin{Equation} \hat{\phi} \mathrel{: =} \expect [\phi | \Text{data}] = \int \phi \Pr (\phi | \Text{data}) {\mathrm d} \phi, \end{Equation} kde $ \Text{data} $ představuje celý záznam všech získaných hodnot `Result`.</span><span class="sxs-lookup"><span data-stu-id="099aa-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="099aa-162">Přesné odvození bayesovského rozhodování je v praxi nevolatelné.</span><span class="sxs-lookup"><span data-stu-id="099aa-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="099aa-163">Pokud se chcete podívat na tento příklad, chtěli bychom se naučit $n $-bitovou proměnnou $x $.</span><span class="sxs-lookup"><span data-stu-id="099aa-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="099aa-164">Předchozí distribuce $ \Pr (x) $ podporuje více než $2 ^ n $ hypotetické hodnoty $x $.</span><span class="sxs-lookup"><span data-stu-id="099aa-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="099aa-165">To znamená, že pokud potřebujeme vysoce přesný odhad $xí, odhad fáze bayesovského rozhodování může vyžadovat nepotřebnou paměť a dobu zpracování.</span><span class="sxs-lookup"><span data-stu-id="099aa-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="099aa-166">I když některé aplikace, jako je například simulace provozu, limitted vyžaduje, že tyto metody nevylučuje jiné aplikace, jako je například algoritmus Shor, nemůže v rámci kroku odhadu fáze použít přesný odvozování bayesovského rozhodování.</span><span class="sxs-lookup"><span data-stu-id="099aa-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="099aa-167">Z tohoto důvodu poskytujeme implementace přibližných bayesovského rozhodování metod, jako je například [odhad fáze postupného procházení (RWPE)](xref:microsoft.quantum.research.randomwalkphaseestimation.randomwalkphaseestimation) , a také nebayesovského rozhodováníelné přístupy, jako je například [robustní odhad fáze](xref:microsoft.quantum.characterization.robustphaseestimation).</span><span class="sxs-lookup"><span data-stu-id="099aa-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:microsoft.quantum.research.randomwalkphaseestimation.randomwalkphaseestimation) and also non-Bayesian approaches such as [robust phase estimation](xref:microsoft.quantum.characterization.robustphaseestimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="099aa-168">Robustní odhad fáze</span><span class="sxs-lookup"><span data-stu-id="099aa-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="099aa-169">Maximálně *dodatečná* bayesovského rozhodování rekonstrukce odhadu fáze z výsledků měření je exponenciálně těžká v nejhorším případě.</span><span class="sxs-lookup"><span data-stu-id="099aa-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="099aa-170">Proto většina praktických výpočetních algoritmů při odhadu nevede ke snížení kvality v rámci rekonstrukce v systému Exchange pro množství klasického následného zpracování, které se místo toho škáluje podle počtu měření.</span><span class="sxs-lookup"><span data-stu-id="099aa-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="099aa-171">Jedním z takových příkladů s efektivním krokem po zpracování klasického zpracování je [spolehlivý algoritmus odhadu fáze](https://arxiv.org/abs/1502.02677)s jeho podpisem a vstupy uvedenými nahoře.</span><span class="sxs-lookup"><span data-stu-id="099aa-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="099aa-172">Předpokládá, že vstupní $U $ se zabalí jako `DiscreteOracle` typ, a proto se jenom dotazují jenom celá čísla řízených $U $.</span><span class="sxs-lookup"><span data-stu-id="099aa-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="099aa-173">Pokud je stav vstupu v registru `Qubit[]` eigenstate $U \ket{\psi} = e ^ {i\phi} \ KET {\ psí} $, algoritmus stabilní fáze odhadování vrátí odhad $ \hat{\phi}\in [-\pi, \pi) $ $ \phi $ jako `Double`.</span><span class="sxs-lookup"><span data-stu-id="099aa-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="099aa-174">Nejdůležitější funkcí odhadu robustní fáze, která je sdílena s většinou dalšími užitečnými variantami, je, že kvalita rekonstrukce $ \hat{\phi} $ je v některém smyslu Heisenberg – omezeno.</span><span class="sxs-lookup"><span data-stu-id="099aa-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="099aa-175">To znamená, že pokud je odchylka $ \hat{\phi} $ od hodnoty true $ \sigma $, pak $ \sigma $ se škáluje v poměru k celkovému počtu dotazů $Q $ provedených na řízená – $U $, tj. $ \sigma = \mathcal{O} (1/Q) $.</span><span class="sxs-lookup"><span data-stu-id="099aa-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="099aa-176">Nyní se definice odchylek liší mezi různými algoritmy odhadu.</span><span class="sxs-lookup"><span data-stu-id="099aa-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="099aa-177">V některých případech to může znamenat, že s minimálně $ \mathcal{O} (1) $ pravděpodobností je chyba odhadu $ | \hat{\phi}-\phi |\_\circ\le \sigma $ u některé cyklické míry $ \circ $.</span><span class="sxs-lookup"><span data-stu-id="099aa-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="099aa-178">U stabilního odhadu fáze je odchylka přesnější odchylkou $ \sigma ^ 2 = \mathbb{E}\_\hat{\phi} [(\mod\_{2 \ PI} (\hat{\phi}-\phi + \pi)-\pi) ^ 2] $, pokud rozbalíme pravidelné fáze do jednoho omezeného intervalu $ (-\pi, \pi] $.</span><span class="sxs-lookup"><span data-stu-id="099aa-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="099aa-179">Směrodatná odchylka v robustním odhadu fáze je přesnější a splňuje nerovnosti $ $ \begin{align} 2,0 \pi/Q \le \sigma \le 2 \ pi/2 ^ {n} \le 10.7 \ PI/Q, \end{align} $ $, kde spodní mez dosáhla limitu maximálního množství $Q $, a horní mez je zaručená i pro malá velikost vzorků.</span><span class="sxs-lookup"><span data-stu-id="099aa-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="099aa-180">Všimněte si, že $n $ vybrané `bitsPrecision` vstupu, který implicitně definuje $Q $.</span><span class="sxs-lookup"><span data-stu-id="099aa-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="099aa-181">K dalším důležitým podrobnostem patří například malý počet režijních nákladů jenom $1 $ ancilla qubit, nebo že postup není adaptivní, což znamená, že požadovaná posloupnost experimentů na základě doby nezávisí na výsledcích mezilehlého měření.</span><span class="sxs-lookup"><span data-stu-id="099aa-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="099aa-182">V tomto a nadcházejících příkladech, kde je důležité zvolit algoritmus odhadu fáze, by měl jedna z nich odkazovat na dokumentaci, jako je @"microsoft.quantum.characterization.robustphaseestimation", a na odkazované publikace, kde najdete další informace a jejich implementaci.</span><span class="sxs-lookup"><span data-stu-id="099aa-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="099aa-183">Existuje mnoho vzorků, ve kterých se používá robustní odhad fáze.</span><span class="sxs-lookup"><span data-stu-id="099aa-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="099aa-184">V případě odhadu fáze při extrakci energie země s různými fyzickými systémy se podívejte na ukázku [ **simulace** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line), [vzorek **SimpleIsing** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple)a [ukázkový **model Hubbard** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard).</span><span class="sxs-lookup"><span data-stu-id="099aa-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="099aa-185">Kontinuální Oracle</span><span class="sxs-lookup"><span data-stu-id="099aa-185">Continuous Oracles</span></span> ###

<span data-ttu-id="099aa-186">Můžeme také zobecnit z výše uvedeného modelu Oracle, aby bylo možné používat v nepřetržitém případě Oracle modelované pomocí typu Canon <xref:microsoft.quantum.oracles.continuousoracle>.</span><span class="sxs-lookup"><span data-stu-id="099aa-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:microsoft.quantum.oracles.continuousoracle>.</span></span>
<span data-ttu-id="099aa-187">Vezměte v úvahu, že místo jednoho jednotkového operátoru $U $ máme řadu $U operátorů \mathbb{R} (t) $ pro $t \in $, což $U (t) U (t) $ = $U (t + s) $.</span><span class="sxs-lookup"><span data-stu-id="099aa-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="099aa-188">Jedná se o slabší příkaz, než v samostatném případě, protože je možné vytvořit <xref:microsoft.quantum.oracles.discreteoracle> omezením $t = m\,\delta t $ pro některé pevné $ \delta t $.</span><span class="sxs-lookup"><span data-stu-id="099aa-188">This is a weaker statement than in the discrete case, since we can construct a <xref:microsoft.quantum.oracles.discreteoracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="099aa-189">[Věta na kámen](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups)– $U (t) = \exp (i H t) $ pro nějaký operátor $H $, kde $ \exp $ je exponenciální exponenciální, jak je popsáno v tématu [Pokročilé matrice](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="099aa-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="099aa-190">Eigenstate $ \ket{\phi} $ of $H $, jako je $H \ket{\phi} = \phi \ket{\phi} $, pak také eigenstate $U (t) $ pro všechny $t $, \begin{Equation} U (t) \ket{\phi} = e ^ {i \phi t} \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="099aa-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="099aa-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="099aa-191">\end{equation}</span></span>

<span data-ttu-id="099aa-192">Stejnou analýzu, kterou popisuje [odhad fáze bayesovského rozhodování](#bayesian-phase-estimation) , lze použít a funkce pravděpodobnosti je pro tento obecnější model Oracle naprosto stejná: $ $ \Pr (\texttt{Zero} | \phi; t, \theta) = \cos ^ 2 \ Left (\frac{t [\phi-\theta]}{2}\right).</span><span class="sxs-lookup"><span data-stu-id="099aa-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="099aa-193">Pokud je navíc $U $ Simulace dynamického generátoru, stejně jako v případě [simulace Hamiltonian](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), budeme interpretovat $ \phi $ jako energii.</span><span class="sxs-lookup"><span data-stu-id="099aa-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="099aa-194">Proto použití fáze odhadu se souvislými dotazy nám umožní zjistit simulované [energetická spektrum molekul](https://arxiv.org/abs/quant-ph/0604193), [materiálů](https://arxiv.org/abs/1510.03859) nebo [polí teorie](https://arxiv.org/abs/1111.3633v2) bez nutnosti narušit náš výběr experimentů tím, že vyžaduje, $t $ jako celé číslo.</span><span class="sxs-lookup"><span data-stu-id="099aa-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="099aa-195">Odhad fáze náhodného procházení</span><span class="sxs-lookup"><span data-stu-id="099aa-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="099aa-196">Q # poskytuje užitečnou aproximaci odhadu fáze bayesovského rozhodování, která je navržena pro použití blízko u zařízení, která fungují s podmínkou náhodného procházení záznamu dat získaných z iterativní fáze odhadu.</span><span class="sxs-lookup"><span data-stu-id="099aa-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="099aa-197">Tato metoda je adaptivní i zcela deterministický a umožňuje téměř optimální škálování chyb v odhadovaných fázích $ \hat{\phi} $ s velmi nízkými náklady na paměť.</span><span class="sxs-lookup"><span data-stu-id="099aa-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="099aa-198">Protokol používá přibližnou bayesovského rozhodování odvozenou metodu, která předpokládá, že předchozí distribuce je Gaussovské.</span><span class="sxs-lookup"><span data-stu-id="099aa-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="099aa-199">Tento Gaussovské předpoklad umožňuje použití analytického vzorce pro experiment, který minimalizuje dodatečnou odchylku.</span><span class="sxs-lookup"><span data-stu-id="099aa-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="099aa-200">Algoritmus pak na základě výsledku tohoto experimentu posune odhad $ \phi $ vlevo nebo vpravo o předem stanovenou hodnotu a zmenší odchylku o předem stanovenou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="099aa-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="099aa-201">Tato střední hodnota a variance poskytují všechny informace, které jsou nutné k zadání Gaussovské před $ \phi $ pro další experiment.</span><span class="sxs-lookup"><span data-stu-id="099aa-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="099aa-202">Neočekávaná selhání měření nebo skutečný výsledek počátečních částí předchozího postupu může způsobit selhání této metody.</span><span class="sxs-lookup"><span data-stu-id="099aa-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="099aa-203">Provede experimenty k testování, zda je aktuální střední hodnota a směrodatná odchylka vhodná pro systém.</span><span class="sxs-lookup"><span data-stu-id="099aa-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="099aa-204">Pokud nejsou, pak algoritmus provede inverzní krok procházení a proces pokračuje.</span><span class="sxs-lookup"><span data-stu-id="099aa-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="099aa-205">Možnost krokovat zpět také umožňuje, aby se algoritmus zjistil i v případě, že počáteční předchozí směrodatná odchylka je inapropriately malá.</span><span class="sxs-lookup"><span data-stu-id="099aa-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="099aa-206">Algoritmy odhadu volání fáze</span><span class="sxs-lookup"><span data-stu-id="099aa-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="099aa-207">Každá operace odhadu fáze dodaná s Q # Canon používá jinou sadu vstupů Parametrizace kvality, kterou vydáváme z konečného odhadu $ \hat{\phi} $.</span><span class="sxs-lookup"><span data-stu-id="099aa-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="099aa-208">U těchto různých vstupů se ale sdílí několik běžných vstupů, takže částečná aplikace přes parametry kvality má za následek společný podpis.</span><span class="sxs-lookup"><span data-stu-id="099aa-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="099aa-209">Například operace <xref:microsoft.quantum.characterization.robustphaseestimation> popsaná v následující části má následující signaturu:</span><span class="sxs-lookup"><span data-stu-id="099aa-209">For example, the <xref:microsoft.quantum.characterization.robustphaseestimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="099aa-210">Vstup `bitsPrecision` je jedinečný pro `RobustPhaseEstimation`, zatímco `oracle` a `eigenstate` jsou společné.</span><span class="sxs-lookup"><span data-stu-id="099aa-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="099aa-211">Proto, jak je vidět v **H2Sample**, může operace přijmout algoritmus odhadu iterativní fáze se vstupním formulářem `(DiscreteOracle, Qubit[]) => Unit`, aby uživatel mohl zadat libovolné algoritmy odhadu fáze:</span><span class="sxs-lookup"><span data-stu-id="099aa-211">Thus, as seen in **H2Sample**, an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="099aa-212">Tyto algoritmy odhadu fáze nesčetných jsou optimalizované pro různé vlastnosti a vstupní parametry, které je potřeba pochopit, aby se pro cílovou aplikaci zajistila nejlepší volba.</span><span class="sxs-lookup"><span data-stu-id="099aa-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="099aa-213">Například některé algoritmy odhadu fází jsou adaptivní, což znamená, že budoucí kroky jsou classicně kontrolovány pomocí výsledků měření předchozích kroků.</span><span class="sxs-lookup"><span data-stu-id="099aa-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="099aa-214">Některá z možností vyžadují, aby bylo možné exponentiate své černé části s jednotkou Oracle podle libovolných skutečných pravomocí, a jiné vyžadují jenom celočíselné pravomoci, ale dají se jenom vyřešit odhad fáze s hodnotou modulo $2 \ PI $.</span><span class="sxs-lookup"><span data-stu-id="099aa-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="099aa-215">Některé vyžadují mnoho pomocných qubits a jiné vyžadují jenom jeden.</span><span class="sxs-lookup"><span data-stu-id="099aa-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="099aa-216">Podobně použití odhadu náhodné fáze procházení pokračuje mnohem stejným způsobem jako u jiných algoritmů dodaných s Canon:</span><span class="sxs-lookup"><span data-stu-id="099aa-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
