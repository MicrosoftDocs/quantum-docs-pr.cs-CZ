---
title: 'Q # standardní knihovny – algoritmy | Microsoft Docs'
description: Standardní knihovny jazyka Q#
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
ms.openlocfilehash: 91f65b05c83367c2d2ece93212369dc448d8c2a8
ms.sourcegitcommit: f8d6d32d16c3e758046337fb4b16a8c42fb04c39
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/29/2020
ms.locfileid: "76821010"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="82f07-103">Algoritmy doby.</span><span class="sxs-lookup"><span data-stu-id="82f07-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="82f07-104">Zvětšování amplitudy</span><span class="sxs-lookup"><span data-stu-id="82f07-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="82f07-105">*Zesílení amplitud* je jedním z základních nástrojů pro výpočetní výkon.</span><span class="sxs-lookup"><span data-stu-id="82f07-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="82f07-106">Je to základní nápad, který představuje hledání Grover, odhad amplitud a mnoho hlavních algoritmů strojového učení.</span><span class="sxs-lookup"><span data-stu-id="82f07-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="82f07-107">Existuje mnoho variant a v Q # poskytujeme obecnou verzi na základě zesílení amplitud oblivious s částečnými odrazy, které umožňují nejširší oblast aplikace.</span><span class="sxs-lookup"><span data-stu-id="82f07-107">There are many variants, and in Q# we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="82f07-108">Centrální nápad na zesílení amplitud je rozšířit pravděpodobnost požadovaného výsledku, ke kterému dochází, provedením posloupnosti odrazů.</span><span class="sxs-lookup"><span data-stu-id="82f07-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="82f07-109">Tyto odrazy otočí počáteční stav blíže k požadovanému cílovému stavu, který se často označuje jako označený stav.</span><span class="sxs-lookup"><span data-stu-id="82f07-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="82f07-110">Konkrétně platí, že pokud je pravděpodobnost měření počátečního stavu v označeném stavu, je $ \sin ^ 2 (\theta) $ poté, co se použije amplituda amplitud $m $ kolikrát se pravděpodobnost úspěchu stala $ \sin ^ 2 ((2 min + 1) \theta) $.</span><span class="sxs-lookup"><span data-stu-id="82f07-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="82f07-111">To znamená, že pokud $ \theta = \ PI/[2 (2n + 1)] $ pro určitou hodnotu $n $ pak amplituda zesílení může zvýšit pravděpodobnost úspěchu až $100\\% $ po $n $ iterace zesílení amplitudy.</span><span class="sxs-lookup"><span data-stu-id="82f07-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="82f07-112">Vzhledem k tomu, že $ \theta = \sin ^{-1}(\sqrt{\Pr (úspěch)}) $) $ to znamená, že počet iterací potřebných k obdržení úspěchu je kvadratickě nižší než očekávané číslo, které je potřeba k nalezení označeného stavu, který nedeterministické pomocí náhodného vzorkování.</span><span class="sxs-lookup"><span data-stu-id="82f07-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="82f07-113">Každá iterace zesílení amplitudy vyžaduje, aby byly zadány dva operátory reflexe.</span><span class="sxs-lookup"><span data-stu-id="82f07-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="82f07-114">Konkrétně, pokud $Q $ je iterace zesílení a $P _0 $ je operátor projektoru na počáteční mezeru a $P _1 $ je projektor na označené místo, pak $Q =-(\boldone-2P_0) (\boldone-2P_1) $.</span><span class="sxs-lookup"><span data-stu-id="82f07-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="82f07-115">Odvolání, že projektor je Hermitian operátor, který má eigenvalues $ + $1 a $0 $ a jako výsledek $ (\boldone-2P_0) $ je jednotná, protože obsahuje eigenvalues, které jsou kořeny Unity (v tomto případě $ \Pm $1).</span><span class="sxs-lookup"><span data-stu-id="82f07-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="82f07-116">Jako příklad si představte, že se v případě hledání v Grover s počátečním stavem $H ^ {\otimes n} \ket{0}$ a označili State $ \ket{m} $, $P _0 = H ^ {\otimes n} \ket{0}\bra{0}H ^ {\otimes n} $ a $P _1 = \ket{m}\bra{m} $.</span><span class="sxs-lookup"><span data-stu-id="82f07-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="82f07-117">Ve většině aplikací amplitudy zesílení $P _0 $ bude projektor do počátečního stavu, což znamená, že $P _0 = \boldone-2 \ KET {\ psí} \ Bra {\ psí} $ pro nějaký vektor $ \ket{\psi} $; Nicméně pro oblivious amplituda amplication $P _0 $ obvykle se projektuje na mnoho stavových stavů (tj. násobnost $ + $1 eigenvalue $P _0 $ je větší než $1 $).</span><span class="sxs-lookup"><span data-stu-id="82f07-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="82f07-118">Logika za zesílením amplitudy následuje přímo z Eigen-dekompozice $Q $.</span><span class="sxs-lookup"><span data-stu-id="82f07-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="82f07-119">Konkrétně eigenvectors $Q $, že počáteční stav má nenulovou podporu, se může zobrazit jako lineární $1 kombinace $P eigenvectors _0 $ a $P _1 $.</span><span class="sxs-lookup"><span data-stu-id="82f07-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="82f07-120">Konkrétně počáteční stav pro zesílení amplitudy (za předpokladu, že je to $ + $1 eigenvector of $P _0 $), může být zapsaný jako $ $ \ket{\psi} = \frac{-i}{\sqrt{2}} \left (e ^ {i\theta} \ KET {\ psi_ +} + e ^ {-i\theta} \ KET {\ psi_-} \right). $ $ Where $ \ket{\ psi_ \pm} $ jsou eigenvectors $Q $ with eigenvalues $e ^ {\Pm 2i \ théta} $ a podporují pouze eigenvectors _0 $P _1 $ a $P $. $1</span><span class="sxs-lookup"><span data-stu-id="82f07-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="82f07-121">Fakt, že eigenvalues jsou $e ^ {\Pm i \theta} $ znamená, že operátor $Q $ provede otočení v dvojrozměrném prostoru určeném dvěma projektory a počátečním stavem, kde je úhel otočení $2 \ théta $.</span><span class="sxs-lookup"><span data-stu-id="82f07-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="82f07-122">To je důvod, proč po $m $ iterace $Q $ pravděpodobnost úspěchu je $ \sin ^ 2 ([2 min + 1] \theta) $.</span><span class="sxs-lookup"><span data-stu-id="82f07-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="82f07-123">Další užitečnou vlastností, která se z nich nachází, je, že eigenvalue $ \theta $ přímo souvisí s pravděpodobností, že počáteční stav bude označený (v případě, že $P _0 $ je projektor pouze do počátečního stavu).</span><span class="sxs-lookup"><span data-stu-id="82f07-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="82f07-124">Vzhledem k tomu, že eigenphases $Q $ jsou $2 \ théta = 2 \ Sin ^{-1}(\sqrt{\Pr (úspěch)}) $, pak se vám postupuje podle toho, že pokud použijete odhad fáze na $Q $, můžeme zjistit pravděpodobnost úspěchu při použití v případě, že se jedná o postupné řízení.</span><span class="sxs-lookup"><span data-stu-id="82f07-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="82f07-125">To je užitečné, protože pro zjištění pravděpodobnosti úspěšnosti, která by jinak vyžadovala, je nutné, aby bylo v případě, že vyžaduje kvadratickou, méně aplikací tohoto postupu</span><span class="sxs-lookup"><span data-stu-id="82f07-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="82f07-126">Q # zavádí zesílení amplitud jako specializace zesílení amplitudy oblivious.</span><span class="sxs-lookup"><span data-stu-id="82f07-126">Q# introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="82f07-127">Zesílení amplitud oblivious umožňuje získat tento moniker, protože projektor na počáteční eigenspace nemusí být projektor do počátečního stavu.</span><span class="sxs-lookup"><span data-stu-id="82f07-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="82f07-128">V tomto smyslu je protokol oblivious do počátečního stavu.</span><span class="sxs-lookup"><span data-stu-id="82f07-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="82f07-129">Klíčová aplikace zesílení amplitud oblivious je v některých *lineárních kombinacích* Hamiltonian metod simulace, přičemž je v tom, že počáteční stav není znám, ale je entangled s registrem ancilla v protokolu simulace.</span><span class="sxs-lookup"><span data-stu-id="82f07-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="82f07-130">Pokud by byl tento registr ancilla měřen jako pevná hodnota, řekněme $0 $, pak tyto metody simulace aplikují požadovanou jednotnou transformaci na zbývající qubits (označované jako systémový registr).</span><span class="sxs-lookup"><span data-stu-id="82f07-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="82f07-131">U všech ostatních výsledků měření se ale povede k selhání.</span><span class="sxs-lookup"><span data-stu-id="82f07-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="82f07-132">Zesílení amplitud oblivious umožňuje zvýšit pravděpodobnost úspěchu tohoto měření na $100\\% $ pomocí výše uvedeného důvodu.</span><span class="sxs-lookup"><span data-stu-id="82f07-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="82f07-133">Navíc běžné zesílení amplitudy odpovídá případu, kde je systémový registr prázdný.</span><span class="sxs-lookup"><span data-stu-id="82f07-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="82f07-134">Důvodem je, proč Q # používá zesílení oblivious amplitud jako základní podprogram amplitudy zesílení.</span><span class="sxs-lookup"><span data-stu-id="82f07-134">This is why Q# uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="82f07-135">Obecná rutina (`AmpAmpObliviousByReflectionPhases`) má dva Registry, které voláme `ancillaRegister` a `systemRegister`.</span><span class="sxs-lookup"><span data-stu-id="82f07-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="82f07-136">Přijímá také dva Oracle pro nezbytné odrazy.</span><span class="sxs-lookup"><span data-stu-id="82f07-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="82f07-137">`ReflectionOracle` funguje pouze v `ancillaRegister`, zatímco `ObliviousOracle` pracuje společně na obou registrech.</span><span class="sxs-lookup"><span data-stu-id="82f07-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="82f07-138">Vstup do `ancillaRegister` musí být inicializován na hodnotu-1 eigenstate prvního operátoru reflexe $ \boldone-2P_1 $.</span><span class="sxs-lookup"><span data-stu-id="82f07-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="82f07-139">Obvykle Oracle připraví stav v výpočetních intervalech $ \ket{0...0} $.</span><span class="sxs-lookup"><span data-stu-id="82f07-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="82f07-140">V naší implementaci `ancillaRegister` sestávají z jednoho qubit (`flagQubit`), který řídí `stateOracle` a zbytek požadovaného ancillas.</span><span class="sxs-lookup"><span data-stu-id="82f07-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="82f07-141">`stateOracle` se použije, pokud je `flagQubit` $ \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="82f07-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="82f07-142">Jeden může také poskytovat `StateOracle` Oracle a `ObliviousOracle` namísto odrazů prostřednictvím volání `AmpAmpObliviousByOraclePhases`.</span><span class="sxs-lookup"><span data-stu-id="82f07-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="82f07-143">Jak už bylo zmíněno, tradiční zesílení amplitud je pouze zvláštní případ těchto rutin, kde `ObliviousOracle` je operátorem identity a neexistuje qubits systému (tj. `systemRegister` je prázdná).</span><span class="sxs-lookup"><span data-stu-id="82f07-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="82f07-144">Pokud chcete získat fáze pro částečné odrazy (například pro hledání Grover), je funkce `AmpAmpPhasesStandard` k dispozici.</span><span class="sxs-lookup"><span data-stu-id="82f07-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="82f07-145">Ukázkovou implementaci algoritmu Grover najdete v tématu `DatabaseSearch.qs`.</span><span class="sxs-lookup"><span data-stu-id="82f07-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="82f07-146">Připravujeme fáze qubit rotace na fáze operátoru reflexe, jak je popsáno v dokumentu [G.H. nízká, I. L. Čuangština](https://arxiv.org/abs/1707.05391).</span><span class="sxs-lookup"><span data-stu-id="82f07-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="82f07-147">Použité fáze s pevným bodem jsou podrobně popsány v [Yoder, low a Čuangština](https://arxiv.org/abs/1409.3305) spolu s fázemi v [dolních Yoder a Čuangština](https://arxiv.org/abs/1603.03996).</span><span class="sxs-lookup"><span data-stu-id="82f07-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="82f07-148">V případě pozadí můžete začít ze [standardního zesílení amplitud](https://arxiv.org/abs/quant-ph/0005055) , přejít na Úvod k [oblivious amplitud](https://arxiv.org/abs/1312.1414) a nakonec vytvořit generalize v [dolních a Čuangština](https://arxiv.org/abs/1610.06546).</span><span class="sxs-lookup"><span data-stu-id="82f07-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="82f07-149">V rámci této [Dominicy](http://www.dominicberry.org/presentations/Durban.pdf)je k disHamiltonianá prezentace s dobrým přehledem této celé oblasti (stejně jako v souvislosti s simulací).</span><span class="sxs-lookup"><span data-stu-id="82f07-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="82f07-150">Fourierova transformace</span><span class="sxs-lookup"><span data-stu-id="82f07-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="82f07-151">Fourierova transformace je základní nástroj pro klasický rozbor a je stejně důležitá pro výpočetní prostředky.</span><span class="sxs-lookup"><span data-stu-id="82f07-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="82f07-152">Kromě toho efektivita aplikace *Fourierova transformace* (QFT) daleko přebírá, co je možné na klasickém počítači, takže při navrhování algoritmu pro plnění hodnot.</span><span class="sxs-lookup"><span data-stu-id="82f07-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="82f07-153">Jako přibližné generalizace QFT poskytujeme operaci <xref:microsoft.quantum.canon.approximateqft>, která umožňuje další optimalizace vyřazením rotací, které nejsou bezpodmínečně nutné pro požadovanou přesnost algoritmu.</span><span class="sxs-lookup"><span data-stu-id="82f07-153">As an approximate generalization of the QFT, we provide the <xref:microsoft.quantum.canon.approximateqft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="82f07-154">Přibližná QFT vyžaduje operaci otočení dyadic $Z $-<xref:microsoft.quantum.intrinsic.rfrac> a operaci <xref:microsoft.quantum.intrinsic.h>.</span><span class="sxs-lookup"><span data-stu-id="82f07-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:microsoft.quantum.intrinsic.rfrac> as well as the <xref:microsoft.quantum.intrinsic.h> operation.</span></span>
<span data-ttu-id="82f07-155">Předpokládá se, že vstup a výstup mají kódování ve formátu big endian (nejnižší bitů/qubit je vlevo, totéž jako [KET Notation](xref:microsoft.quantum.concepts.dirac)).</span><span class="sxs-lookup"><span data-stu-id="82f07-155">The input and output are assumed to be encoded in big endian encoding (lowest bit/qubit is on the left, same as [ket notation](xref:microsoft.quantum.concepts.dirac)).</span></span>
<span data-ttu-id="82f07-156">Parametr aproximace $a $ určuje úroveň vyřazení $Z $-rotace, tj. $a \in [0.. n] $.</span><span class="sxs-lookup"><span data-stu-id="82f07-156">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="82f07-157">V tomto případě všechny $Z $-rotace $2 \ pi/2 ^ k $, kde $k > a $, se odeberou z okruhu QFT.</span><span class="sxs-lookup"><span data-stu-id="82f07-157">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="82f07-158">Je známo, že pro $k \ge \ log_2 (n) + \ log_2 (1/\epsilon) + $3.</span><span class="sxs-lookup"><span data-stu-id="82f07-158">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="82f07-159">jedna může být vázaná na $\\| \operatorname{QFT}-\operatorname{AQFT} \\| < \epsilon $.</span><span class="sxs-lookup"><span data-stu-id="82f07-159">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="82f07-160">Tady $\\| \cdot\\| $ je norma operátoru, která v tomto případě je druhá odmocnina největší [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) z $ (\Operatorname{QFT}-\operatorname{AQFT}) (\Operatorname{QFT}-\operatorname{AQFT}) ^ \dagger $.</span><span class="sxs-lookup"><span data-stu-id="82f07-160">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="82f07-161">Aritmetické operace</span><span class="sxs-lookup"><span data-stu-id="82f07-161">Arithmetic</span></span> ##

<span data-ttu-id="82f07-162">Stejně jako aritmetická role hraje centrální roli v klasickém výpočetním prostředí, je také indispensible ve výpočetním prostředí.</span><span class="sxs-lookup"><span data-stu-id="82f07-162">Just as arithmetic plays a central role in classical computing, it is also indispensible in quantum computing.</span></span>  <span data-ttu-id="82f07-163">Algoritmy jako algoritmus pro simulaci Shor, metody simulace a také mnoho algoritmů oracular spoléhají na souvislé aritmetické operace.</span><span class="sxs-lookup"><span data-stu-id="82f07-163">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="82f07-164">Nejvíc přístupů k aritmetickému sestavování po okruhech přidávání</span><span class="sxs-lookup"><span data-stu-id="82f07-164">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="82f07-165">Nejjednodušší přizpůsobování přebírá klasický vstup $b $ a přidává hodnotu do stavového pole s celým číslem $ \ket{a} $.</span><span class="sxs-lookup"><span data-stu-id="82f07-165">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="82f07-166">Matematicky, přidávání (což znamená, že Poznámka $ \operatorname{Add} (b) $ pro klasický vstup $b $) má vlastnost, která</span><span class="sxs-lookup"><span data-stu-id="82f07-166">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="82f07-167">$ $ \operatorname{Add} (b) \ket{a} = \ket{a + b}.</span><span class="sxs-lookup"><span data-stu-id="82f07-167">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="82f07-168">$ $ Tento okruh základního přidaných je více než přidaným objektem pro přidání.</span><span class="sxs-lookup"><span data-stu-id="82f07-168">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="82f07-169">Dá se převést na modul pro přidávání, který má dva vstupy za sebou přes $ $ \operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b}. $ $ používá $n $ řízené aplikace pro přidání do formuláře \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left (\operatorname{Add} (1) \right) \Lambda\_{a\_1} \left (\operatorname{Add} (2) \right) \Lambda\_{a\_2} \left (\operatorname{Add} (4) \right) \cdots \Lambda\_{a\_{n-1}} \left (\ operátor {Add} ({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} pro $n $-bitová čísla $a $ a $b $ a další modulo $2 ^ n $.</span><span class="sxs-lookup"><span data-stu-id="82f07-169">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="82f07-170">Odvolat, že Notation $ \Lambda\_x (A) $ odkazuje pro všechny operace $A $ na kontrolovanou verzi této operace s ovládacím prvkem qubit $x $.</span><span class="sxs-lookup"><span data-stu-id="82f07-170">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="82f07-171">Podobně klasická řízená násobení (modulární forma, která je základem pro faktor vytváření Shor), lze provádět pomocí podobné série řízených přídavků: \begin{align} \operatorname{Mult} (a) \ket{x}\ket{b} & = \Lambda\_{x\_0} \left (\operatorname{Add} (2 ^ 0 a) \right) \Lambda\_{a\_1} \left (\operatorname{Add} (2 ^ 1a) \right) \Lambda\_{a\_2} \left (\operatorname{Add} (2 ^ 2 a) \right) \cdots \Lambda\_{x\_{ n-1}} \left (\operatorname{Add} ({2 ^ {n-1}} a) \right) \ket{x}\ket{b} \\\\ & = \ket{x}\ket{b + AX}.</span><span class="sxs-lookup"><span data-stu-id="82f07-171">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="82f07-172">\end{align} je Subtlety s násobnou částí na počítačích, které si můžete všimnout od definice $ \operatorname{Mult} $ výše.</span><span class="sxs-lookup"><span data-stu-id="82f07-172">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="82f07-173">Na rozdíl od přípravné verze tohoto okruhu ukládá produkt ze vstupů v doplňkovém registru, nikoli v vstupním registru.</span><span class="sxs-lookup"><span data-stu-id="82f07-173">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="82f07-174">V tomto příkladu se registr inicializuje s hodnotou $b $, ale obvykle se začne držet hodnota nula.</span><span class="sxs-lookup"><span data-stu-id="82f07-174">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="82f07-175">To je potřeba v důsledku toho, že obecně není multiplikativní INVERT pro obecné $a $ a $x $.</span><span class="sxs-lookup"><span data-stu-id="82f07-175">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="82f07-176">Vzhledem k tomu, že všechny provozní operace, šetří měření, potřebujeme, abychom měli dostatek informací, aby bylo možné Invertovat násobení.</span><span class="sxs-lookup"><span data-stu-id="82f07-176">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="82f07-177">Z tohoto důvodu je výsledek uložen v samostatném poli.</span><span class="sxs-lookup"><span data-stu-id="82f07-177">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="82f07-178">Tento způsob uložení výstupu nevratné operace, jako je násobení, se v samostatném registru označuje jako "Bennett štych" po Charlie Bennett a je základním nástrojem v vratném i nem výpočetním prostředí.</span><span class="sxs-lookup"><span data-stu-id="82f07-178">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="82f07-179">Mnoho okruhů za sebou bylo navrženo pro přidání a každý prozkoumat různé kompromisy na základě počtu qubits (místa) a počtu potřebných operací s bránou (čas).</span><span class="sxs-lookup"><span data-stu-id="82f07-179">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="82f07-180">Prověříme dva vysoce dostupné efektivní přidávání, které je známé jako Draper přidávání a přidávání Beauregard.</span><span class="sxs-lookup"><span data-stu-id="82f07-180">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="82f07-181">Přidávání Draper</span><span class="sxs-lookup"><span data-stu-id="82f07-181">Draper Adder</span></span> ###

<span data-ttu-id="82f07-182">Přidávání Draper je pravděpodobně jedním z nejpokročilejších přidaných kódů, protože přímo vyvolá vlastnosti pro každý z nich k provedení sčítání.</span><span class="sxs-lookup"><span data-stu-id="82f07-182">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="82f07-183">Vhledem k přidávání Draper je, že transformační transformaci lze použít k posunutí fází posunu do bitového posunu.</span><span class="sxs-lookup"><span data-stu-id="82f07-183">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="82f07-184">Následně se postupuje pomocí Fourierova transformace, použití vhodných fází posunu a následnou transformací Fourierova transformace, kterou můžete použít k implementaci přidávání.</span><span class="sxs-lookup"><span data-stu-id="82f07-184">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="82f07-185">Na rozdíl od mnoha dalších přidaných přidaných, Draper přidávání explicitně používá efekty s velkým množstvím, které byly zavedeny prostřednictvím Fourierova transformace.</span><span class="sxs-lookup"><span data-stu-id="82f07-185">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="82f07-186">Nemá přirozený klasický protějšek.</span><span class="sxs-lookup"><span data-stu-id="82f07-186">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="82f07-187">Konkrétní kroky přidávání Draper jsou uvedené níže.</span><span class="sxs-lookup"><span data-stu-id="82f07-187">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="82f07-188">Předpokládejme, že máte dva $n $-bit qubit Registry ukládají celá čísla $a $ a $b $ then pro všechny $a $ $ $ \operatorname{QFT}\ket{a} = \frac{1}{\sqrt{2 ^ n}} \sum\_{j = 0} ^ {2 ^ n-1} e ^ {i2\pi (AJ)/2 ^ n} \ket{j}.</span><span class="sxs-lookup"><span data-stu-id="82f07-188">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="82f07-189">$ $ Pokud definujeme $ $ \ket{\phi\_k (a)} = \frac{1}{\sqrt{2}} \left (\ket{0} + e ^ {i2\pi a/2 ^ k} \ket{1} \right), $ $ then za některými algebraickýy vidíte, že $ $ \operatorname{QFT}\ket{a} = \ket{\phi\_1 (a)} \otimes \cdots \otimes \ket{\phi\_n (a)}.</span><span class="sxs-lookup"><span data-stu-id="82f07-189">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="82f07-190">$ $ Cesta k provedení operace přidávání se pak po zjištění, že součet vstupních hodnot může zapsat jako $ $ \ket{a + b} = \operatorname{QFT} ^{-1}\ket{\phi\_1 (a + b)} \otimes \cdots \otimes \ket{\phi\_n (a + b)}.</span><span class="sxs-lookup"><span data-stu-id="82f07-190">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="82f07-191">$ $ Celá čísla $b $ a $a $ je pak možné přidat při řízeném otočení fáze na každé qubits v rozloženém formátu pomocí ovládacích prvků $b $ as.</span><span class="sxs-lookup"><span data-stu-id="82f07-191">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="82f07-192">Toto rozšíření může být dále zjednodušené. zaznamená si, že pro libovolné celé číslo $j $ a reálné číslo $x $, $e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $.</span><span class="sxs-lookup"><span data-stu-id="82f07-192">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="82f07-193">Důvodem je to, že Pokud otočíte v kruhu $360 ^ {\circ} $ Degrees ($ 2 \ PI $ radiánů), budete mít přesně na začátku místo, kde jste začali.</span><span class="sxs-lookup"><span data-stu-id="82f07-193">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="82f07-194">Jedinou důležitou součástí $x $ for $e ^ {i2\pi x} $ je proto desetinná část $x $.</span><span class="sxs-lookup"><span data-stu-id="82f07-194">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="82f07-195">Konkrétně, pokud máme binární rozšíření formuláře $x = y +0. x\_0x\_2 \ ldots x\_n $ then $e ^ {i2\pi x} = e ^ {i2\pi (0. x\_0x\_2 \ ldots x\_{n-1})} $, tedy $ $ \ket{\phi\_k (a + b)} = \frac{1}{\sqrt{2}} \left (\ket{0} + e ^ {i2\pi [a/2 ^ k +0. b\_k\ldots b\_1]} \ket{1} \right). $ $ to znamená, že pokud provedeme další zvýšením hodnoty tensor faktory v rozšíření Fourierova transformace $ \ket{a} $, přičemž počet otočení se zmenší, protože se $k $ zmenší.</span><span class="sxs-lookup"><span data-stu-id="82f07-195">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="82f07-196">Tím se podstatně sníží počet bran, které jsou potřeba při přidávání.</span><span class="sxs-lookup"><span data-stu-id="82f07-196">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="82f07-197">Poznamenejte si kroky Fourierova transformace, fáze sčítání a invertované funkce Fourierova transformace, které tvoří Draper jako $ \operatorname{QFT} ^{-1} \left (\phi\\\!\operatorname{ADD}\right) \operatorname{QFT} $.</span><span class="sxs-lookup"><span data-stu-id="82f07-197">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="82f07-198">Okruh nároků, který používá toto zjednodušení k implementaci celého procesu, je možné zobrazit níže.</span><span class="sxs-lookup"><span data-stu-id="82f07-198">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![Zobrazení Draper jako diagram obvodu](~/media/draper.png)

<span data-ttu-id="82f07-200">Každá řízená $eá brána ^ {I2 \ pi/k} $ v okruhu odkazuje na bránu řízených fází.</span><span class="sxs-lookup"><span data-stu-id="82f07-200">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="82f07-201">Taková omezení mají vlastnost, která se nachází na páru qubits, na které jednají, $ \ket{00}\mapsto \ket{00}$, ale $ \ket{11}\mapsto e ^ {I2 \ pi/k} \ KET{11}$.</span><span class="sxs-lookup"><span data-stu-id="82f07-201">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="82f07-202">Tento okruh vám umožní doplněním bez dalších qubits kromě těch, které jsou potřeba k uložení vstupů a výstupů.</span><span class="sxs-lookup"><span data-stu-id="82f07-202">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="82f07-203">Přidávání Beauregard</span><span class="sxs-lookup"><span data-stu-id="82f07-203">Beauregard Adder</span></span> ###

<span data-ttu-id="82f07-204">Přidávání Beauregard je modulární přizpůsobování, které používá přidávání Draper, aby se daly přidat modulo $N $ pro libovolnou hodnotu kladné celé číslo $N $.</span><span class="sxs-lookup"><span data-stu-id="82f07-204">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="82f07-205">Význam modulárních přidaných modulů, jako je například přidání Beauregard, je ve velkém rozsahu od jejich použití v modulárním umocněném kroku v rámci Shor algoritmu pro účely faktoringu.</span><span class="sxs-lookup"><span data-stu-id="82f07-205">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="82f07-206">Modulární přihlašování do modulárního příprocesoru má následující akci pro vstupy a výstupy na $a \ket{b} $, kde $a $ a $b $ jsou přislíbené jako celá čísla $N $, což znamená, že jsou v intervalu $ [0, \ldots, N-1] $.</span><span class="sxs-lookup"><span data-stu-id="82f07-206">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="82f07-207">$ $ \ket{b}\rightarrow \ket{b + a \Text{mod} N} = \begin{Cases} \ket{b + a}, & b + < N\\\\ \ket{b + a-N}, & (b + a) \ge N \end{Cases}.</span><span class="sxs-lookup"><span data-stu-id="82f07-207">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="82f07-208">K přidání $a $ a $b $ ve fázi Beauregard přidáváte pomocí přidávání Draper, nebo speciálně \!\phi\\\operatorname{ADD} $.</span><span class="sxs-lookup"><span data-stu-id="82f07-208">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="82f07-209">Pak používá stejnou operaci k určení, zda $a + b < N $ pomocí odečítání $N $ a testování, pokud $a + b-N < 0 $.</span><span class="sxs-lookup"><span data-stu-id="82f07-209">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="82f07-210">Okruh tyto informace uchovává v doplňkovém qubit a potom přidá $N $ back-Register, pokud $a + b < N $.</span><span class="sxs-lookup"><span data-stu-id="82f07-210">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="82f07-211">Pak ukončí nevýpočetní Tento doplňkový bit (Tento krok je nutný, aby bylo zajištěno, že ancilla lze po volání přidávání zrušit přidělení).</span><span class="sxs-lookup"><span data-stu-id="82f07-211">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="82f07-212">Okruh pro přidání Beauregard je uveden níže.</span><span class="sxs-lookup"><span data-stu-id="82f07-212">The circuit for the Beauregard adder is given below.</span></span>

![Zobrazení Beauregard jako diagram obvodu](~/media/beau.png)

<span data-ttu-id="82f07-214">Tady je brána $ \phi\\\!\operatorname{ADD} $ má stejný tvar jako $ \phi\\\!\operatorname{ADD} $ s tím rozdílem, že v tomto kontextu je vstup klasický, ale nejedná se o něj.</span><span class="sxs-lookup"><span data-stu-id="82f07-214">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="82f07-215">To umožňuje, aby řízené fáze v $ \phi\\\!\operatorname{ADD} $ nahradily fázemi, které se pak dají kompilovat do menšího počtu operací, aby se snížil počet qubits a počet bran potřebných pro daný modul.</span><span class="sxs-lookup"><span data-stu-id="82f07-215">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="82f07-216">Další podrobnosti najdete v tématu [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) a [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span><span class="sxs-lookup"><span data-stu-id="82f07-216">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="82f07-217">Odhad kvantové fáze</span><span class="sxs-lookup"><span data-stu-id="82f07-217">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="82f07-218">Jednou obzvláště důležitou aplikací pro Fourierova transformaci je naučit se eigenvaluesí jednotlivých operátorů, problém známý jako *odhad fáze*.</span><span class="sxs-lookup"><span data-stu-id="82f07-218">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation*.</span></span>
<span data-ttu-id="82f07-219">Vezměte v úvahu jednotkové $U $ a State $ \ket{\phi} $, což znamená, že $ \ket{\phi} $ je eigenstate $U $ s neznámým eigenvalue $ \phi $, \begin{Equation} U\ket {\ fí} = \phi\ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="82f07-219">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="82f07-220">\end{Equation} Pokud máme přístup pouze k $U $ jako Oracle, můžeme se naučit fázi $ \phi $ pomocí toho, že $Z $ rotace aplikovaná na cíl kontrolované operace se rozšíří zpátky na ovládací prvek.</span><span class="sxs-lookup"><span data-stu-id="82f07-220">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="82f07-221">Předpokládejme, že $V $ je řízená aplikace $U $, například \begin{align} V (\ket{0} \otimes \ket{\phi}) & = \ket{0} \otimes \ket{\phi} \\\\ \textrm{a} V (\ket{1} \otimes \ket{\phi}) & = e ^ {i \phi} \ket{1} \otimes \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="82f07-221">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="82f07-222">\end{Align} a potom lineární, \begin{align} V (\ket{+} \otimes \ket{\phi}) & = \frac{(\ket{0} \otimes \ket{\phi}) + e ^ {i \phi} (\ket{1} \otimes \ket{\phi})} {\sqrt{2}}.</span><span class="sxs-lookup"><span data-stu-id="82f07-222">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="82f07-223">\end{align} můžeme shromažďovat výrazy, abychom zjistili, že \begin{align} V (\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e ^ {i \phi} \ket{1}} {\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1 (\phi) \ket{+}) \otimes \ket{\phi}, \end{align}, kde $R _1 $ je jednotná operace <xref:microsoft.quantum.intrinsic.r1>.</span><span class="sxs-lookup"><span data-stu-id="82f07-223">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:microsoft.quantum.intrinsic.r1> operation.</span></span>
<span data-ttu-id="82f07-224">Nefunguje jinak, účinek použití $V $ je přesně stejný jako při použití $R _1 $ s neznámým úhlem, i když máme přístup pouze k $V $ jako Oracle.</span><span class="sxs-lookup"><span data-stu-id="82f07-224">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="82f07-225">Proto se pro zbytek této diskuze podíváme na fázi odhadu v souvislosti s $R _1 (\phi) $, kterou implementujeme pomocí *Kickback fáze*s názvem.</span><span class="sxs-lookup"><span data-stu-id="82f07-225">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback*.</span></span>

<span data-ttu-id="82f07-226">Vzhledem k tomu, že registr řízení a cíle zůstane untangled po tomto procesu, můžeme použít $ \ket{\phi} $ jako cíl kontrolované aplikace $U ^ $2 a připravit druhý qubit ovládacího prvku ve stavu $R _1 (2 \phi) \ket{+} $.</span><span class="sxs-lookup"><span data-stu-id="82f07-226">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="82f07-227">V tomto případě můžeme získat registraci formuláře \begin{align} \ket{\psi} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j \phi) \ket{+} \\\\ & \propto \ bigotimes_ {j = 0} ^ {n} \left (\ket{0} + \exp (i 2 ^ {j} \phi) \ket{1}\right) \\\\ & \propto \ sum_ {k = 0} ^ {2 ^ n-1} \exp (i \phi k) \ket{k} \end{align}, kde $n $ je počet bitů s přesností, které vyžadujeme. a tam, kde jsme použili ${} \propto {}$ k označení toho, že jsme potlačili faktor normalizace $ 1/\sqrt{2 ^ n} $.</span><span class="sxs-lookup"><span data-stu-id="82f07-227">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="82f07-228">Pokud předpokládáme, že $ \phi = 2 \pi p/2 ^ k $ pro celé číslo $p $, rozpoznáme to jako $ \ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n} $, kde $p _J $ je $j ^ {\textrm{th}} $ bit of $2 \pi \phi $.</span><span class="sxs-lookup"><span data-stu-id="82f07-228">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="82f07-229">Když použijete sousedící transformaci Fourierova transformace, získáme proto binární reprezentace fáze kódované jako stav pro stav.</span><span class="sxs-lookup"><span data-stu-id="82f07-229">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="82f07-230">V Q # to je implementováno operací <xref:microsoft.quantum.characterization.quantumphaseestimation>, která přebírá <xref:microsoft.quantum.oracles.discreteoracle> implementující aplikaci $U ^ m $ jako funkci kladných celých čísel $m $.</span><span class="sxs-lookup"><span data-stu-id="82f07-230">In Q#, this is implemented by the <xref:microsoft.quantum.characterization.quantumphaseestimation> operation, which takes a <xref:microsoft.quantum.oracles.discreteoracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
