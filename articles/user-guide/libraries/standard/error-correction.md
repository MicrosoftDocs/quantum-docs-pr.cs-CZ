---
title: 'Oprava chyb ve Q# standardních knihovnách'
description: 'Naučte se, jak používat chyby při opravování kódů v Q# programech při ochraně stavu qubits.'
author: QuantumWriter
uid: microsoft.quantum.libraries.error-correction
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- 'Q#'
- '$$v'
ms.openlocfilehash: 94251e185cea65c5fc08ed70d5fba9b7b19501e3
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692044"
---
# <a name="error-correction"></a><span data-ttu-id="d6083-103">Oprava chyb</span><span class="sxs-lookup"><span data-stu-id="d6083-103">Error Correction</span></span> #

## <a name="introduction"></a><span data-ttu-id="d6083-104">Úvod</span><span class="sxs-lookup"><span data-stu-id="d6083-104">Introduction</span></span> ##

<span data-ttu-id="d6083-105">Pokud jeden z klasických výpočetních prostředků chce chránit bitovou kopii proti chybám, může to často stačit k tomu, aby tento bit představoval *logický bit* opakováním datového bitu.</span><span class="sxs-lookup"><span data-stu-id="d6083-105">In classical computing, if one wants to protect a bit against errors, it can often suffice to represent that bit by a *logical bit* by repeating the data bit.</span></span>
<span data-ttu-id="d6083-106">Například let $ \overline {0} = $0 je kódování datového bitu 0, kde používáme řádek nad popiskem 0 k označení toho, že se jedná o kódování bitu ve stavu 0.</span><span class="sxs-lookup"><span data-stu-id="d6083-106">For instance, let $\overline{0} = 000$ be the encoding of the data bit 0, where we use the a line above the label 0 to indicate that it is an encoding of a bit in the 0 state.</span></span>
<span data-ttu-id="d6083-107">Pokud obdobně ponecháme $ \overline {1} = $111, máme k dispozici jednoduchý kód opakování, který chrání proti libovolné bitové chybě překlopení.</span><span class="sxs-lookup"><span data-stu-id="d6083-107">If we similarly let $\overline{1} = 111$, then we have a simple repetition code that protects against any one bit flip error.</span></span>
<span data-ttu-id="d6083-108">To znamená, že pokud se některé ze tří bitů překlopí, můžeme obnovit stav logického bitu tím, že vyberete většinou hlasů.</span><span class="sxs-lookup"><span data-stu-id="d6083-108">That is, if any of the three bits are flipped, then we can recover the state of the logical bit by taking a majority vote.</span></span>
<span data-ttu-id="d6083-109">I když klasická chyba je mnohem rozsáhlejší, že tento konkrétní příklad (doporučujeme [Lint Úvod do kódování](https://www.springer.com/us/book/9783540641339)), výše uvedený kód opakování již odkazuje na možný problém při ochraně stavových kódů.</span><span class="sxs-lookup"><span data-stu-id="d6083-109">Though classical error correction is a much richer subject that this particular example (we recommend [Lint's introduction to coding theory](https://www.springer.com/us/book/9783540641339)), the repetition code above already points to a possible problem in protecting quantum information.</span></span>
<span data-ttu-id="d6083-110">To znamená, že pokud si [věta žádného klonování](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) , znamená to, že pokud si vyměříme jednotlivé qubity a v případě, že použijete stejný hlas na klasický kód výše, ztratili jsme přesné informace, které se snažíme chránit.</span><span class="sxs-lookup"><span data-stu-id="d6083-110">Namely, the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) implies that if we measure each individual qubit and take a majority vote by analogy to classical code above, then we have lost the precise information that we are trying to protect.</span></span>

<span data-ttu-id="d6083-111">V nastavení pro stavové pole uvidíme, že měření je problematické.</span><span class="sxs-lookup"><span data-stu-id="d6083-111">In the quantum setting, we will see that the measurement is problematic.</span></span> <span data-ttu-id="d6083-112">Přesto můžeme implementovat kódování uvedené výše.</span><span class="sxs-lookup"><span data-stu-id="d6083-112">We can still implement the encoding above.</span></span>
<span data-ttu-id="d6083-113">To je užitečné, pokud chcete zjistit, jak můžeme provést generalizaci opravy chyb na případ.</span><span class="sxs-lookup"><span data-stu-id="d6083-113">It is helpful to do so to see how we can generalize error correction to the quantum case.</span></span>
<span data-ttu-id="d6083-114">Proto $ \ket{\overline {0} } = \ket {000} = \ket {0} \otimes \ket {0} \otimes \ket {0} $ a let $ \ket{\overline {1} } = \ket {111} $.</span><span class="sxs-lookup"><span data-stu-id="d6083-114">Thus, let $\ket{\overline{0}} = \ket{000} = \ket{0} \otimes \ket{0} \otimes \ket{0}$, and let $\ket{\overline{1}} = \ket{111}$.</span></span>
<span data-ttu-id="d6083-115">Po linearitě jsme pro všechny vstupy definovali náš kód opakování. např. $ \ket{\overline{+}} = (\ket{\overline {0} } + \ket{\overline {1} })/\sqrt {2} = (\ket {000} + \ket {111} )/\sqrt {2} $.</span><span class="sxs-lookup"><span data-stu-id="d6083-115">Then, by linearity, we have defined our repetition code for all inputs; for instance, $\ket{\overline{+}} = (\ket{\overline{0}} + \ket{\overline{1}}) / \sqrt{2} = (\ket{000} + \ket{111}) / \sqrt{2}$.</span></span>
<span data-ttu-id="d6083-116">Konkrétně v důsledku překlopení chyby $X _1 $ Act v prostředních qubit jsme zjistili, že oprava potřebná v obou větvích je přesně $X _1 $: $ $ \begin{align} X_1 \ket{\overline{+}} & = \frac {1} {\sqrt {2} } \left (X_1 \ket {000} + X_1 \ket {111} \right) \\ \\ & = \frac {1} {\sqrt {2} } \left (\ket {010} + \ket {101} \right).</span><span class="sxs-lookup"><span data-stu-id="d6083-116">In particular, letting a bit-flip error $X_1$ act on the middle qubit, we see that the correction needed in both branches is precisely $X_1$: $$ \begin{align} X_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left( X_1 \ket{000} + X_1 \ket{111} \right) \\\\ & = \frac{1}{\sqrt{2}} \left( \ket{010} + \ket{101} \right).</span></span>
<span data-ttu-id="d6083-117">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="d6083-117">\end{align} $$</span></span>

<span data-ttu-id="d6083-118">Pokud se chcete podívat, jak můžeme zjistit, že se jedná o tento případ bez měření velmi velkého stavu, který se snažíme chránit, je užitečné, abyste si vyzkoušeli, co každá z různých bitových překlopných chyb dělá u našich logických stav</span><span class="sxs-lookup"><span data-stu-id="d6083-118">To see how we can identify that this is the case without measuring the very state we are trying to protect, it is helpful to write down what each different bit flip error does to our logical states:</span></span>

| <span data-ttu-id="d6083-119">Chyba $E $</span><span class="sxs-lookup"><span data-stu-id="d6083-119">Error $E$</span></span> | <span data-ttu-id="d6083-120">$E \ket{\overline {0} } $</span><span class="sxs-lookup"><span data-stu-id="d6083-120">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="d6083-121">$E \ket{\overline {1} } $</span><span class="sxs-lookup"><span data-stu-id="d6083-121">$E\ket{\overline{1}}$</span></span> |
| --- | --- | --- |
| <span data-ttu-id="d6083-122">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="d6083-122">$\boldone$</span></span> | <span data-ttu-id="d6083-123">$ \ket {000} $</span><span class="sxs-lookup"><span data-stu-id="d6083-123">$\ket{000}$</span></span> | <span data-ttu-id="d6083-124">$ \ket {111} $</span><span class="sxs-lookup"><span data-stu-id="d6083-124">$\ket{111}$</span></span> |
| <span data-ttu-id="d6083-125">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="d6083-125">$X_0$</span></span> | <span data-ttu-id="d6083-126">$ \ket {100} $</span><span class="sxs-lookup"><span data-stu-id="d6083-126">$\ket{100}$</span></span> | <span data-ttu-id="d6083-127">$ \ket {011} $</span><span class="sxs-lookup"><span data-stu-id="d6083-127">$\ket{011}$</span></span> |
| <span data-ttu-id="d6083-128">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="d6083-128">$X_1$</span></span> | <span data-ttu-id="d6083-129">$ \ket {010} $</span><span class="sxs-lookup"><span data-stu-id="d6083-129">$\ket{010}$</span></span> | <span data-ttu-id="d6083-130">$ \ket {101} $</span><span class="sxs-lookup"><span data-stu-id="d6083-130">$\ket{101}$</span></span> |
| <span data-ttu-id="d6083-131">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="d6083-131">$X_2$</span></span> | <span data-ttu-id="d6083-132">$ \ket {001} $</span><span class="sxs-lookup"><span data-stu-id="d6083-132">$\ket{001}$</span></span> | <span data-ttu-id="d6083-133">$ \ket {110} $</span><span class="sxs-lookup"><span data-stu-id="d6083-133">$\ket{110}$</span></span> |

<span data-ttu-id="d6083-134">Abychom chránili stav, který kódujeme, musíme být schopni odlišit tři chyby od sebe navzájem a z identity $ \boldone $ bez rozlišení mezi $ \ket{\overline {0} } $ a $ \ket{\overline {1} } $.</span><span class="sxs-lookup"><span data-stu-id="d6083-134">In order to protect the state that we're encoding, we need to be able to distinguish the three errors from each other and from the identity $\boldone$ without distinguishing between $\ket{\overline{0}}$ and $\ket{\overline{1}}$.</span></span>
<span data-ttu-id="d6083-135">Pokud například měříme $Z _0 $, získáme jiný výsledek pro $ \ket{\overline {0} } $ a $ \ket{\overline {1} } $ v případu No-Error, takže se sbalí kódovaný stav.</span><span class="sxs-lookup"><span data-stu-id="d6083-135">For example, if we measure $Z_0$, we get a different result for $\ket{\overline{0}}$ and $\ket{\overline{1}}$ in the no-error case, so that collapses the encoded state.</span></span>
<span data-ttu-id="d6083-136">Na druhé straně zvažte měření $Z _0 Z_1 $, paritu prvních dvou bitů v každém výpočetním stavu.</span><span class="sxs-lookup"><span data-stu-id="d6083-136">On the other hand, consider measuring $Z_0 Z_1$, the parity of the first two bits in each computational basis state.</span></span>
<span data-ttu-id="d6083-137">Načtěte si, že každé měření Pauli operátoru kontroluje, které eigenvalue se má měřit, takže pro každý stav $ \ket{\psi} $ v tabulce výše můžeme vypočítat $Z _0 Z_1 \ket{\psi} $, abyste zjistili, jestli se vrátíme $ \pm\ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="d6083-137">Recall that each measurement of a Pauli operator checks which eigenvalue  the state being measured corresponds to, so for each state $\ket{\psi}$ in the table above, we can compute $Z_0 Z_1 \ket{\psi}$ to see if we get $\pm\ket{\psi}$.</span></span>
<span data-ttu-id="d6083-138">Všimněte si, že $Z _0 Z_1 \ket {000} = \ket {000} $ a $Z _0 Z_1 \ket {111} = \ket {111} $, takže jsme uzavřeli, že toto měření bude stejné jako u kódovaných stavů.</span><span class="sxs-lookup"><span data-stu-id="d6083-138">Note that $Z_0 Z_1 \ket{000} = \ket{000}$ and that $Z_0 Z_1 \ket{111} = \ket{111}$, so that we conclude that this measurement does the same thing to both encoded states.</span></span>
<span data-ttu-id="d6083-139">Na druhé straně $Z _0 Z_1 \ket {100} =-\ket {100} $ a $Z _0 Z_1 \ket {011} =-\ket {011} $, takže výsledek měření $Z _0 Z_1 $ odhalí užitečné informace o tom, která chyba nastala.</span><span class="sxs-lookup"><span data-stu-id="d6083-139">On the other hand, $Z_0 Z_1 \ket{100} = - \ket{100}$ and $Z_0 Z_1 \ket{011} = -\ket{011}$, so the result of measuring $Z_0 Z_1$ reveals useful information about which error occurred.</span></span>

<span data-ttu-id="d6083-140">Pokud to chcete zdůraznit, opakujeme tabulku výše, ale do každého řádku přidejte výsledky měření $Z _0 Z_1 $ a $Z _1y Z_2 $.</span><span class="sxs-lookup"><span data-stu-id="d6083-140">To emphasize this, we repeat the table above, but add the results of measuring $Z_0 Z_1$ and $Z_1 Z_2$ on each row.</span></span>
<span data-ttu-id="d6083-141">Poznamenejte si výsledky každého měření pomocí znaménka eigenvalue, který je pozorován, buď $ + $ nebo $-$, který odpovídá Q# `Result` hodnotám v `Zero` a v `One` uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="d6083-141">We denote the results of each measurement by the sign of the eigenvalue that is observed, either $+$ or $-$, corresponding to the Q# `Result` values of `Zero` and `One`, respectively.</span></span>

| <span data-ttu-id="d6083-142">Chyba $E $</span><span class="sxs-lookup"><span data-stu-id="d6083-142">Error $E$</span></span> | <span data-ttu-id="d6083-143">$E \ket{\overline {0} } $</span><span class="sxs-lookup"><span data-stu-id="d6083-143">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="d6083-144">$E \ket{\overline {1} } $</span><span class="sxs-lookup"><span data-stu-id="d6083-144">$E\ket{\overline{1}}$</span></span> | <span data-ttu-id="d6083-145">Výsledek $Z _0 Z_1 $</span><span class="sxs-lookup"><span data-stu-id="d6083-145">Result of $Z_0 Z_1$</span></span> | <span data-ttu-id="d6083-146">Výsledek $Z _1 Z_2 $</span><span class="sxs-lookup"><span data-stu-id="d6083-146">Result of $Z_1 Z_2$</span></span> |
| --- | --- | --- | --- | --- |
| <span data-ttu-id="d6083-147">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="d6083-147">$\boldone$</span></span> | <span data-ttu-id="d6083-148">$ \ket {000} $</span><span class="sxs-lookup"><span data-stu-id="d6083-148">$\ket{000}$</span></span> | <span data-ttu-id="d6083-149">$ \ket {111} $</span><span class="sxs-lookup"><span data-stu-id="d6083-149">$\ket{111}$</span></span> | $+$ | $+$ |
| <span data-ttu-id="d6083-150">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="d6083-150">$X_0$</span></span> | <span data-ttu-id="d6083-151">$ \ket {100} $</span><span class="sxs-lookup"><span data-stu-id="d6083-151">$\ket{100}$</span></span> | <span data-ttu-id="d6083-152">$ \ket {011} $</span><span class="sxs-lookup"><span data-stu-id="d6083-152">$\ket{011}$</span></span> | $-$ | $+$ |
| <span data-ttu-id="d6083-153">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="d6083-153">$X_1$</span></span> | <span data-ttu-id="d6083-154">$ \ket {010} $</span><span class="sxs-lookup"><span data-stu-id="d6083-154">$\ket{010}$</span></span> | <span data-ttu-id="d6083-155">$ \ket {101} $</span><span class="sxs-lookup"><span data-stu-id="d6083-155">$\ket{101}$</span></span> | $-$ | $-$ |
| <span data-ttu-id="d6083-156">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="d6083-156">$X_2$</span></span> | <span data-ttu-id="d6083-157">$ \ket {001} $</span><span class="sxs-lookup"><span data-stu-id="d6083-157">$\ket{001}$</span></span> | <span data-ttu-id="d6083-158">$ \ket {110} $</span><span class="sxs-lookup"><span data-stu-id="d6083-158">$\ket{110}$</span></span> | $+$ | $-$ |

<span data-ttu-id="d6083-159">Proto výsledky dvou měření jednoznačně určují, jakou chybu překlopení došlo k chybě, ale bez odhalení informací o tom, jaký stav je zakódovaný.</span><span class="sxs-lookup"><span data-stu-id="d6083-159">Thus, the results of the two measurements uniquely determines which bit-flip error occurred, but without revealing any information about which state we encoded.</span></span>
<span data-ttu-id="d6083-160">Tyto výsledky říkáme *Syndrome* a přečtěte si proces mapování Syndrome zpátky na chybu, která způsobila *obnovení* .</span><span class="sxs-lookup"><span data-stu-id="d6083-160">We call these results a *syndrome* , and refer to the process of mapping a syndrome back to the error that caused it as *recovery* .</span></span>
<span data-ttu-id="d6083-161">Zejména jsme zdůraznili, že obnovení je *klasický* postup odvození, který jako svůj vstup přebírá Syndrome, ke kterému došlo, a vrátí předpis pro opravu chyb, ke kterým mohlo dojít.</span><span class="sxs-lookup"><span data-stu-id="d6083-161">In particular, we emphasize that recovery is a *classical* inference procedure which takes as its input the syndrome which occurred, and returns a prescription for how to fix any errors that may have occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="d6083-162">Výše uvedený kód překlápění lze opravit pouze proti chybám s jedním překlopením; To znamená, že `X` operace funguje na jednom qubit.</span><span class="sxs-lookup"><span data-stu-id="d6083-162">The bit-flip code above can only correct against single bit-flip errors; that is, an `X` operation acting on a single qubit.</span></span>
> <span data-ttu-id="d6083-163">Použití `X` na více než jeden qubit bude namapovat $ \ket{\overline {0} } $ na $ \ket{\overline {1} } $ po obnovení.</span><span class="sxs-lookup"><span data-stu-id="d6083-163">Applying `X` to more than one qubit will map $\ket{\overline{0}}$ to $\ket{\overline{1}}$ following recovery.</span></span>
> <span data-ttu-id="d6083-164">Podobně při použití operace překlápění fáze `Z` se namapuje $ \ket{\overline {1} } $ na $-\ket{\overline {1} } $, a proto se namapuje $ \ket{\overline{+}} $ na $ \ket{\overline {-} } $.</span><span class="sxs-lookup"><span data-stu-id="d6083-164">Similarly, applying a phase flip operation `Z` will map $\ket{\overline{1}}$ to $-\ket{\overline{1}}$, and hence will map $\ket{\overline{+}}$ to $\ket{\overline{-}}$.</span></span>
> <span data-ttu-id="d6083-165">Obecněji je možné vytvářet kódy pro zpracování většího počtu chyb a zpracovávat chyby $Z $ a také chyby $X $.</span><span class="sxs-lookup"><span data-stu-id="d6083-165">More generally, codes can be created to handle larger number of errors, and to handle $Z$ errors as well as $X$ errors.</span></span>

<span data-ttu-id="d6083-166">Vhledem, jak můžeme popsat měření při opravách chyb, která působí stejným způsobem u všech stavů kódu, je podstata *formalit na stabilizaci* .</span><span class="sxs-lookup"><span data-stu-id="d6083-166">The insight that we can describe measurements in quantum error correction that act the same way on all code states, is the essence of the *stabilizer formalism* .</span></span>
<span data-ttu-id="d6083-167">Q#Canon poskytuje rozhraní pro popis kódování a dekódování z kódů stabilizovaných a pro popis toho, jak se jedno obnovuje z chyb.</span><span class="sxs-lookup"><span data-stu-id="d6083-167">The Q# canon provides a framework for describing encoding into and decoding from stabilizer codes, and for describing how one recovers from errors.</span></span>
<span data-ttu-id="d6083-168">V této části popíšeme toto rozhraní a jeho aplikaci na několik jednoduchých chybných procesorů.</span><span class="sxs-lookup"><span data-stu-id="d6083-168">In this section, we describe this framework and its application to a few simple quantum error-correcting codes.</span></span>

> [!TIP]
> <span data-ttu-id="d6083-169">Úplný Úvod k formalitám na stabilizaci je nad rámec této části.</span><span class="sxs-lookup"><span data-stu-id="d6083-169">A full introduction to the stabilizer formalism is beyond the scope of this section.</span></span>
> <span data-ttu-id="d6083-170">Čtenářům, kteří mají zájem o další informace, se dozvíte o [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span><span class="sxs-lookup"><span data-stu-id="d6083-170">We refer readers interested in learning more to [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span></span>

## <a name="representing-error-correcting-codes-in-no-locq"></a><span data-ttu-id="d6083-171">Reprezentace chybových oprav kódů v Q#</span><span class="sxs-lookup"><span data-stu-id="d6083-171">Representing Error Correcting Codes in Q#</span></span> ##

<span data-ttu-id="d6083-172">Aby bylo možné zadat chyby oprav kódů, Q# Canon poskytuje několik různých uživatelsky definovaných typů:</span><span class="sxs-lookup"><span data-stu-id="d6083-172">To help specify error correcting codes, the Q# canon provides several distinct user-defined types:</span></span>

- <span data-ttu-id="d6083-173"><xref:Microsoft.Quantum.ErrorCorrection.LogicalRegister>`= Qubit[]`: Označuje, že registr qubits by měl být interpretován jako blok kódu pro chybu s opravou kódu.</span><span class="sxs-lookup"><span data-stu-id="d6083-173"><xref:Microsoft.Quantum.ErrorCorrection.LogicalRegister> `= Qubit[]`: Denotes that a register of qubits should be interpreted as the code block of an error-correcting code.</span></span>
- <span data-ttu-id="d6083-174"><xref:Microsoft.Quantum.ErrorCorrection.Syndrome>`= Result[]`: Označuje, že pole výsledků měření by mělo být interpretováno jako Syndrome měřené na bloku kódu.</span><span class="sxs-lookup"><span data-stu-id="d6083-174"><xref:Microsoft.Quantum.ErrorCorrection.Syndrome> `= Result[]`: Denotes that an array of measurement results should be interpreted as the syndrome measured on a code block.</span></span>
- <span data-ttu-id="d6083-175"><xref:Microsoft.Quantum.ErrorCorrection.RecoveryFn>`= (Syndrome -> Pauli[])`: Označuje, že by se měla použít *Klasická* funkce k interpretaci Syndrome a vrácení opravy, která by se měla použít.</span><span class="sxs-lookup"><span data-stu-id="d6083-175"><xref:Microsoft.Quantum.ErrorCorrection.RecoveryFn> `= (Syndrome -> Pauli[])`: Denotes that a *classical* function should be used to interpret a syndrome and return a correction that should be applied.</span></span>
- <span data-ttu-id="d6083-176"><xref:Microsoft.Quantum.ErrorCorrection.EncodeOp>`= ((Qubit[], Qubit[]) => LogicalRegister)`: Označuje, že operace přebírá qubits, která představuje data společně s čerstvou ancilla qubits, aby vytvořila blok kódu pro chybu s opravou kódu.</span><span class="sxs-lookup"><span data-stu-id="d6083-176"><xref:Microsoft.Quantum.ErrorCorrection.EncodeOp> `= ((Qubit[], Qubit[]) => LogicalRegister)`: Denotes that an operation takes qubits representing data along with fresh ancilla qubits in order to produce a code block of an error-correcting code.</span></span>
- <span data-ttu-id="d6083-177"><xref:Microsoft.Quantum.ErrorCorrection.DecodeOp>`= (LogicalRegister => (Qubit[], Qubit[]))`: Všimněte si, že operace označuje blok kódu chyby správného opravy kódu do qubits dat a ancilla qubits, který slouží k reprezentaci informací Syndrome.</span><span class="sxs-lookup"><span data-stu-id="d6083-177"><xref:Microsoft.Quantum.ErrorCorrection.DecodeOp> `= (LogicalRegister => (Qubit[], Qubit[]))`: Denotes than an operation decomposes a code block of an error correcting code into the data qubits and the ancilla qubits used to represent syndrome information.</span></span>
- <span data-ttu-id="d6083-178"><xref:Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp>`= (LogicalRegister => Syndrome)`: Označuje operaci, která by měla být použita k extrakci informací Syndrome z bloku kódu, aniž by narušila stav chráněný kódem.</span><span class="sxs-lookup"><span data-stu-id="d6083-178"><xref:Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp> `= (LogicalRegister => Syndrome)`: Denotes an operation that should be used to extract syndrome information from a code block, without disturbing the state protected by the code.</span></span>

<span data-ttu-id="d6083-179">Nakonec Canon poskytne <xref:Microsoft.Quantum.ErrorCorrection.QECC> typ pro shromáždění dalších typů potřebných k definování chybných hodnot při opravách kódu.</span><span class="sxs-lookup"><span data-stu-id="d6083-179">Finally, the canon provides the <xref:Microsoft.Quantum.ErrorCorrection.QECC> type to collect the other types required to define a quantum error-correcting code.</span></span> <span data-ttu-id="d6083-180">V souvislosti s každým kódem doby stabilizace je délka kódu $n $, číslo $k $ logického qubits a minimální vzdálenost $d $, která je často vhodná pro seskupení do Notation ⟦ $n $, $k $, $d $ ⟧.</span><span class="sxs-lookup"><span data-stu-id="d6083-180">Associated with each stabilizer quantum code is the code length $n$, the number $k$ of logical qubits, and the minimum distance $d$, often conveniently grouped together in the notation ⟦$n$, $k$, $d$⟧.</span></span> <span data-ttu-id="d6083-181">Například <xref:Microsoft.Quantum.ErrorCorrection.BitFlipCode> funkce definuje ⟦ 3, 1, 1 ⟧ bit překlopení kódu:</span><span class="sxs-lookup"><span data-stu-id="d6083-181">For example, the <xref:Microsoft.Quantum.ErrorCorrection.BitFlipCode> function defines the ⟦3, 1, 1⟧ bit flip code:</span></span>

```qsharp
let encodeOp = EncodeOp(BitFlipEncoder);
let decodeOp = DecodeOp(BitFlipDecoder);
let syndMeasOp = SyndromeMeasOp(MeasureStabilizerGenerators([
    [PauliZ, PauliZ, PauliI],
    [PauliI, PauliZ, PauliZ]
], _, MeasureWithScratch));
let code = QECC(encodeOp, decodeOp, syndMeasOp);
```

<span data-ttu-id="d6083-182">Všimněte si, že `QECC` typ *not* nezahrnuje funkci obnovení.</span><span class="sxs-lookup"><span data-stu-id="d6083-182">Notice that the `QECC` type does *not* include a recovery function.</span></span>
<span data-ttu-id="d6083-183">Díky tomu můžeme změnit funkci obnovení, která se používá při opravách chyb beze změny definice samotného kódu; Tato možnost je užitečná zejména při začlenění zpětné vazby z měření popisu do modelu, který předpokládá obnovení.</span><span class="sxs-lookup"><span data-stu-id="d6083-183">This allows us to change the recovery function that is used in correcting errors without changing the definition of the code itself; this ability is in particular useful when incorporating feedback from characterization measurements into the model assumed by recovery.</span></span>

<span data-ttu-id="d6083-184">Po definování kódu tímto způsobem můžeme použít <xref:Microsoft.Quantum.ErrorCorrection.Recover> operaci k zotavení z chyb:</span><span class="sxs-lookup"><span data-stu-id="d6083-184">Once a code is defined in this way, we can use the <xref:Microsoft.Quantum.ErrorCorrection.Recover> operation to recover from errors:</span></span>

```qsharp
let code = BitFlipCode();
let fn = BitFlipRecoveryFn();
let X0 = ApplyPauli([PauliX, PauliI, PauliI], _);
using (scratch = Qubit[nScratch]) {
    let logicalRegister = encode(data, scratch);
    // Cause an error.
    X0(logicalRegister);
    Recover(code, fn, logicalRegister);
    let (decodedData, decodedScratch) = decode(logicalRegister);
    ApplyToEach(Reset, decodedScratch);
}
```

<span data-ttu-id="d6083-185">Podrobněji o tom prozkoumáme v [ukázce bitové překlopení kódu](https://github.com/microsoft/Quantum/tree/main/samples/error-correction/bit-flip-code).</span><span class="sxs-lookup"><span data-stu-id="d6083-185">We explore this in more detail in the [bit flip code sample](https://github.com/microsoft/Quantum/tree/main/samples/error-correction/bit-flip-code).</span></span>

<span data-ttu-id="d6083-186">Kromě kódu překlápění, Q# je technologie Canon k dispozici s implementacemi [qubit dokonalého kódu](https://arxiv.org/abs/quant-ph/9602019)a [sedmi qubit kódem](https://arxiv.org/abs/quant-ph/9705052), který může opravit libovolnou chybu s jedním qubit.</span><span class="sxs-lookup"><span data-stu-id="d6083-186">Aside from the bit-flip code, the Q# canon is provided with implementations of the [five-qubit perfect code](https://arxiv.org/abs/quant-ph/9602019), and the [seven-qubit code](https://arxiv.org/abs/quant-ph/9705052), both of which can correct an arbitrary single-qubit error.</span></span>
