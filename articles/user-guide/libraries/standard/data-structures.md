---
title: Datové struktury ve Q# standardních knihovnách
description: Přečtěte si o datových strukturách, Oracle a dynamických generátorech ve Q# standardních knihovnách společnosti Microsoft.
author: QuantumWriter
uid: microsoft.quantum.libraries.data-structures
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 51eb52d0b8ace972f6a425edba400ca9a8916d2e
ms.sourcegitcommit: 9b0d1ffc8752334bd6145457a826505cc31fa27a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/21/2020
ms.locfileid: "90835583"
---
# <a name="data-structures-and-modeling"></a><span data-ttu-id="db7d8-103">Datové struktury a modelování</span><span class="sxs-lookup"><span data-stu-id="db7d8-103">Data Structures and Modeling</span></span> #

## <a name="classical-data-structures"></a><span data-ttu-id="db7d8-104">Klasické datové struktury</span><span class="sxs-lookup"><span data-stu-id="db7d8-104">Classical Data Structures</span></span> ##

<span data-ttu-id="db7d8-105">Společně s uživatelsky definovanými typy pro reprezentaci konceptů, Canon také poskytuje operace, funkce a typy pro práci s klasickými daty používanými v řízení systémů.</span><span class="sxs-lookup"><span data-stu-id="db7d8-105">Along with user-defined types for representing quantum concepts, the canon also provides operations, functions, and types for working with classical data used in the control of quantum systems.</span></span>
<span data-ttu-id="db7d8-106">Například <xref:microsoft.quantum.arrays.reversed> funkce přebírá pole jako vstup a vrací stejné pole v opačném pořadí.</span><span class="sxs-lookup"><span data-stu-id="db7d8-106">For instance, the <xref:microsoft.quantum.arrays.reversed> function takes an array as input and returns the same array in reverse order.</span></span>
<span data-ttu-id="db7d8-107">To lze potom použít pro pole typu `Qubit[]` , abyste se vyhnuli nutnosti použít nepotřebné brány $ \operatorname{swap} $ při konverzi mezi reprezentací typu Integer.</span><span class="sxs-lookup"><span data-stu-id="db7d8-107">This can then be used on an array of type `Qubit[]` to avoid having to apply unnecessary $\operatorname{SWAP}$ gates when converting between quantum representations of integers.</span></span>
<span data-ttu-id="db7d8-108">Podobně jsme viděli v předchozí části, že typy formuláře `(Int, Int -> T)` mohou být užitečné, aby představovaly kolekce s náhodným přístupem, takže <xref:microsoft.quantum.arrays.lookupfunction> funkce poskytuje pohodlný způsob, jak vytvořit takové typy z typů polí.</span><span class="sxs-lookup"><span data-stu-id="db7d8-108">Similarly, we saw in the previous section that types of the form `(Int, Int -> T)` can be useful for representing random access collections, so the <xref:microsoft.quantum.arrays.lookupfunction> function provides a convenient way of constructing such types from array types.</span></span>

### <a name="pairs"></a><span data-ttu-id="db7d8-109">Spár</span><span class="sxs-lookup"><span data-stu-id="db7d8-109">Pairs</span></span> ###

<span data-ttu-id="db7d8-110">Canon podporuje zápis funkčního stylu pro páry, doplnění přístupu k řazeným kolekcím členů pomocí dekonstrukce:</span><span class="sxs-lookup"><span data-stu-id="db7d8-110">The canon supports functional-style notation for pairs, complementing accessing tuples by deconstruction:</span></span>

```qsharp
let pair = (PauliZ, register); // type (Pauli, Qubit[])
ApplyToEach(H, Snd(pair)); // No need to deconstruct to access the register.
```

### <a name="arrays"></a><span data-ttu-id="db7d8-111">Pole</span><span class="sxs-lookup"><span data-stu-id="db7d8-111">Arrays</span></span> ###

<span data-ttu-id="db7d8-112">Canon nabízí několik funkcí pro manipulaci s poli.</span><span class="sxs-lookup"><span data-stu-id="db7d8-112">The canon provides several functions for manipulating arrays.</span></span>
<span data-ttu-id="db7d8-113">Tyto funkce jsou typu parametrizované, a proto je lze použít s poli libovolného Q# typu.</span><span class="sxs-lookup"><span data-stu-id="db7d8-113">These functions are type-parameterized, and thus can be used with arrays of any Q# type.</span></span>
<span data-ttu-id="db7d8-114">Například <xref:microsoft.quantum.arrays.reversed> funkce vrátí nové pole, jehož prvky jsou v opačném pořadí, od vstupu.</span><span class="sxs-lookup"><span data-stu-id="db7d8-114">For instance, the <xref:microsoft.quantum.arrays.reversed> function returns a new array whose elements are in reverse order from its input.</span></span>
<span data-ttu-id="db7d8-115">Dá se použít ke změně způsobu, jakým se při volání operací reprezentuje registr s hodnotou:</span><span class="sxs-lookup"><span data-stu-id="db7d8-115">This can be used to change how a quantum register is represented when calling operations:</span></span>

```qsharp
let leRegister = LittleEndian(register);
// QFT expects a BigEndian, so we can reverse before calling.
QFT(BigEndian(Reversed(leRegister!)));
// This is how the LittleEndianAsBigEndian function is implemented:
QFT(LittleEndianAsBigEndian(leRegister));
```

<span data-ttu-id="db7d8-116">Podobně <xref:microsoft.quantum.arrays.subarray> lze funkci použít k přeuspořádání nebo přeřazení podmnožiny prvků pole:</span><span class="sxs-lookup"><span data-stu-id="db7d8-116">Similarly, the <xref:microsoft.quantum.arrays.subarray> function can be used to reorder or take subsets of the elements of an array:</span></span>

```qsharp
// Applies H to qubits 2 and 5.
ApplyToEach(H, Subarray([2, 5], register));
```

<span data-ttu-id="db7d8-117">V kombinaci s řízením toku může funkce manipulace s polem, jako je například, <xref:microsoft.quantum.arrays.zip> poskytovat účinný způsob, jak vyjádřit programy na více než jednou.</span><span class="sxs-lookup"><span data-stu-id="db7d8-117">When combined with flow control, array manipulation functions such as <xref:microsoft.quantum.arrays.zip> can provide a powerful way to express quantum programs:</span></span>

```qsharp
// Applies X₃ Y₁ Z₇ to a register of any size.
ApplyToEach(
    ApplyPauli(_, register),
    Map(
        EmbedPauli(_, _, Length(register)),
        Zip([PauliX, PauliY, PauliZ], [3, 1, 7])
    )
);
```

## <a name="oracles"></a><span data-ttu-id="db7d8-118">Oracle</span><span class="sxs-lookup"><span data-stu-id="db7d8-118">Oracles</span></span> ##

<span data-ttu-id="db7d8-119">Ve [fázi odhadu](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) a [amplitudy zesílení amplitudy](https://en.wikipedia.org/wiki/Amplitude_amplification) se pojem Oracle objevuje často.</span><span class="sxs-lookup"><span data-stu-id="db7d8-119">In the [phase estimation](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) and [amplitude amplification](https://en.wikipedia.org/wiki/Amplitude_amplification) literature the concept of an oracle appears frequently.</span></span>
<span data-ttu-id="db7d8-120">V tomto případě se pojem Oracle vztahuje na podprogramovou rutinu Blackbox, která funguje na sadě qubits, a vrátí odpověď jako fázi.</span><span class="sxs-lookup"><span data-stu-id="db7d8-120">Here the term oracle refers to a blackbox quantum subroutine that acts upon a set of qubits and returns the answer as a phase.</span></span>
<span data-ttu-id="db7d8-121">Tato podrutina se často může považovat za vstup do algoritmu pro plnění hodnoty, který přijímá Oracle, kromě některých dalších parametrů a používá řadu operací po sobě a zpracovává volání této podprocesu, jako by šlo o základní bránu.</span><span class="sxs-lookup"><span data-stu-id="db7d8-121">This subroutine often can be thought of as an input to a quantum algorithm that accepts the oracle, in addition to some other parameters, and applies a series of quantum operations and treating a call to this quantum subroutine as if it were a fundamental gate.</span></span>
<span data-ttu-id="db7d8-122">Aby bylo možné skutečně implementovat větší algoritmus, je nutné poskytnout konkrétní rozložené rozhraní Oracle do základních bran, ale takové rozložené není nutné, aby bylo možné pochopit algoritmus, který volá Oracle.</span><span class="sxs-lookup"><span data-stu-id="db7d8-122">Obviously, in order to actually implement the larger algorithm a concrete decomposition of the oracle into fundamental gates must be provided but such a decomposition is not needed in order to understand the algorithm that calls the oracle.</span></span>
<span data-ttu-id="db7d8-123">V Q# nástroji je tato abstrakce reprezentována pomocí těchto operací jsou hodnoty první třídy, což znamená, že operace mohou být předány do implementace algoritmů pro plnění v černém poli.</span><span class="sxs-lookup"><span data-stu-id="db7d8-123">In Q#, this abstraction is represented by using that operations are first-class values, such that operations can be passed to implementations of quantum algorithms in a black-box manner.</span></span>
<span data-ttu-id="db7d8-124">Kromě toho uživatelsky definované typy se používají k označení různých reprezentace Oracle bezpečným způsobem, což ztěžuje náhodné rozlišit různé druhy operací černého boxu.</span><span class="sxs-lookup"><span data-stu-id="db7d8-124">Moreover, user-defined types are used to label the different oracle representations in a type-safe way, making it difficult to accidentally conflate different kinds of black box operations.</span></span>

<span data-ttu-id="db7d8-125">Tyto Oracle se zobrazují v řadě různých kontextů, včetně slavnýchch příkladů, jako jsou například [Grover vyhledávání](https://en.wikipedia.org/wiki/Grover%27s_algorithm) a simulace.</span><span class="sxs-lookup"><span data-stu-id="db7d8-125">Such oracles appear in a number of different contexts, including famous examples such as [Grover's search](https://en.wikipedia.org/wiki/Grover%27s_algorithm) and quantum simulation algorithms.</span></span>
<span data-ttu-id="db7d8-126">Tady se zaměříme na Oracle, které potřebuje jenom dvě aplikace: zesílení amplitud a odhad fáze.</span><span class="sxs-lookup"><span data-stu-id="db7d8-126">Here we focus on the oracles needed for just two applications: amplitude amplification and phase estimation.</span></span>
<span data-ttu-id="db7d8-127">Před pokračováním odhadu fáze budeme nejdřív projednávat amplituda zesílení Oracle.</span><span class="sxs-lookup"><span data-stu-id="db7d8-127">We will first discuss amplitude amplification oracles before proceeding to phase estimation.</span></span>

### <a name="amplitude-amplification-oracles"></a><span data-ttu-id="db7d8-128">Amplituda zesílení pro Oracle</span><span class="sxs-lookup"><span data-stu-id="db7d8-128">Amplitude Amplification Oracles</span></span> ###

<span data-ttu-id="db7d8-129">Algoritmus zesílení amplitudy se zaměřuje na otočení mezi počátečním stavem a konečným stavem, a to použitím sekvence odrazů stavu.</span><span class="sxs-lookup"><span data-stu-id="db7d8-129">The amplitude amplification algorithm aims to perform a rotation between an initial state and a final state by applying a sequence of reflections of the state.</span></span>
<span data-ttu-id="db7d8-130">Aby algoritmus fungoval, potřebuje specifikace obou těchto stavů.</span><span class="sxs-lookup"><span data-stu-id="db7d8-130">In order for the algorithm to function, it needs a specification of both of these states.</span></span>
<span data-ttu-id="db7d8-131">Tyto specifikace jsou dány dvěma Oracle.</span><span class="sxs-lookup"><span data-stu-id="db7d8-131">These specifications are given by two oracles.</span></span>
<span data-ttu-id="db7d8-132">Tyto Oracle fungují tak, že jsou porušují vstupy na dvou místech a "cílový" prostor a "počáteční" prostor.</span><span class="sxs-lookup"><span data-stu-id="db7d8-132">These oracles work by breaking the inputs into two spaces, a "target" subspace and an "initial" subspace.</span></span>
<span data-ttu-id="db7d8-133">Oracle identifikují taková dílčí místa, podobně jako Pauli operátory identifikují dva mezery, a to tak, že na tyto prostory použijí fázi $ \Pm $1.</span><span class="sxs-lookup"><span data-stu-id="db7d8-133">The oracles identify such subspaces, similar to how Pauli operators identify two spaces, by applying a $\pm 1$ phase to these spaces.</span></span>
<span data-ttu-id="db7d8-134">Hlavní rozdíl spočívá v tom, že tyto prostory nemusí být v této aplikaci v polovičním prostoru.</span><span class="sxs-lookup"><span data-stu-id="db7d8-134">The main difference is that these spaces need not be half-spaces in this application.</span></span>
<span data-ttu-id="db7d8-135">Všimněte si také, že tyto dvě podprostory nejsou obvykle vzájemně exkluzivní: budou existovat vektory, které jsou členy obou prostorů.</span><span class="sxs-lookup"><span data-stu-id="db7d8-135">Also note that these two subspaces are not usually mutually exclusive: there will be vectors that are members of both spaces.</span></span>
<span data-ttu-id="db7d8-136">Pokud to neplatí, pak amplituda zesílení by neměla mít žádný vliv, takže potřebujeme, aby počáteční dílčí prostor byl bez nulového překrytí cílovým podprostorem.</span><span class="sxs-lookup"><span data-stu-id="db7d8-136">If this were not true then amplitude amplification would have no effect so we need the initial subspace to have non-zero overlap with the target subspace.</span></span>

<span data-ttu-id="db7d8-137">Všimněte si, že první Oracle, který potřebujeme pro zesílení amplitud, musí být $P \_ $0, definovaná pro následující akce.</span><span class="sxs-lookup"><span data-stu-id="db7d8-137">We will denote the first oracle that we need for amplitude amplification to be $P\_0$, defined to have the following action.</span></span>  <span data-ttu-id="db7d8-138">Pro všechny stavy $ \ket{x} $ v "počátečním" podprostoru $P \_ 0 \ket{x} =-\ket{x} $ a pro všechny stavy $ \ket{y} $, které nejsou v tomto dílčím prostoru, máme $P \_ 0 \ket{y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-138">For all states $\ket{x}$ in the "initial" subspace $P\_0 \ket{x} = -\ket{x}$ and for all states $\ket{y}$ that are not in this subspace we have $P\_0 \ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="db7d8-139">Oracle, který označuje cílové podprostor, $P _1 $, používá přesně stejný tvar.</span><span class="sxs-lookup"><span data-stu-id="db7d8-139">The oracle that marks the target subspace, $P_1$, takes exactly the same form.</span></span>
<span data-ttu-id="db7d8-140">Pro všechny stavy $ \ket{x} $ v cílovém dílčím prostoru (tj. pro všechny stavy, které chcete algoritmus výstup), $P _1 \ KET {x} =-\ket{x} $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-140">For all states $\ket{x}$ in the target subspace (i.e., for all states that you'd like the algorithm to output), $P_1\ket{x} = -\ket{x}$.</span></span>
<span data-ttu-id="db7d8-141">Podobně platí pro všechny stavy $ \ket{y} $, které nejsou v cílovém místě $P _1 \ KET {y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-141">Similarly, for all states $\ket{y}$ that are not in the target subspace $P_1\ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="db7d8-142">Tyto dvě odrazy se pak zkombinují za účelem vytvoření operátoru, který vydává jediný krok zesílení amplitud, $Q =-P_0 P_1 $, kde se celkový symbol mínus považuje jenom v kontrolovaných aplikacích.</span><span class="sxs-lookup"><span data-stu-id="db7d8-142">These two reflections are then combined to form an operator that enacts a single step of amplitude amplification, $Q = -P_0 P_1$, where the overall minus sign is only important to consider in controlled applications.</span></span>
<span data-ttu-id="db7d8-143">Amplituda amplitud pak pokračuje tím, že vezme počáteční stav $ \ket{\psi} $, který je v počátečním a pak provede $ \ket{\psi} \mapsto Q ^ m \ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-143">Amplitude amplification then proceeds by taking an initial state, $\ket{\psi}$ that is in the initial subspace and then performs $\ket{\psi} \mapsto Q^m \ket{\psi}$.</span></span>
<span data-ttu-id="db7d8-144">Tato iterace zaručuje, že pokud jeden začíná s počátečním stavem, který překrývá $ \sin ^ 2 (\theta) $ s označeným prostorem, pak po $m $ iterace se překrývá na $ \sin ^ 2 ([2 min + 1] \theta) $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-144">Performing such an iteration guarantees that if one starts with an initial state that has overlap $\sin^2(\theta)$ with the marked space then after $m$ iterations this overlap becomes $\sin^2([2m + 1] \theta)$.</span></span>
<span data-ttu-id="db7d8-145">Proto si obvykle přejete zvolit $m $ jako bezplatný parametr, například $ [2 min + 1] \theta = \ pi/2 $; Takové tuhé volby ale nejsou důležité pro některé formy zesílení amplitud, jako je zesílení amplitudy pevně stanovených bodů.</span><span class="sxs-lookup"><span data-stu-id="db7d8-145">We therefore typically wish to choose $m$ to be a free parameter such that $[2m+1]\theta = \pi/2$; however, such rigid choices are not as important for some forms of amplitude amplification such as fixed point amplitude amplification.</span></span>
<span data-ttu-id="db7d8-146">Tento proces nám umožňuje připravit stav ve vyhrazeném místě pomocí kvadratických méně dotazů na funkci označení a funkce přípravy stavu, než by bylo možné na čistě klasických zařízeních.</span><span class="sxs-lookup"><span data-stu-id="db7d8-146">This process allows us to prepare a state in the marked subspace using quadratically fewer queries to the marking function and the state preparation function than would be possible on a strictly classical device.</span></span>
<span data-ttu-id="db7d8-147">To je důvod, proč je zesílení amplitud flexibilní stavební blok pro spoustu aplikací, které výpočetní výkon využívá.</span><span class="sxs-lookup"><span data-stu-id="db7d8-147">This is why amplitude amplification is a significant building block for many applications of quantum computing.</span></span>

<span data-ttu-id="db7d8-148">Aby bylo možné pochopit, jak používat algoritmus, je užitečné poskytnout příklad, který poskytuje konstrukci Oracle.</span><span class="sxs-lookup"><span data-stu-id="db7d8-148">In order to understand how to use the algorithm, it is useful to provide an example that gives a construction of the oracles.</span></span>  <span data-ttu-id="db7d8-149">V tomto nastavení zvažte, jak provést Grover algoritmus pro prohledávání databáze.</span><span class="sxs-lookup"><span data-stu-id="db7d8-149">Consider performing Grover's algorithm for database searches in this setting.</span></span>
<span data-ttu-id="db7d8-150">V hledání Grover je cílem transformovat stav $ \ket{+} ^ {\otimes n} = H ^ {\otimes n} \ket {0} $ na jeden z (potenciálně) mnoho označených stavů.</span><span class="sxs-lookup"><span data-stu-id="db7d8-150">In Grover's search the goal is to transform the state $\ket{+}^{\otimes n} = H^{\otimes n} \ket{0}$ into one of (potentially) many marked states.</span></span>
<span data-ttu-id="db7d8-151">Abychom mohli ještě víc zjednodušit, Podívejme se jenom na případ, kde je jenom označený stav $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-151">To further simplify, let's just look at the case where the only marked state is $\ket{0}$.</span></span>
<span data-ttu-id="db7d8-152">Pak máme návrh dvou Oracle: ten označuje pouze počáteční stav $ \ket{+} ^ {\otimes n} $ s znaménkem mínus a další, který označuje označený stav $ \ket {0} $ znaménkem mínus.</span><span class="sxs-lookup"><span data-stu-id="db7d8-152">Then we have design two oracles: one that only marks the initial state $\ket{+}^{\otimes n}$ with a minus sign and another that marks the marked state $\ket{0}$ with a minus sign.</span></span>
<span data-ttu-id="db7d8-153">Druhou bránu je možné implementovat pomocí následující operace zpracování pomocí operací toku řízení v Canon:</span><span class="sxs-lookup"><span data-stu-id="db7d8-153">The latter gate can be implemented using the following process operation, by using the control flow operations in the canon:</span></span>

```qsharp
operation ReflectAboutAllZeros(register : Qubit[]) : Unit 
is Adj + Ctl {

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);

    // Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.
    // This gate will lead to a sign flip if and only if every qubit is
    // $1$, which happens only if each of the qubits were $0$ before step 1.
    Controlled Z(Most(register), Tail(register));

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);
}
```

<span data-ttu-id="db7d8-154">Tento Oracle je pak zvláštním případem <xref:microsoft.quantum.canon.rall1> operace, který umožňuje otočení pomocí libovolné fáze namísto případu odrazu $ \phi = \pi $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-154">This oracle is then a special case of the <xref:microsoft.quantum.canon.rall1> operation, which allows for rotating by an arbitrary phase instead of the reflection case $\phi = \pi$.</span></span>
<span data-ttu-id="db7d8-155">V tomto případě `RAll1` se podobá <xref:microsoft.quantum.intrinsic.r1> operaci předehru, a to v tom, že se místo \ket{11\cdots1}ého stavu qubit $ \ket $ otáčí o $ $ {1} .</span><span class="sxs-lookup"><span data-stu-id="db7d8-155">In this case, `RAll1` is similar to the <xref:microsoft.quantum.intrinsic.r1> prelude operation, in that it rotates about $\ket{11\cdots1}$ instead of the single-qubit state $\ket{1}$.</span></span>

<span data-ttu-id="db7d8-156">Oracle, který označuje počáteční mezeru, může být vytvořen podobně.</span><span class="sxs-lookup"><span data-stu-id="db7d8-156">The oracle that marks the initial subspace can be constructed similarly.</span></span>
<span data-ttu-id="db7d8-157">V pseudokódu:</span><span class="sxs-lookup"><span data-stu-id="db7d8-157">In pseudocode:</span></span>

1. <span data-ttu-id="db7d8-158">U každého qubit použijte $H $ bran.</span><span class="sxs-lookup"><span data-stu-id="db7d8-158">Apply $H$ gates to every qubit.</span></span>
2. <span data-ttu-id="db7d8-159">U každého qubit použijte $X $ bran.</span><span class="sxs-lookup"><span data-stu-id="db7d8-159">Apply $X$ gates to every qubit.</span></span>
3. <span data-ttu-id="db7d8-160">Pro $n ^ {\Text{th}} $ qubit použijte bránu $Z $-$1 řízenou v $n.</span><span class="sxs-lookup"><span data-stu-id="db7d8-160">Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.</span></span>
4. <span data-ttu-id="db7d8-161">U každého qubit použijte $X $ bran.</span><span class="sxs-lookup"><span data-stu-id="db7d8-161">Apply $X$ gates to every qubit.</span></span>
5. <span data-ttu-id="db7d8-162">U každého qubit použijte $H $ bran.</span><span class="sxs-lookup"><span data-stu-id="db7d8-162">Apply $H$ gates to every qubit.</span></span>

<span data-ttu-id="db7d8-163">V tuto chvíli jsme také předvedli použití <xref:microsoft.quantum.canon.applywith> společně s <xref:microsoft.quantum.canon.rall1> výše popsanou operací:</span><span class="sxs-lookup"><span data-stu-id="db7d8-163">This time, we also demonstrate using <xref:microsoft.quantum.canon.applywith> together with the <xref:microsoft.quantum.canon.rall1> operation discussed above:</span></span>

```qsharp
operation ReflectAboutInitial(register : Qubit[]) : Unit
is Adj + Ctl {
    ApplyWithCA(ApplyToEach(H, _), ApplyWith(ApplyToEach(X, _), RAll1(_, PI()), _), register);
}
```

<span data-ttu-id="db7d8-164">Pak můžeme kombinovat tyto dva společnosti Oracle, aby je bylo možné otočit mezi oběma stavy a deterministické transformaci $ \ket{+} ^ {\otimes n} $ na $ \ket {0} $ pomocí několika vrstev ch bran, které jsou v poměru k $ \sqrt{2 ^ n} $ (ie $m \propto \sqrt{2 ^ n} $) oproti přibližně $2 ^ n $ vrstvám, které by byly potřeba pro nedeterministické přípravu $ \ket $, a to tak, že se {0} připraví a měří počáteční stav, dokud se nezjistí výsledek $0 $ $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-164">We can then combine these two oracles together to rotate between the two states and deterministically transform $\ket{+}^{\otimes n}$ to $\ket{0}$ using a number of layers of Hadamard gates that is proportional to $\sqrt{2^n}$ (ie $m\propto \sqrt{2^n}$) versus the roughly $2^n$ layers that would be needed to non-deterministically prepare the $\ket{0}$ state by preparing and measuring the initial state until the outcome $0$ is observed.</span></span>

### <a name="phase-estimation-oracles"></a><span data-ttu-id="db7d8-165">Odhad fáze Oracle</span><span class="sxs-lookup"><span data-stu-id="db7d8-165">Phase Estimation Oracles</span></span> ###

<span data-ttu-id="db7d8-166">V případě odhadu fáze jsou Oracle trochu přirozenější.</span><span class="sxs-lookup"><span data-stu-id="db7d8-166">For phase estimation the oracles are somewhat more natural.</span></span>
<span data-ttu-id="db7d8-167">Cílem ve fázi odhadu je návrh dílčí rutiny, která je schopná vzorkování z eigenvalues matice s jednou jednotkou.</span><span class="sxs-lookup"><span data-stu-id="db7d8-167">The aim in phase estimation is to design a subroutine that is capable of sampling from the eigenvalues of a unitary matrix.</span></span>
<span data-ttu-id="db7d8-168">Tato metoda je nepostradatelná v simulaci stavových období, protože pro mnoho fyzických problémů v chemii a materiálové vědy poskytují tyto eigenvalues základní energiesé systémy, které poskytují cenné informace o fázích vytváření materiálů a reakcí v dynamikě pro molekuly.</span><span class="sxs-lookup"><span data-stu-id="db7d8-168">This method is indispensable in quantum simulation because for many physical problems in chemistry and material science these eigenvalues give the ground-state energies of quantum systems which provides us valuable information about the phase diagrams of materials and reaction dynamics for molecules.</span></span>
<span data-ttu-id="db7d8-169">Každý charakter odhadu fáze vyžaduje vstup s jednou jednotkou.</span><span class="sxs-lookup"><span data-stu-id="db7d8-169">Every flavor of phase estimation needs an input unitary.</span></span>
<span data-ttu-id="db7d8-170">Tato jednotná část je obvykle popsána jedním ze dvou typů Oracle.</span><span class="sxs-lookup"><span data-stu-id="db7d8-170">This unitary is customarily described by one of two types of oracles.</span></span>

> [!TIP]
> <span data-ttu-id="db7d8-171">Oba typy Oracle popsané níže jsou uvedené v ukázkách.</span><span class="sxs-lookup"><span data-stu-id="db7d8-171">Both of the oracle types described below are covered in the samples.</span></span>
> <span data-ttu-id="db7d8-172">Další informace o průběžných dotazech Oracle najdete v [ukázce **PhaseEstimation** ](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="db7d8-172">To learn more about continuous query oracles, please see the [**PhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation).</span></span>
> <span data-ttu-id="db7d8-173">Další informace o samostatných dotazech Oracle najdete v [ukázce **IsingPhaseEstimation** ](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="db7d8-173">To learn more about discrete query oracles, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>

<span data-ttu-id="db7d8-174">První typ Oracle, který volá diskrétní dotaz Oracle a představuje uživatelsky definovaný typ <xref:microsoft.quantum.oracles.discreteoracle> , jednoduše zahrnuje jednotnou matici.</span><span class="sxs-lookup"><span data-stu-id="db7d8-174">The first type of oracle, which we call a discrete query oracle and represent with the user-defined type <xref:microsoft.quantum.oracles.discreteoracle>, simply involves a unitary matrix.</span></span>
<span data-ttu-id="db7d8-175">Pokud je $U $ jednotkou, jejíž eigenvalues chceme odhadnout, je Oracle pro $U $ jednoduše samostatným předpokladem pro podprogram, který implementuje $U $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-175">If $U$ is the unitary whose eigenvalues we wish to estimate then the oracle for $U$ is simply a stand-in for a subroutine that implements $U$.</span></span>
<span data-ttu-id="db7d8-176">Například jedna může trvat $U $ to je, že pro odhad amplitud se výše definovala $Q Oracle.</span><span class="sxs-lookup"><span data-stu-id="db7d8-176">For example, one could take $U$ to be the oracle $Q$ defined above for amplitude estimation.</span></span>
<span data-ttu-id="db7d8-177">Eigenvalues této matice se dá použít k odhadu překrytí mezi počátečními a cílovými stavy, $ \sin ^ 2 (\theta) $, a to za použití kvadratickě méně vzorků, než je třeba v případě, že by to vyžadovalo jinak.</span><span class="sxs-lookup"><span data-stu-id="db7d8-177">The eigenvalues of this matrix can be used to estimate the overlap between the initial and target states, $\sin^2(\theta)$, using quadratically fewer samples than one would need otherwise.</span></span>
<span data-ttu-id="db7d8-178">Tím se vyrozumí použití odhadu fáze pomocí Grover Oracle $Q $ jako zadání monikeru odhadu amplitudy.</span><span class="sxs-lookup"><span data-stu-id="db7d8-178">This earns the application of phase estimation using the Grover oracle $Q$ as input the moniker of amplitude estimation.</span></span>
<span data-ttu-id="db7d8-179">Další běžnou aplikací, která se běžně používá v rozsahu metrologie, zahrnuje odhad malého úhlu otočení.</span><span class="sxs-lookup"><span data-stu-id="db7d8-179">Another common application, widely used in quantum metrology, involves estimating a small rotation angle.</span></span>
<span data-ttu-id="db7d8-180">Jinými slovy chceme odhadnout $ \theta $ pro neznámou rotující bránu formuláře $R _z (\theta) $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-180">In other words, we wish to estimate $\theta$ for an unknown rotation gate of the form $R_z(\theta)$.</span></span>
<span data-ttu-id="db7d8-181">V takových případech by měla podrutina, s níž komunikujeme, s cílem zjistit tuto pevnou hodnotu $ \theta $ pro bránu je $ $ \begin{align} U & = R_z (\theta) \\ \\ & = \begin{bmatrix} e ^ {-i \theta/2} & 0 \\ \\ 0 & e ^ {i \ théta/2} \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="db7d8-181">In such cases, the subroutine that we would interact with in order to learn this fixed value of $\theta$ for the gate is $$ \begin{align} U & = R_z(\theta) \\\\ & = \begin{bmatrix} e^{-i \theta / 2} & 0 \\\\ 0 & e^{i\theta/2} \end{bmatrix}.</span></span>
<span data-ttu-id="db7d8-182">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="db7d8-182">\end{align} $$</span></span>

<span data-ttu-id="db7d8-183">Druhým typem Oracle použitým ve fázi odhad je průběžný dotaz Oracle, reprezentovaný <xref:microsoft.quantum.oracles.continuousoracle> typem.</span><span class="sxs-lookup"><span data-stu-id="db7d8-183">The second type of oracle used in phase estimation is the continuous query oracle, represented by the <xref:microsoft.quantum.oracles.continuousoracle> type.</span></span>
<span data-ttu-id="db7d8-184">Průběžný dotaz Oracle pro odhad fáze má formu $U (t) $, kde $t $ je klasický známý reálné číslo.</span><span class="sxs-lookup"><span data-stu-id="db7d8-184">A continuous query oracle for phase estimation takes the form $U(t)$ where $t$ is a classically known real number.</span></span>
<span data-ttu-id="db7d8-185">Pokud máme $U $ být fixní jednotkou, pak má průběžný dotaz Oracle formu $U (t) = U ^ t $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-185">If we let $U$ be a fixed unitary then the continuous query oracle takes the form $U(t) = U^t$.</span></span>
<span data-ttu-id="db7d8-186">To nám umožňuje dotazovat se na matice, jako je $ \sqrt{U} $, které se nedaly implementovat přímo v samostatném modelu dotazu.</span><span class="sxs-lookup"><span data-stu-id="db7d8-186">This allows us to query matrices such as $\sqrt{U}$, which could not be implemented directly in the discrete query model.</span></span>

<span data-ttu-id="db7d8-187">Tento typ Oracle je užitečný v případě, že nebudete provádět konkrétní jednotnou, ale chcete se dozvědět, jaké jsou vlastnosti generátoru s jednou jednotkou.</span><span class="sxs-lookup"><span data-stu-id="db7d8-187">This type of oracle is valuable when you're not probing a particular unitary, but rather wish to learn the properties of the generator of the unitary.</span></span>
<span data-ttu-id="db7d8-188">Například při simulaci dynamických stavových procesorů je cílem navrhnout okruhy v provozu, které úzce přibližně $U (t) = e ^ {-i H} $ pro matrici Hermitian $H $ a dobu vývoje $t $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-188">For example, in dynamical quantum simulation the goal is to devise quantum circuits that closely approximate $U(t)=e^{-i H t}$ for a Hermitian matrix $H$ and evolution time $t$.</span></span>
<span data-ttu-id="db7d8-189">Eigenvalues $U (t) $ přímo souvisí s eigenvalues $H $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-189">The eigenvalues of $U(t)$ are directly related to the eigenvalues of $H$.</span></span>
<span data-ttu-id="db7d8-190">Pokud to chcete vidět, vezměte v úvahu eigenvector $H $: $H \ket{E} = E\ket {E} $. pak se snadno zobrazí z definice Power-Series exponenciálního exponenciálního výrazu, který $U (t) \ket{E} = E ^ {i\phi} \ KET {E} = E ^ {-iEt} \ket{E} $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-190">To see this, consider an eigenvector of $H$: $H \ket{E} = E\ket{E}$ then it is easy to see from the power-series definition of the matrix exponential that $U(t) \ket{E} = e^{i\phi}\ket{E}= e^{-iEt}\ket{E}$.</span></span>
<span data-ttu-id="db7d8-191">Proto se odhaduje eigenphase $U (t) $ poskytne $E eigenvalue $ za předpokladu, že eigenvector $ \ket{E} $ je vstup do algoritmu odhadu fáze.</span><span class="sxs-lookup"><span data-stu-id="db7d8-191">Thus estimating the eigenphase of $U(t)$ gives the eigenvalue $E$ assuming the eigenvector $\ket{E}$ is input into the phase estimation algorithm.</span></span>
<span data-ttu-id="db7d8-192">V tomto případě se ale hodnota $t $ dá zvolit podle uvážení uživatele, protože u jakékoli dostatečně malé hodnoty $t $ se eigenvalue $E $ dá jednoznačně vrátit přes $E =-\ fí/t $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-192">However, in this case the value $t$ can be chosen at the user's discretion since for any sufficiently small value of $t$ the eigenvalue $E$ can be uniquely inverted through $E=-\phi/t$.</span></span>
<span data-ttu-id="db7d8-193">Vzhledem k tomu, že metody simulace využívání služeb poskytují možnost provádět zlomkové vývoje, jsou tyto algoritmy odhadu fáze při dotazování na určitou dobu další volnou, konkrétně když diskrétní model dotazů umožňuje použít pouze unitaries $U formuláře ^ j $ pro celé číslo $j $. průběžný dotaz Oracle umožňuje přibližnou unitaries ve formě $U ^ t $ pro všechny skutečné hodnoty $t $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-193">Since quantum simulation methods provide the ability to perform a fractional evolution, this grants phase estimation algorithms an additional freedom when querying the unitary, specifically while the discrete query model allows only unitaries of the form $U^j$ to applied for integer $j$ the continuous query oracle allows us to approximate unitaries of the form $U^t$ for any real valued $t$.</span></span>
<span data-ttu-id="db7d8-194">To je důležité pro stlačení každé poslední unce v algoritmech odhadu fází, protože nám umožňuje přesně zvolit experiment, který by poskytoval nejvíc informací o $E $; vzhledem k tomu, že metody založené na diskrétních dotazech musí dělat s kompromisem, a to výběrem nejlepšího celočíselného počtu dotazů v algoritmu.</span><span class="sxs-lookup"><span data-stu-id="db7d8-194">This is important to squeeze every last ounce of efficiency out of phase estimation algorithms because it allows us to choose precisely the experiment that would provide the most information about $E$; whereas methods based on discrete queries must make do with compromising by choosing the best integer number of queries in the algorithm.</span></span>

<span data-ttu-id="db7d8-195">Jako konkrétní příklad tohoto problému zvažte, jak se při odhadování nejedná o úhel otočení brány, ale frekvence procesu rotujícího systému.</span><span class="sxs-lookup"><span data-stu-id="db7d8-195">As a concrete example of this, consider the problem of estimating not the rotation angle of a gate but the procession frequency of a rotating quantum system.</span></span>
<span data-ttu-id="db7d8-196">Jednotná, která popisuje takové pole s dobou provozu, je $U (t) = R_z (2 \ Omega t) $ pro dobu vývoje $t $ a neznámá frekvence $ \omega $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-196">The unitary that describes such quantum dynamics is $U(t)=R_z(2\omega t)$ for evolution time $t$ and unknown frequency $\omega$.</span></span>
<span data-ttu-id="db7d8-197">V tomto kontextu můžeme simulovat $U (t) $ pro všechny $t $ pomocí jedné $R _z $ a nemusíte tak omezovat dodržovali jenom na diskrétní dotazy.</span><span class="sxs-lookup"><span data-stu-id="db7d8-197">In this context, we can simulate $U(t)$ for any $t$ using a single $R_z$ gate and as such do not need to restrict ourselves to only discrete queries to the unitary.</span></span>
<span data-ttu-id="db7d8-198">Tento souvislý model má také vlastnost, že frekvence větší než $2 \ PI $ se dají poznat z procesů odhadů fází, které používají průběžné dotazy, protože informace o fázi, které by jinak byly maskovány pomocí děleného průřezu funkce, se dají vykrýt z výsledků experimentů provedených na neúměrných hodnotách $t $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-198">Such a continuous model also has the property that frequencies greater than $2\pi$ can be learned from phase estimation processes that use continuous queries because phase information that would otherwise be masked by the branch-cuts of the logarithm function can be revealed from the results of experiments performed on non-commensurate values of $t$.</span></span>
<span data-ttu-id="db7d8-199">Proto jsou problémy, jako jsou tyto průběžné modely dotazů pro fáze odhadující fáze Oracle, nejen vhodné, ale jsou také vhodnější pro diskrétní model dotazů.</span><span class="sxs-lookup"><span data-stu-id="db7d8-199">Thus for problems such as this continuous query models for the phase estimation oracle are not only appropriate but are also preferable to the discrete query model.</span></span>
<span data-ttu-id="db7d8-200">Z tohoto důvodu Q# má funkčnost jak pro formy dotazů, tak pro uživatele, aby se rozhodla o algoritmu odhadu fáze podle svých potřeb a typu Oracle, který je k dispozici.</span><span class="sxs-lookup"><span data-stu-id="db7d8-200">For this reason Q# has functionality for both forms of queries and leave it to the user to decide upon a phase estimation algorithm to fit their needs and the type of oracle that is available.</span></span>

## <a name="dynamical-generator-modeling"></a><span data-ttu-id="db7d8-201">Modely dynamického generátoru</span><span class="sxs-lookup"><span data-stu-id="db7d8-201">Dynamical Generator Modeling</span></span> ##

<span data-ttu-id="db7d8-202">Generátory času pro vývoj popisují, jak se stavy vyvíjejí v čase.</span><span class="sxs-lookup"><span data-stu-id="db7d8-202">Generators of time-evolution describe how states evolve through time.</span></span> <span data-ttu-id="db7d8-203">Například dynamika stavového stavu $ \ket{\psi} $ se řídí rovnicí Schrödinger $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $ s Hermitian maticí $H $, která se označuje jako Hamiltonian, jako generátor pohybu.</span><span class="sxs-lookup"><span data-stu-id="db7d8-203">For instance, the dynamics of a quantum state $\ket{\psi}$ is governed by the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ with a Hermitian matrix $H$, known as the Hamiltonian, as the generator of motion.</span></span> <span data-ttu-id="db7d8-204">Byl zadán počáteční stav $ \ket{\psi (0)} $ v čase $t = $0, formální řešení této rovnice v čase $t $ může být v podstatě zapsané $ $ \begin{align} \ket{\psi (t)} = U (t) \ket{\psi (0)}, \end{align} $ $, kde je výraz exponenciální $U (t) = e ^ {-i H} $, označovaný jako jednotkový operátor pro vývoj času.</span><span class="sxs-lookup"><span data-stu-id="db7d8-204">Given an initial state $\ket{\psi(0)}$ at time $t=0$, the formal solution to this equation at time $t$ may be, in principle, written $$ \begin{align} \ket{\psi(t)} = U(t)\ket{\psi(0)}, \end{align} $$ where the matrix exponential $U(t)=e^{-i H t}$ is known as the unitary time-evolution operator.</span></span> <span data-ttu-id="db7d8-205">I když se zaměříme na generátory tohoto formuláře v níže uvedeném příkladu, doporučujeme zdůraznit, že koncept se bude považovat za obecnější, například na simulaci otevřených systémů, nebo na více abstraktních rozdílových rovnic.</span><span class="sxs-lookup"><span data-stu-id="db7d8-205">Though we focus on generators of this form in the following, we emphasize that the concept applies more broadly, such as to the simulation of open quantum systems, or to more abstract differential equations.</span></span>

<span data-ttu-id="db7d8-206">Hlavním cílem dynamické simulace je implementace operátoru pro vývoj času v některých stavech, který je kódovaný v qubits počítače s procesorem.</span><span class="sxs-lookup"><span data-stu-id="db7d8-206">A primary goal of dynamical simulation is to implement the time-evolution operator on some quantum state encoded in qubits of a quantum computer.</span></span>  <span data-ttu-id="db7d8-207">V mnoha případech může být Hamiltonian rozdělená na součet některých $d $ jednodušších podmínek.</span><span class="sxs-lookup"><span data-stu-id="db7d8-207">In many cases, the Hamiltonian may be broken into a sum of some $d$ simpler terms</span></span>

<span data-ttu-id="db7d8-208">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j, \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="db7d8-208">$$ \begin{align} H & = \sum^{d-1}_{j=0} H_j, \end{align} $$</span></span>

<span data-ttu-id="db7d8-209">v případě, že je v počítači s procesorem na více procesorech snadné implementovat čas v každém termínu.</span><span class="sxs-lookup"><span data-stu-id="db7d8-209">where time-evolution by each term alone is easy to implement on a quantum computer.</span></span> <span data-ttu-id="db7d8-210">Například pokud $H _j $ je Pauli $X _1X_2 $, který působí na první a druhý prvek registru qubit `qubits` , může být vývoj času v každém čase $t $ implementován jednoduše voláním operace `Exp([PauliX,PauliX], t, qubits[1..2])` , která má signaturu `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="db7d8-210">For instance, if $H_j$ is a Pauli $X_1X_2$ operator acting on the 1st and 2nd elements of the qubit register `qubits`, time-evolution by it for any time $t$ may be implemented simply by calling the operation `Exp([PauliX,PauliX], t, qubits[1..2])`, which has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span> <span data-ttu-id="db7d8-211">Jak je popsáno dále v simulaci Hamiltonian, jedno řešení pak bude přibližný vývoj času pomocí $H $ se sekvencí jednodušších operací.</span><span class="sxs-lookup"><span data-stu-id="db7d8-211">As discussed later in Hamiltonian Simulation, one solution then is to approximate time-evolution by $H$ with a sequence of simpler operations</span></span>

<span data-ttu-id="db7d8-212">$ $ \begin{align} U (t) & = \left (e ^ {-iH \_ 0 t/r} e ^ {-IH \_ 1 t/r} \cdots e ^ {-IH \_ {d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="db7d8-212">$$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j \\|H\_j\\|^2 t^2/r), \end{align} $$</span></span>

<span data-ttu-id="db7d8-213">kde celé číslo $r > $0 řídí chybu aproximace.</span><span class="sxs-lookup"><span data-stu-id="db7d8-213">where the integer $r > 0$ controls the approximation error.</span></span>

<span data-ttu-id="db7d8-214">Knihovna modelování dynamického generátoru poskytuje rozhraní pro systematické kódování složitých generátorů z pohledu jednodušších generátorů.</span><span class="sxs-lookup"><span data-stu-id="db7d8-214">The dynamical generator modeling library provides a framework for systematically encoding complicated generators in terms of simpler generators.</span></span> <span data-ttu-id="db7d8-215">Tento popis může být předán do, řekněme, že knihovna simulace implementuje časový vývoj pomocí algoritmu simulace výběru, přičemž mnoho podrobností automaticky postará o.</span><span class="sxs-lookup"><span data-stu-id="db7d8-215">Such a description may then be passed to, say, the simulation library to implement time-evolution by a simulation algorithm of choice, with many details automatically taken care of.</span></span>

> [!TIP]
> <span data-ttu-id="db7d8-216">Knihovna dynamického generátoru popsaná níže je uvedena v ukázkách.</span><span class="sxs-lookup"><span data-stu-id="db7d8-216">The dynamical generator library described below is covered in the samples.</span></span> <span data-ttu-id="db7d8-217">Příklad založený na modelu Ising naleznete v [ukázce **IsingGenerators** ](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/generators).</span><span class="sxs-lookup"><span data-stu-id="db7d8-217">For an example based on the Ising model, please see the [**IsingGenerators** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/generators).</span></span>
> <span data-ttu-id="db7d8-218">Příklad založený na molekulovém vodíku najdete v ukázkách [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) a [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/gui) .</span><span class="sxs-lookup"><span data-stu-id="db7d8-218">For an example based on molecular Hydrogen, please see the [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) and [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/gui) samples.</span></span>

### <a name="complete-description-of-a-generator"></a><span data-ttu-id="db7d8-219">Úplný popis generátoru</span><span class="sxs-lookup"><span data-stu-id="db7d8-219">Complete Description of a Generator</span></span> ###

<span data-ttu-id="db7d8-220">Na nejvyšší úrovni je úplný popis Hamiltonian obsažen v `EvolutionGenerator` uživatelsky definovaném typu, který má dvě součásti.:</span><span class="sxs-lookup"><span data-stu-id="db7d8-220">At the top level, a complete description of a Hamiltonian is contained in the `EvolutionGenerator` user-defined type which has two components.:</span></span>

```qsharp
newtype EvolutionGenerator = (EvolutionSet, GeneratorSystem);
```

<span data-ttu-id="db7d8-221">`GeneratorSystem`Uživatelem definovaný typ je klasický popis Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="db7d8-221">The `GeneratorSystem` user-defined type is a classical description of the Hamiltonian.</span></span>

```qsharp
newtype GeneratorSystem = (Int, (Int -> GeneratorIndex));
```

<span data-ttu-id="db7d8-222">První prvek `Int` řazené kolekce členů ukládá počet podmínek $d $ v Hamiltonian a druhý prvek `(Int -> GeneratorIndex)` je funkce, která mapuje celočíselný index ve výrazu $ \{ 0, 1,..., d-1 \} $ na `GeneratorIndex` uživatelsky definovaný typ, který jednoznačně identifikuje jednotlivé primitivní podmínky v Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="db7d8-222">The first element `Int` of the tuple stores the number of terms $d$ in the Hamiltonian, and the second element `(Int -> GeneratorIndex)` is a function that maps an integer index in $\{0,1,...,d-1\}$ to a `GeneratorIndex` user-defined type which uniquely identifies each primitive term in the Hamiltonian.</span></span> <span data-ttu-id="db7d8-223">Všimněte si, že vyjádřením shromažďování podmínek v Hamiltonian jako funkce, nikoli jako pole `GeneratorIndex[]` , umožňuje průběžné zpracování, `GeneratorIndex` které je zvlášť užitečné při popisu Hamiltonians s velkým počtem podmínek.</span><span class="sxs-lookup"><span data-stu-id="db7d8-223">Note that by expressing the collection of terms in the Hamiltonian as a function rather than as an array `GeneratorIndex[]`, this allows for on-the-fly computation of the `GeneratorIndex` which is especially useful when describing Hamiltonians with a large number of terms.</span></span>

<span data-ttu-id="db7d8-224">V nerozhodujícím případě nestanovíme konvenci, které primitivní výrazy identifikované pomocí `GeneratorIndex` jsou snadno simulovatelné.</span><span class="sxs-lookup"><span data-stu-id="db7d8-224">Crucially, we do not impose a convention on what primitive terms identified by the `GeneratorIndex` are easy-to-simulate.</span></span> <span data-ttu-id="db7d8-225">Například primitivní výrazy by mohly být Pauli operátory, jak je popsáno výše, ale mohou být také Fermionic Annihilation a operátory vytváření běžně používané v simulaci přístupnosti.</span><span class="sxs-lookup"><span data-stu-id="db7d8-225">For instance, primitive terms could be Pauli operators as discussed above, but they could also be Fermionic annihilation and creation operators commonly used in quantum chemistry simulation.</span></span> <span data-ttu-id="db7d8-226">Sám o sobě znamená, že `GeneratorIndex` nepopisuje způsob, jakým je čas v době, kdy ukazuje, že je možné implementovat časový okruh.</span><span class="sxs-lookup"><span data-stu-id="db7d8-226">By itself, a `GeneratorIndex` is meaningless as it does not describe how time-evolution by the term it points to may be implemented as a quantum circuit.</span></span>

<span data-ttu-id="db7d8-227">To je vyřešeno zadáním `EvolutionSet` uživatelsky definovaného typu, který je namapován `GeneratorIndex` z některé kanonické sady na operátor s jednotkou, `EvolutionUnitary` vyjádřený jako okruh.</span><span class="sxs-lookup"><span data-stu-id="db7d8-227">This is resolved by specifying an `EvolutionSet` user-defined type that maps any `GeneratorIndex`, drawn from some canonical set, to a unitary operator, the `EvolutionUnitary`, expressed as a quantum circuit.</span></span> <span data-ttu-id="db7d8-228">`EvolutionSet`Definuje konvenci `GeneratorIndex` , jak je strukturovaný a také definuje sadu možností `GeneratorIndex` .</span><span class="sxs-lookup"><span data-stu-id="db7d8-228">The `EvolutionSet` defines the convention of how a `GeneratorIndex` is structured, and also defines the set of possible `GeneratorIndex`.</span></span>

```qsharp
newtype EvolutionSet = (GeneratorIndex -> EvolutionUnitary);
```

### <a name="pauli-operator-generators"></a><span data-ttu-id="db7d8-229">Generátory operátorů Pauli</span><span class="sxs-lookup"><span data-stu-id="db7d8-229">Pauli Operator Generators</span></span> ###

<span data-ttu-id="db7d8-230">Konkrétní a užitečný příklad generátorů jsou Hamiltoniansy, které jsou součtem operátorů Pauli, z nichž každá může s jiným koeficientem.</span><span class="sxs-lookup"><span data-stu-id="db7d8-230">A concrete and useful example of generators are Hamiltonians that are a sum of Pauli operators, each possibly with a different coefficient.</span></span>
<span data-ttu-id="db7d8-231">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} a_j H_j, \end{align} $ $, kde každá skupina $ \hat H_j $ je nyní vykreslena z Pauli skupiny.</span><span class="sxs-lookup"><span data-stu-id="db7d8-231">$$ \begin{align} H & = \sum^{d-1}_{j=0} a_j H_j, \end{align} $$ where each $\hat H_j$ is now drawn from the Pauli group.</span></span> <span data-ttu-id="db7d8-232">Pro tyto systémy poskytujeme `PauliEvolutionSet()` typ `EvolutionSet` , který definuje konvenci pro způsob, jakým může být element Pauli skupiny a koeficientu identifikován `GeneratorIndex` , který má následující signaturu.</span><span class="sxs-lookup"><span data-stu-id="db7d8-232">For such systems, we provide the `PauliEvolutionSet()` of type `EvolutionSet` that defines a convention for how an element of the Pauli group and a coefficient may be identified by a `GeneratorIndex`, which has the following signature.</span></span>

```qsharp
newtype GeneratorIndex = ((Int[], Double[]), Int[]);
```

<span data-ttu-id="db7d8-233">V našem kódování první parametr `Int[]` Určuje řetězec Pauli, kde $ \Hat I\rightarrow $0, $ \Hat X\rightarrow $1, $ \Hat Y\rightarrow $2 a $ \Hat Z\rightarrow $3.</span><span class="sxs-lookup"><span data-stu-id="db7d8-233">In our encoding, the first parameter `Int[]` specifies a Pauli string, where $\hat I\rightarrow 0$, $\hat X\rightarrow 1$, $\hat Y\rightarrow 2$, and $\hat Z\rightarrow 3$.</span></span> <span data-ttu-id="db7d8-234">Druhý parametr `Double[]` ukládá koeficient Pauli řetězce v Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="db7d8-234">The second parameter `Double[]` stores the coefficient of the Pauli string in the Hamiltonian.</span></span> <span data-ttu-id="db7d8-235">Všimněte si, že je použit pouze první prvek tohoto pole.</span><span class="sxs-lookup"><span data-stu-id="db7d8-235">Note that only the first element of this array is used.</span></span> <span data-ttu-id="db7d8-236">Třetí parametr `Int[]` indexuje qubits, na kterém tento řetězec Pauli funguje, a nesmí mít žádné duplicitní prvky.</span><span class="sxs-lookup"><span data-stu-id="db7d8-236">The third parameter `Int[]` indexes the qubits that this Pauli string acts on, and must have no duplicate elements.</span></span> <span data-ttu-id="db7d8-237">Proto Hamiltonian Term $0,4 \hat X_0 \hat Y_8 \hat I_2 \hat Z_1 $ může být reprezentován jako</span><span class="sxs-lookup"><span data-stu-id="db7d8-237">Thus the Hamiltonian term $0.4 \hat X_0 \hat Y_8\hat I_2\hat Z_1$ may be represented as</span></span>

```qsharp
let generatorIndexExample = GeneratorIndex(([1,2,0,3], [0.4]]), [0,8,2,1]);
```

<span data-ttu-id="db7d8-238">`PauliEvolutionSet()`Je funkce, která mapuje libovolný `GeneratorIndex` z tohoto formuláře na `EvolutionUnitary` s následující signaturou.</span><span class="sxs-lookup"><span data-stu-id="db7d8-238">The `PauliEvolutionSet()` is a function that maps any `GeneratorIndex` of this form to an `EvolutionUnitary` with the following signature.</span></span>

```qsharp
newtype EvolutionUnitary = ((Double, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="db7d8-239">První parametr představuje časový interval, který bude vynásoben koeficientem v rámci `GeneratorIndex` jednotkového vývoje.</span><span class="sxs-lookup"><span data-stu-id="db7d8-239">The first parameter represents a time-duration, that will be multiplied by the coefficient in the `GeneratorIndex`, of unitary evolution.</span></span> <span data-ttu-id="db7d8-240">Druhým parametrem je qubit, na kterém se registruje jednotná činnost.</span><span class="sxs-lookup"><span data-stu-id="db7d8-240">The second parameter is the qubit register the unitary acts on.</span></span> 

### <a name="time-dependent-generators"></a><span data-ttu-id="db7d8-241">Generátory závislé na čase</span><span class="sxs-lookup"><span data-stu-id="db7d8-241">Time-Dependent Generators</span></span> ###

<span data-ttu-id="db7d8-242">V mnoha případech jsme se také zajímat o generátory závislé na čase modelování, ke kterým může dojít v Schrödinger rovnici $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = \hat H (t) \ket{\psi (t)}, \end{align} $ $, kde generátor $ \hat H (t) $ je teď závislý na čase.</span><span class="sxs-lookup"><span data-stu-id="db7d8-242">In many cases, we are also interested in modelling time-dependent generators, as might occur in the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = \hat H(t) \ket{\psi(t)}, \end{align} $$ where the generator $\hat H(t)$ is now time-dependent.</span></span> <span data-ttu-id="db7d8-243">Rozšíření od zdrojů nezávislých na čase výše tohoto případu je jednoduché.</span><span class="sxs-lookup"><span data-stu-id="db7d8-243">The extension from the time-independent generators above to this case is straightforward.</span></span> <span data-ttu-id="db7d8-244">Místo toho, abyste měli pevně `GeneratorSystem` popisující Hamiltonian pro všechny časy $t $, máme k tomu `GeneratorSystemTimeDependent` uživatelsky definovaný typ.</span><span class="sxs-lookup"><span data-stu-id="db7d8-244">Rather than having a fixed `GeneratorSystem` describing the Hamiltonian for all times $t$, we instead have the `GeneratorSystemTimeDependent` user-defined type.</span></span>

```qsharp
newtype GeneratorSystemTimeDependent = (Double -> GeneratorSystem);
```

<span data-ttu-id="db7d8-245">První parametr je parametr průběžného plánu $s \in [0, 1] $ a funkce tohoto typu vrátí `GeneratorSystem` pro tento plán.</span><span class="sxs-lookup"><span data-stu-id="db7d8-245">The first parameter is a continuous schedule parameter $s\in [0,1]$, and functions of this type return a `GeneratorSystem` for that schedule.</span></span> <span data-ttu-id="db7d8-246">Všimněte si, že parametr Schedule může být lineární v souvislosti s parametrem fyzického času, například $s = t/T $, pro určitý celkový čas simulace $T $.</span><span class="sxs-lookup"><span data-stu-id="db7d8-246">Note that the schedule parameter may be linearly related to the physical time parameter e.g. $s = t / T$, for some total time of simulation $T$.</span></span> <span data-ttu-id="db7d8-247">Obecně to ale nemusí být případ.</span><span class="sxs-lookup"><span data-stu-id="db7d8-247">In general however, this need not be the case.</span></span>

<span data-ttu-id="db7d8-248">Podobně úplný popis tohoto generátoru vyžaduje `EvolutionSet` , a proto definujeme `EvolutionSchedule` uživatelsky definovaný typ.</span><span class="sxs-lookup"><span data-stu-id="db7d8-248">Similarly, a complete description of this generator requires an `EvolutionSet`, and so we define an `EvolutionSchedule` user-defined type.</span></span>

```qsharp
newtype EvolutionSchedule = (EvolutionSet, GeneratorSystemTimeDependent);
```
