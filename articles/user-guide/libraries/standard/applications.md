---
title: 'Aplikace v knihovně Q # Standard'
description: Seznamte se se dvěma základními aplikacemi ve výpočetním prostředí – Hamiltonian simulací a algoritmem hledání Shor.
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 25b06ac697c958b15a756191fb8a4ac49644edd7
ms.sourcegitcommit: 0181e7c9e98f9af30ea32d3cd8e7e5e30257a4dc
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/23/2020
ms.locfileid: "85274629"
---
# <a name="applications"></a><span data-ttu-id="5e13e-103">Aplikace</span><span class="sxs-lookup"><span data-stu-id="5e13e-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="5e13e-104">Hamiltoniánská simulace</span><span class="sxs-lookup"><span data-stu-id="5e13e-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="5e13e-105">Simulace systémů pro plnění je jedním z nejzajímavějších aplikací výpočetních případů.</span><span class="sxs-lookup"><span data-stu-id="5e13e-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="5e13e-106">V klasickém počítači se při simulaci nenáročného navýšení na procesory škálují s dimenzí $N $ jeho reprezentace jeho stavu.</span><span class="sxs-lookup"><span data-stu-id="5e13e-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="5e13e-107">Vzhledem k tomu, že se tato reprezentace rozroste exponenciálně s počtem $n $ qubits $N = 2 ^ n $, což je známý známý také jako seznámení s [dimenzí](xref:microsoft.quantum.concepts.multiple-qubits), simulace nedostatku na klasický hardware je nevolatelné.</span><span class="sxs-lookup"><span data-stu-id="5e13e-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="5e13e-108">Nicméně tato situace může být velmi odlišná na hardwaru s nárokem na stav.</span><span class="sxs-lookup"><span data-stu-id="5e13e-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="5e13e-109">Nejběžnější variace simulace nedostatku času se nazývá problém nezávisle na Hamiltonian simulace.</span><span class="sxs-lookup"><span data-stu-id="5e13e-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="5e13e-110">K dispozici je jedna z popisů systému Hamiltonian $H $, což je Hermitian matice, a některé počáteční stavové stavy $ \ket{\psi (0)} $, které jsou v některých případech kódované v $n $ qubits v počítači s procesorem.</span><span class="sxs-lookup"><span data-stu-id="5e13e-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="5e13e-111">V případě stavových stavů v uzavřených systémech se vyvíjí v rámci rovnice Schrödinger $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}. \end{align} $ $ cílem je implementovat jednotkový operátor pro vývoj času $U (t) = e ^ {-iHt} $ v nějakém pevném čase $t $, kde $ \ket{\psi (t)} = U (t) \ket{\psi (0)} $ vyřeší rovnici Schrödinger.</span><span class="sxs-lookup"><span data-stu-id="5e13e-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="5e13e-112">Obdobně problém s simulací Hamiltonian závislé na čase vyřeší stejnou rovnici, ale s $H (t) $ nyní může být funkce času.</span><span class="sxs-lookup"><span data-stu-id="5e13e-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="5e13e-113">Simulace Hamiltonian je hlavní součástí mnoha dalších problémů s simulací při plnění a řešení problémů s simulací Hamiltonian jsou algoritmy, které popisují sekvenci primitivních předpisů pro syntetizaci velkých a velkých a velkých procesorů $ \tilde{U} $ s chybou $ \\ | \tilde{U}-U (t) \\ | \le \epsilon $ v [spektrální normě](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="5e13e-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="5e13e-114">Složitost těchto algoritmů závisí velmi silně na tom, jak je popis Hamiltonian zájmu přístupný pro počítač ve velkém počtu.</span><span class="sxs-lookup"><span data-stu-id="5e13e-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="5e13e-115">Například v nejhorším případě, pokud $H $ v $n $ qubits byly poskytnuty jako seznam hodnot $2 ^ n \times 2 ^ n $, jeden pro každý prvek matice, jednoduše čtená data již vyžadují exponenciální čas.</span><span class="sxs-lookup"><span data-stu-id="5e13e-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="5e13e-116">V nejlepším případě by jeden mohl předpokládat přístup k černému poli, který $O \ket{t}\ket{\psi (0)} = \ket{t}U (t) \ket{\psi (0)} $ triviální problém vyřeší.</span><span class="sxs-lookup"><span data-stu-id="5e13e-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="5e13e-117">Ani jeden z těchto vstupních modelů není obzvlášť zajímavý – bývalé, protože není lepší než klasický přístup a druhá jako černý rámeček skrývá základní bránu své implementace, což může být exponenciální v počtu qubits.</span><span class="sxs-lookup"><span data-stu-id="5e13e-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="5e13e-118">Popisy Hamiltonians</span><span class="sxs-lookup"><span data-stu-id="5e13e-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="5e13e-119">Jsou proto vyžadovány další předpoklady formátu vstupu.</span><span class="sxs-lookup"><span data-stu-id="5e13e-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="5e13e-120">Jemné vyvážení musí být prolomeno mezi vstupními modely, které jsou dostatečně popisné, aby zahrnovaly zajímavé Hamiltoniansy, jako jsou například pro reálné fyzické systémy nebo zajímavé výpočetní problémy, a vstupní modely, které jsou dostatečně omezující, aby je bylo možné efektivně implementovat na počítači s více počátečními hodnotami.</span><span class="sxs-lookup"><span data-stu-id="5e13e-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="5e13e-121">V této literatuře se může najít celá řada netriviálních vstupních modelů a jejich rozsah od až po klasický.</span><span class="sxs-lookup"><span data-stu-id="5e13e-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="5e13e-122">Jako příklad u vstupních modelů pro [procesory předpokládá Hamiltonian simulace](http://www.nature.com/articles/s41534-017-0013-7) přístup k operacím s černým přístavem, který vytváří kopie matrice hustoty $ \rho $, které se považují za Hamiltonian $H $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="5e13e-123">V modelu jedny [přístupového modelu](https://arxiv.org/abs/1202.5822) předpokládá, že Hamiltonian místo toho předává součet unitaries $ $ \begin{align} H & = \sum ^ {d-1} \_ {j = 0} a \_ j \hat{U} \_ j, \end{align} $ $, kde $a \_ j>$0 jsou koeficienty a $ \hat{U} \_ j $ jsou unitaries.</span><span class="sxs-lookup"><span data-stu-id="5e13e-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="5e13e-124">Pak se předpokládá, že má k dispozici černý přístup k jednotkám Oracle $V = \sum ^ {d-1} \_ {j = 0} \Ket{j}\bra{j}\otimes \hat{U} \_ j $, která vybere požadované $ \hat{U} \_ j $, a Oracle $A \ket {0} = \sum ^ {d-1} \_ {j = 0} \sqrt{a \_ j/\ Sum ^ {d-1} \_ {k = 0} \Alpha \_ j} \ket{j} $, které vytvářejí tyto koeficienty pro kódování stavových procesorů.</span><span class="sxs-lookup"><span data-stu-id="5e13e-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="5e13e-125">V případě [simulace zhuštěných Hamiltonian](https://arxiv.org/abs/quant-ph/0301023)se předpokládá, že Hamiltonian je zhuštěná matice s pouze $d = \mathcal{O} (\Text{polylog} (N)) $ nenulového prvku v každém řádku.</span><span class="sxs-lookup"><span data-stu-id="5e13e-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="5e13e-126">Kromě toho předpokládá, že existence efektivních okruhů na více procesorech vychází z umístění těchto nenulových prvků, jakož i jejich hodnot.</span><span class="sxs-lookup"><span data-stu-id="5e13e-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="5e13e-127">Složitost [algoritmů simulace Hamiltonian](xref:microsoft.quantum.more-information) je vyhodnocována v podobě počtu dotazů do těchto černých polí a základní složitost brány pak závisí hodně na obtížnosti implementace těchto černých polí.</span><span class="sxs-lookup"><span data-stu-id="5e13e-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="5e13e-128">Notaci Big-O se běžně používá k popisu škálování algoritmů složitosti algoritmů.</span><span class="sxs-lookup"><span data-stu-id="5e13e-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="5e13e-129">Zadané dvě reálné funkce $f, g $, výraz $g (x) = \mathcal{O} (f)) $ znamená, že existuje absolutní kladná konstanta $x \_ 0, c>$0, což $g (x) \le c f (x) $ pro všechny $x \ge x \_ $0.</span><span class="sxs-lookup"><span data-stu-id="5e13e-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="5e13e-130">U většiny praktických aplikací, které se mají implementovat na počítač s procesorem, musí být tato černá pole efektivně implementovaná, tedy s využitím \Text{polylog} (N) $ \mathcal{O} (N) $ primitivních procesorů.</span><span class="sxs-lookup"><span data-stu-id="5e13e-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="5e13e-131">Mnohem silné a efektivní simulable Hamiltonians musí mít nějaký dostatečně zhuštěný klasický popis.</span><span class="sxs-lookup"><span data-stu-id="5e13e-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="5e13e-132">V jednom takovém složení se předpokládá, že Hamiltonian dekládá do součtu Hermitian částí $ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j.</span><span class="sxs-lookup"><span data-stu-id="5e13e-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="5e13e-133">\end{align} $ $ navíc předpokládá, že každá část, Hamiltonian $H \_ j $, se dá snadno simulovat.</span><span class="sxs-lookup"><span data-stu-id="5e13e-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="5e13e-134">To znamená, že jednotková $e ^ {-iHa \_ j t} $ $t $ se dá implementovat přesně pomocí \mathcal{O} $ (1) $ primitivních procesorových vratek.</span><span class="sxs-lookup"><span data-stu-id="5e13e-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="5e13e-135">To je například pravda ve speciálním případě, kdy každý $H \_ j $ jsou místní operátory Pauli, což znamená, že jsou tensor produkty \mathcal{O} (1) $ Pauli operátory, které nepatří do identity, které fungují na prostorovém zavření qubits.</span><span class="sxs-lookup"><span data-stu-id="5e13e-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="5e13e-136">Tento model je vhodný zejména pro fyzické systémy s ohraničenou a místní interakcí, protože počet podmínek je $d = \mathcal{O} (\Text{polylog} (N)) $, a může být jasně zapsán, tj. klasickým způsobem popsaným v době polynomu.</span><span class="sxs-lookup"><span data-stu-id="5e13e-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="5e13e-137">Hamiltonians, které se rozloží na součet částí, mohou být popsány pomocí dynamické knihovny reprezentace generátoru.</span><span class="sxs-lookup"><span data-stu-id="5e13e-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="5e13e-138">Další informace najdete v části reprezentace dynamického generátoru v [datových strukturách](xref:microsoft.quantum.libraries.data-structures).</span><span class="sxs-lookup"><span data-stu-id="5e13e-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="5e13e-139">Algoritmy simulace</span><span class="sxs-lookup"><span data-stu-id="5e13e-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="5e13e-140">Algoritmus pro simulaci doby provozu Převede daný popis Hamiltonian na sekvenci primitivních procesorových vratů, které jsou v rámci celého přibližného vývoje času pomocí zmíněného Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="5e13e-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="5e13e-141">Ve speciálním případě, kdy Hamiltonian založí do součtu Hermitian částí, je dekompozice Trotter-Suzuki obzvláště jednoduchý a intuitivní algoritmus pro simulaci Hamiltonians, která se rozloží na součet Hermitian komponent.</span><span class="sxs-lookup"><span data-stu-id="5e13e-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="5e13e-142">Například první vydaný integrátor této rodiny je přibližně $ $ \begin{align} U (t) & = \left (e ^ {-iH \_ 0 t/r} e ^ {-IH \_ 1 t/r} \cdots e ^ {-IH \_ {d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \end{align} $ $ za použití produktu $r d $ terms.</span><span class="sxs-lookup"><span data-stu-id="5e13e-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="5e13e-143">V ukázkách jsou pokryté aplikace algoritmu simulace Trotter-Suzuki.</span><span class="sxs-lookup"><span data-stu-id="5e13e-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="5e13e-144">Pro model Ising s využitím pouze vnitřních operací, které jsou k dispozici v každém cílovém počítači, se podívejte na [ukázku **SimpleIsing** ](https://github.com/microsoft/Quantum/blob/master/samples/simulation/ising/simple).</span><span class="sxs-lookup"><span data-stu-id="5e13e-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/blob/master/samples/simulation/ising/simple).</span></span>
> <span data-ttu-id="5e13e-145">Pro model Ising pomocí struktury ovládacích prvků knihovny Trotter-Suzuki se podívejte na [ukázku **IsingTrotter** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/trotter-evolution).</span><span class="sxs-lookup"><span data-stu-id="5e13e-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/trotter-evolution).</span></span>
> <span data-ttu-id="5e13e-146">Pro molekulovou vodík pomocí struktury ovládacího prvku knihovna Trotter-Suzuki se podívejte na [ukázku **simulace H2** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line).</span><span class="sxs-lookup"><span data-stu-id="5e13e-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line).</span></span>

<span data-ttu-id="5e13e-147">V mnoha případech bychom chtěli implementovat algoritmus simulace, ale neuvažujete o jeho implementaci.</span><span class="sxs-lookup"><span data-stu-id="5e13e-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="5e13e-148">Například integrátor druhého řádu se blíží $ $ \begin{align} U (t) & = \left (e ^ {-iH \_ 0 t/2R} e ^ {-IH \_ 1 t/2R} \cdots e ^ {-IH \_ {d-1} t/2R} e ^ {-IH \_ {d-1} t/2R} \cdots e ^ {-IH \_ 1 t/2R} e ^ {-IH \_ 0 t/2R} \right) ^ {r} + \mathcal{O} (d ^ 3 \ max_j \\ | H \_ j \\ | ^ 3 t ^ 3/r ^ 2), \end{align} $ $ za použití produktu $2RD $ terms.</span><span class="sxs-lookup"><span data-stu-id="5e13e-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="5e13e-149">Větší objednávky budou zahrnovat ještě víc podmínek a optimalizované varianty můžou pro exponenciální hodnoty vyžadovat vysoce triviální řazení.</span><span class="sxs-lookup"><span data-stu-id="5e13e-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="5e13e-150">Další pokročilé algoritmy můžou také zahrnovat použití ancilla qubits v rámci mezipostupných kroků.</span><span class="sxs-lookup"><span data-stu-id="5e13e-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="5e13e-151">Proto se jako uživatelsky definovaný typ zabalí algoritmy simulace ve Canon.</span><span class="sxs-lookup"><span data-stu-id="5e13e-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="5e13e-152">První parametr `Double` je čas simulace, druhý parametr, který je `EvolutionGenerator` popsán v části dynamického generátoru generátoru [dat-struktury](xref:microsoft.quantum.libraries.data-structures), je klasický popis Hamiltonian zabaleného času s pokyny, jak mohou být jednotlivé podmínky v Hamiltonian simulované okruhem.</span><span class="sxs-lookup"><span data-stu-id="5e13e-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="5e13e-153">Typy tohoto formuláře se blíží jednotkové operaci $e ^ {-iHt} $ na třetím parametru `Qubit[]` , což je registr, který uchovává stav nečinnosti simulovaného systému.</span><span class="sxs-lookup"><span data-stu-id="5e13e-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="5e13e-154">Podobně jako v případě závislého na čase definujeme místo toho uživatelem definovaný typ s `EvolutionSchedule` typem, což je klasický popis Hamiltonian závislého na čase.</span><span class="sxs-lookup"><span data-stu-id="5e13e-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="5e13e-155">Jako příklad může být dekompozice Trotter-Suzuki volána pomocí následujících funkcí Canon s parametry, které `trotterStepSize` mění délku simulace v každé exponenciální a `trotterOrder` pro pořadí požadovaného integrátoru.</span><span class="sxs-lookup"><span data-stu-id="5e13e-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="5e13e-156">Aplikace knihovny simulace jsou pokryté v ukázkách.</span><span class="sxs-lookup"><span data-stu-id="5e13e-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="5e13e-157">Odhad fáze v modelu Ising pomocí najdete v `SimulationAlgorithm` [ukázce **IsingPhaseEstimation** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="5e13e-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>
> <span data-ttu-id="5e13e-158">Přípravu stavu adiabatic v modelu Ising pomocí najdete v `TimeDependentSimulationAlgorithm` [ukázce **AdiabaticIsing** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="5e13e-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="5e13e-159">Odhad stavu Adiabatic & fáze</span><span class="sxs-lookup"><span data-stu-id="5e13e-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="5e13e-160">Jednou z běžných aplikací simulace Hamiltonian je adiabatic stavový přípravek.</span><span class="sxs-lookup"><span data-stu-id="5e13e-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="5e13e-161">V takovém případě je k dispozici se dvěma Hamiltonians $H \_ {\Text{Start}} $ a $H \_ {\Text{end}} $ a $H stavem 2 – 2 \_ .</span><span class="sxs-lookup"><span data-stu-id="5e13e-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="5e13e-162">Obvykle \_ je zvolena možnost $H {\Text{Start}} $, což znamená, že $ \ket{\psi (0)} $ se snadno připravuje z výpočetního stavu na výpočetní úrovni $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="5e13e-163">Po interpolaci mezi těmito Hamiltoniansmi v případě problémů s simulací závislého na čase, který je dostatečně pomalý, je možné ukončit s vysokou pravděpodobností v terénu konečného Hamiltonian $H \_ {\Text{end}} $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficiently slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="5e13e-164">I když se připravuje dobrý odhad na Hamiltonianické stavy, může tento způsob vyvolat volání algoritmů simulace Hamiltonian v závislosti na čase jako dílčí rutinu, jiné koncepční různé přístupy, jako je například kolísání eigensolver, které je možné.</span><span class="sxs-lookup"><span data-stu-id="5e13e-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="5e13e-165">Ještě další všudypřítomný aplikace v chemii v terénu odhaduje stavovou energii Hamiltonians, která představuje mezilehlé kroky chemické reakce.</span><span class="sxs-lookup"><span data-stu-id="5e13e-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="5e13e-166">Takové schéma může například spoléhat na přípravu stavu adiabatic k vytvoření stavu země a pak začlenit simulaci Hamiltonian simulace jako dílčí rutinu v popisu fáze odhadu k extrakci této energie s určitou konečnou chybou a pravděpodobností úspěchu.</span><span class="sxs-lookup"><span data-stu-id="5e13e-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="5e13e-167">Abstrakce algoritmů simulace jako uživatelsky definovaných typů `SimulationAlgorithm` a `TimeDependentSimulationAlgorithm` nám umožňuje pohodlně začlenit jejich funkce do výkonnějších procesorových algoritmů.</span><span class="sxs-lookup"><span data-stu-id="5e13e-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="5e13e-168">To nám motivuje pro tyto běžně používané podrutiny.</span><span class="sxs-lookup"><span data-stu-id="5e13e-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="5e13e-169">Proto definujeme pohodlnou funkci</span><span class="sxs-lookup"><span data-stu-id="5e13e-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="5e13e-170">Vrátí se tak jednotná operace, která implementuje všechny kroky adiabatic stavu.</span><span class="sxs-lookup"><span data-stu-id="5e13e-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="5e13e-171">První parametr `interpolatedTime` definuje čas, ve kterém se lineárně interpoluje mezi počátečními Hamiltonian popsanými druhým parametrem `evolutionGeneratorStart` a koncovým Hamiltonian, které popisuje třetí parametr `evolutionGeneratorEnd` .</span><span class="sxs-lookup"><span data-stu-id="5e13e-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="5e13e-172">Čtvrtý parametr `timeDependentSimulationAlgorithm` je tam, kde jedna umožňuje výběr algoritmu simulace.</span><span class="sxs-lookup"><span data-stu-id="5e13e-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="5e13e-173">Všimněte si, že pokud `interpolatedTime` je v dostatečném limitu, počáteční základní stav Hamiltonian po celou dobu trvání simulace závislé na čase a tak končí v terénu koncového Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="5e13e-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="5e13e-174">Také definujeme užitečnou operaci, která automaticky provádí všechny kroky typického experimentu pro práci s více operačními systémem.</span><span class="sxs-lookup"><span data-stu-id="5e13e-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="5e13e-175">Například máme následující, které vrací odhad energie stavu, který vytvořila Příprava stavu adiabatic:</span><span class="sxs-lookup"><span data-stu-id="5e13e-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

<span data-ttu-id="5e13e-176">`nQubits`je počet qubits, který se používá ke kódování počátečního stavu.</span><span class="sxs-lookup"><span data-stu-id="5e13e-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="5e13e-177">`statePrepUnitary`připraví stav spuštění z výpočetního základu $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="5e13e-178">`adiabaticUnitary`je jednotková operace, která implementuje přípravu stavu adiabatic, jako je vyprodukována `InterpolatedEvolution` funkcí.</span><span class="sxs-lookup"><span data-stu-id="5e13e-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="5e13e-179">`qpeUnitary`je jednotková operace, která se používá k provádění odhadu fáze ve výsledném stavu.</span><span class="sxs-lookup"><span data-stu-id="5e13e-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="5e13e-180">`phaseEstAlgorithm`je naše volba algoritmu odhadu fází.</span><span class="sxs-lookup"><span data-stu-id="5e13e-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="5e13e-181">V ukázkách jsou pokryté aplikace adiabatic State Preparation.</span><span class="sxs-lookup"><span data-stu-id="5e13e-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="5e13e-182">Pro model Ising s využitím ruční implementace přípravných stavů adiabatic `AdiabaticEvolution` a pomocí funkce se podívejte na [ukázku **AdiabaticIsing** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="5e13e-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span></span>
> <span data-ttu-id="5e13e-183">V případě odhadu fáze a přípravy stavu adiabatic v modelu Ising se podívejte na [ukázku **IsingPhaseEstimation** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="5e13e-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>

> [!TIP]
> <span data-ttu-id="5e13e-184">[Simulace molekulové vodíku](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) je zajímavá a krátká ukázka.</span><span class="sxs-lookup"><span data-stu-id="5e13e-184">The [simulation of molecular Hydrogen](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) is an interesting and brief sample.</span></span> <span data-ttu-id="5e13e-185">Model a experimentální výsledky hlášené v [O'Malley et. Al.](https://arxiv.org/abs/1512.06860)</span><span class="sxs-lookup"><span data-stu-id="5e13e-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="5e13e-186">vyžaduje jenom Pauli matice a má formu $ \hat H = g \_ {0} I \_ 0I \_ 1 + g \_ 1 {z \_ 0} + g \_ 2 {Z \_ 1} + g \_ 3 {z \_ 0} {z \_ 1} + g \_ 4 {Y \_ 0} {y \_ 1} + g \_ 5 {x \_ 0} {x \_ 1} $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="5e13e-187">Jedná se o efektivní Hamiltonian, který vyžaduje jenom 2 qubits, kde se konstanty $g $ vypočítávají z vzdálenosti $R $ mezi dvěma atomy vodíku.</span><span class="sxs-lookup"><span data-stu-id="5e13e-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="5e13e-188">Pomocí funkcí Canon se Pauls převede na unitaries a pak se postupně vyvinuly v krátkém časovém úseku pomocí dekompozice Trotter-Suzuki.</span><span class="sxs-lookup"><span data-stu-id="5e13e-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="5e13e-189">Dobrý odhad stavu $H _2 $ uzemnění se dá vytvořit bez použití přípravy stavu adiabatic, takže se stavová energie může najít přímo pomocí odhadu fáze z Canon.</span><span class="sxs-lookup"><span data-stu-id="5e13e-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="5e13e-190">Shorův algoritmus</span><span class="sxs-lookup"><span data-stu-id="5e13e-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="5e13e-191">Shor algoritmus zůstává jedním z nejvýznamnějších vývojů ve výpočetním prostředí, protože ukázalo, že by se počítače mohly použít k řešení důležitých, aktuálně nerušivých problémů.</span><span class="sxs-lookup"><span data-stu-id="5e13e-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="5e13e-192">Algoritmus Shor poskytuje rychlý způsob, jak rychle vyhodnotit Velká čísla pomocí počítače s velkým množstvím, což je problém s názvem *faktoringu*.</span><span class="sxs-lookup"><span data-stu-id="5e13e-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring*.</span></span>
<span data-ttu-id="5e13e-193">Zabezpečení mnoha současných cryptosystemsch dnů vychází z předpokladu, že pro účely faktoringu neexistuje žádný rychlý algoritmus.</span><span class="sxs-lookup"><span data-stu-id="5e13e-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="5e13e-194">Proto má Shorový algoritmus v podstatě vliv na zabezpečení v rámci po celém světě.</span><span class="sxs-lookup"><span data-stu-id="5e13e-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="5e13e-195">Shor algoritmus lze představit jako hybridní algoritmus.</span><span class="sxs-lookup"><span data-stu-id="5e13e-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="5e13e-196">Počítač s více tečkami slouží k provádění výpočetně náročného úkolu, který se označuje jako perioda hledání.</span><span class="sxs-lookup"><span data-stu-id="5e13e-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="5e13e-197">Výsledky hledání za období jsou následně zpracovávány Classic za účelem odhadu faktorů.</span><span class="sxs-lookup"><span data-stu-id="5e13e-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="5e13e-198">Tyto dva kroky prozkoumáme níže.</span><span class="sxs-lookup"><span data-stu-id="5e13e-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="5e13e-199">Hledání období</span><span class="sxs-lookup"><span data-stu-id="5e13e-199">Period Finding</span></span> ###

<span data-ttu-id="5e13e-200">Zjistili jsme, jak funkce Fourierova transformace a odhad fáze funguje (viz [algoritmy](xref:microsoft.quantum.libraries.standard.algorithms)doby provozu), můžeme pomocí těchto nástrojů vyřešit klasický pevný výpočetní problém nazývaný *hledání období*.</span><span class="sxs-lookup"><span data-stu-id="5e13e-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding*.</span></span>  <span data-ttu-id="5e13e-201">V další části se dozvíte, jak použít hledání období pro faktoring.</span><span class="sxs-lookup"><span data-stu-id="5e13e-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="5e13e-202">Zadaná dvě celá čísla $a $ a $N $, kde $a<N $, cílem hledání období, označovaného také jako hledání objednávek, je najít _objednávku_ $r $ z $a $ modulo $N $, kde $r $ je definováno jako nejmenší kladné celé číslo tak, aby $a ^ r \equiv 1 \Text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="5e13e-203">Pokud chcete zjistit pořadí pomocí počítače s více poli, můžeme použít algoritmus odhadu fáze použitý u následujícího operátoru s jednou jednotkou $U _a $: $ $ U_a \ket{x} \equiv \ket{(AX) \Text{mod} N}. $ $ eigenvectors $U _a $ jsou pro celočíselné $s $ a $0 \ LEQ s \leq r-$1, $ $ \ket{x_s} \equiv 1/\sqrt{r} \sum \_ {k = 0} ^ {r-1} e ^ {\frac{-2\pi i SK} {r}} \ket{a ^ k\text {mod} N}, $ $ jsou _eigenstates_ $U _a $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="5e13e-204">Eigenvalues $U _a $ $ U \_ a \ket{x \_ s} = e ^ {2 \ PI i s/r} \ket{x \_ s}.</span><span class="sxs-lookup"><span data-stu-id="5e13e-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="5e13e-205">Odhad fáze tak má za výstupem eigenvalues $e ^ {2 \ PI i/r} $, z nichž lze $r $ zjistit efektivně pomocí dalších [zlomků](https://en.wikipedia.org/wiki/Continued_fraction) z $s/r $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="5e13e-206">Diagram okruhu pro zjištění doby trvání:</span><span class="sxs-lookup"><span data-stu-id="5e13e-206">The circuit diagram for quantum period finding is:</span></span>

![Diagram okruhu pro hledání doby trvání](~/media/QPE.svg)

<span data-ttu-id="5e13e-208">Zde $2N $ qubits jsou inicializovány do $ \ket {0} $ a $n $ qubits jsou inicializovány do $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-208">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="5e13e-209">Čtenář se znovu může zajímat, proč se v registru eigenstates inicializuje do $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-209">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="5e13e-210">Vzhledem k tomu, že jedna z těchto informací neví, že pořadí $r $ předem nemůžeme přímo připravit stavy $ \ket{x_s} $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-210">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="5e13e-211">Donovanovo, zapíná tento příkaz: $1/\ sqrt {r} \sum \_ {s = 0} ^ {r-1} \ket{x \_ s} = \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-211">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="5e13e-212">Nemusíte ve skutečnosti připravovat $ \ket{x} $!</span><span class="sxs-lookup"><span data-stu-id="5e13e-212">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="5e13e-213">Můžeme pouze připravit registraci $n $ qubits ve stavu $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-213">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="5e13e-214">Okruh obsahuje QFT a několik řízených bran.</span><span class="sxs-lookup"><span data-stu-id="5e13e-214">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="5e13e-215">Brána QFT byla popsána [dříve](xref:microsoft.quantum.libraries.standard.algorithms).</span><span class="sxs-lookup"><span data-stu-id="5e13e-215">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="5e13e-216">Řízený $U _a $ \ket{Maps $ \ket{x} $ to $ (AX) \Text{mod} N} $, pokud je ovládací prvek qubit $ \ket {1} $ a map $ \ket{x} $ na $ \ket{x} $, jinak.</span><span class="sxs-lookup"><span data-stu-id="5e13e-216">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="5e13e-217">Pokud chcete dosáhnout $ (a ^ NX) \Text{mod} N $, můžeme jednoduše použít řízené $U _ {a ^ N} $, kde vypočítáme $a ^ n \Text{mod} N $ Classic, aby se mohl připojit k okruhu.</span><span class="sxs-lookup"><span data-stu-id="5e13e-217">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="5e13e-218">Okruhy, které mají dosáhnout těchto modulárních aritmetických výpočtů, jsou popsané v [aritmetické dokumentaci](./algorithms.md#arithmetic)pro procesory, konkrétně pro implementaci operací řízených $U \_ {a ^ i} $ je potřeba modulární okruh umocnění.</span><span class="sxs-lookup"><span data-stu-id="5e13e-218">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="5e13e-219">Zatímco okruh výše odpovídá [odhadu fáze](xref:microsoft.quantum.characterization.quantumphaseestimation) plnění a explicitně povoluje hledání objednávek, můžeme snížit počet požadovaných qubits.</span><span class="sxs-lookup"><span data-stu-id="5e13e-219">While the circuit above corresponds to [Quantum Phase Estimation](xref:microsoft.quantum.characterization.quantumphaseestimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="5e13e-220">Můžeme buď použít metodu Beauregard pro hledání objednávek, jak je popsáno [na stránce 8 arXiv: quant-pH/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), nebo použijte jednu z rutin odhadu fáze, která je k dispozici v Microsoft..</span><span class="sxs-lookup"><span data-stu-id="5e13e-220">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Characterization.</span></span> <span data-ttu-id="5e13e-221">Například [robustní odhad fáze](xref:microsoft.quantum.characterization.robustphaseestimation) také používá jednu další qubit.</span><span class="sxs-lookup"><span data-stu-id="5e13e-221">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>
 
### <a name="factoring"></a><span data-ttu-id="5e13e-222">Které budou zohledňovat</span><span class="sxs-lookup"><span data-stu-id="5e13e-222">Factoring</span></span> ###
<span data-ttu-id="5e13e-223">Cílem faktoringu je určit dva základní faktory typu Integer $N $, kde $N $ je $n číslo bitu.</span><span class="sxs-lookup"><span data-stu-id="5e13e-223">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="5e13e-224">Sefaktoringování se skládá z kroků popsaných níže.</span><span class="sxs-lookup"><span data-stu-id="5e13e-224">Factoring consists of the steps described below.</span></span> <span data-ttu-id="5e13e-225">Kroky jsou rozděleny do tří částí: rutina klasického předzpracování (1-4); výpočetní rutina pro vyhledá pořadí $a \Text{mod} N $ (5); a klasická rutina postprocessing, která odvozuje základní faktory od pořadí (6-9).</span><span class="sxs-lookup"><span data-stu-id="5e13e-225">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="5e13e-226">Rutina pro klasický proces předzpracování se skládá z následujících kroků:</span><span class="sxs-lookup"><span data-stu-id="5e13e-226">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="5e13e-227">Je-li $N $ je dokonce, vraťte se do základního faktoru $2 $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-227">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="5e13e-228">Pokud $N = p ^ q $ pro $p \geq1 $, $q \geq2 $, vraťte se do základního faktoru $p $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-228">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="5e13e-229">Tento krok se provádí v klasickém nasazení.</span><span class="sxs-lookup"><span data-stu-id="5e13e-229">This step is performed classically.</span></span>
3. <span data-ttu-id="5e13e-230">Vyberte náhodné číslo $a $, které $1 < < N-$1.</span><span class="sxs-lookup"><span data-stu-id="5e13e-230">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="5e13e-231">Pokud $ \Text{GCD} (a, N) >$1, vraťte se k hlavnímu faktoru $ \Text{GCD} (a, N) $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-231">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="5e13e-232">Tento krok je vypočítán pomocí algoritmu euklidovského.</span><span class="sxs-lookup"><span data-stu-id="5e13e-232">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="5e13e-233">Pokud se nevrátí žádný základní faktor, budeme pokračovat v rutině pro nečinnosti:</span><span class="sxs-lookup"><span data-stu-id="5e13e-233">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="5e13e-234">Pro výpočet pořadí $r $ of $a \Text{mod} N $ zavolejte algoritmus pro zjištění doby platnosti.</span><span class="sxs-lookup"><span data-stu-id="5e13e-234">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="5e13e-235">Pomocí $r $ v klasické rutině postprocessing určete základní faktory:</span><span class="sxs-lookup"><span data-stu-id="5e13e-235">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="5e13e-236">Pokud je $r $ liché, vraťte se k kroku předběžného zpracování (3).</span><span class="sxs-lookup"><span data-stu-id="5e13e-236">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="5e13e-237">Pokud je $r $ i $a ^ {r/2} =-1 \ text {mod} N $, vraťte se zpátky na krok předběžného zpracování (3).</span><span class="sxs-lookup"><span data-stu-id="5e13e-237">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="5e13e-238">Pokud $ \Text{GCD} (a ^ {r/2} + 1, N) $ je netriviální faktor $N $, vraťte $ \Text{GCD} (a ^ {r/2} + 1, N) $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-238">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="5e13e-239">Pokud $ \Text{GCD} (a ^ {r/2}-1, N) $ je netriviální faktor $N $, vraťte $ \Text{GCD} (a ^ {r/2}-1, N) $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-239">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="5e13e-240">Algoritmus faktoringu je pravděpodobnostní: může se zobrazit, že s pravděpodobností nejméně jednu polovinu, která $r $ bude i $a ^ {r/2} \neq-1 \Text{mod} N $, čímž se vytvoří základní faktor.</span><span class="sxs-lookup"><span data-stu-id="5e13e-240">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="5e13e-241">(Další [informace](xref:microsoft.quantum.more-information)najdete v části [původní dokument Shor](https://doi.org/10.1109/SFCS.1994.365700) nebo v části *základní výpočetní* texty v tématu.)</span><span class="sxs-lookup"><span data-stu-id="5e13e-241">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="5e13e-242">Pokud se nevrátí žádný primární faktor, jednoduše zopakujeme algoritmus z kroku (1).</span><span class="sxs-lookup"><span data-stu-id="5e13e-242">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="5e13e-243">Po $n $ pokusů se pravděpodobnost, že se všechny pokusy nezdařila, nanejvýš na 2 ^ {-n} $.</span><span class="sxs-lookup"><span data-stu-id="5e13e-243">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="5e13e-244">Proto po opakování algoritmu malý počet pokusů o úspěch je prakticky zaručený.</span><span class="sxs-lookup"><span data-stu-id="5e13e-244">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
