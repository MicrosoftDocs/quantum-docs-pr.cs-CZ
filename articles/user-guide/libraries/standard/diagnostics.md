---
title: Diagnostika ve Q# standardních knihovnách
description: Přečtěte si o diagnostických funkcích a operacích v rámci Q# standardních knihoven používaných k zachycení chyb nebo chyb v programech pro práci s poli.
author: cgranade
uid: microsoft.quantum.libraries.diagnostics
ms.author: chgranad
ms.topic: conceptual
no-loc:
- Q#
- $$v
ms.openlocfilehash: d13122187a24893d297cfdbb3ad4db03eb22ded0
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/26/2021
ms.locfileid: "98858686"
---
# <a name="diagnostics"></a><span data-ttu-id="9f626-103">Diagnostika</span><span class="sxs-lookup"><span data-stu-id="9f626-103">Diagnostics</span></span> #

<span data-ttu-id="9f626-104">Stejně jako u klasického vývoje je důležité, abyste mohli diagnostikovat chyby a chyby v programech za běhu.</span><span class="sxs-lookup"><span data-stu-id="9f626-104">As with classical development, it is important to be able to diagnose mistakes and errors in quantum programs.</span></span>
<span data-ttu-id="9f626-105">Q#Standardní knihovny poskytují celou řadu různých způsobů, jak zajistit správnost programů v řadě, jak je popsáno v <xref:microsoft.quantum.guide.testingdebugging> .</span><span class="sxs-lookup"><span data-stu-id="9f626-105">The Q# standard libraries provide a variety of different ways to ensure the correctness of quantum programs, as detailed in <xref:microsoft.quantum.guide.testingdebugging>.</span></span>
<span data-ttu-id="9f626-106">Z velké části řečeno tato podpora přichází ve formě funkcí a operací, které buď instruují cílový počítač, aby poskytoval další diagnostické informace pro hostitelský program nebo vývojáře, nebo vynutil správnost podmínek a invariant vyjádřených voláním funkce nebo operace.</span><span class="sxs-lookup"><span data-stu-id="9f626-106">Largely speaking, this support comes in the form of functions and operations that either instruct the target machine to provide additional diagnostic information to the host program or developer, or enforce the correctness of conditions and invariants expressed by the function or operation call.</span></span>

## <a name="machine-diagnostics"></a><span data-ttu-id="9f626-107">Diagnostika počítače</span><span class="sxs-lookup"><span data-stu-id="9f626-107">Machine Diagnostics</span></span> ##

<span data-ttu-id="9f626-108">Diagnostiku o klasických hodnotách se dá získat pomocí <xref:Microsoft.Quantum.Intrinsic.Message> funkce pro protokolování zprávy ve formě závislé na počítači.</span><span class="sxs-lookup"><span data-stu-id="9f626-108">Diagnostics about classical values can be obtained by using the <xref:Microsoft.Quantum.Intrinsic.Message> function to log a message in a machine-dependent way.</span></span>
<span data-ttu-id="9f626-109">Ve výchozím nastavení zapíše řetězec do konzoly.</span><span class="sxs-lookup"><span data-stu-id="9f626-109">By default, this writes the string to the console.</span></span>
<span data-ttu-id="9f626-110">Používá se společně s interpolované řetězce a usnadňuje <xref:Microsoft.Quantum.Intrinsic.Message> tak sestavy diagnostických informací o klasických hodnotách:</span><span class="sxs-lookup"><span data-stu-id="9f626-110">Used together with interpolated strings, <xref:Microsoft.Quantum.Intrinsic.Message> makes it easy to report diagnostic information about classical values:</span></span>

```qsharp
let angle = Microsoft.Quantum.Math.PI() * 2.0 / 3.0;
Message($"About to rotate by an angle of {angle}...");
```

> [!NOTE]
> <span data-ttu-id="9f626-111">`Message` má signaturu `(String -> Unit)` , která reprezentuje, že generování zprávy protokolu ladění není možné pozorovat v rámci Q# .</span><span class="sxs-lookup"><span data-stu-id="9f626-111">`Message` has signature `(String -> Unit)`, again representing that emitting a debug log message cannot be observed from within Q#.</span></span>

<span data-ttu-id="9f626-112"><xref:Microsoft.Quantum.Diagnostics.DumpMachine>A <xref:Microsoft.Quantum.Diagnostics.DumpRegister> volat cílové počítače instruují, aby poskytovaly diagnostické informace o všech aktuálně přidělených qubits nebo o konkrétním registru qubits, v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="9f626-112">The <xref:Microsoft.Quantum.Diagnostics.DumpMachine> and <xref:Microsoft.Quantum.Diagnostics.DumpRegister> callables instruct target machines to provide diagnostic information about all currently allocated qubits or about a specific register of qubits, respectively.</span></span>
<span data-ttu-id="9f626-113">Každý cílový počítač se liší v tom, jaké diagnostické informace jsou k dispozici v reakci na instrukci výpisu paměti.</span><span class="sxs-lookup"><span data-stu-id="9f626-113">Each target machine varies in what diagnostic information is provided in response to a dump instruction.</span></span>
<span data-ttu-id="9f626-114">Úplný cílový počítač [simulátoru stavu](xref:microsoft.quantum.machines.full-state-simulator) poskytuje hostitelský program s vektorem stavu, který interně používá k reprezentaci registru qubits.</span><span class="sxs-lookup"><span data-stu-id="9f626-114">The [full state simulator](xref:microsoft.quantum.machines.full-state-simulator) target machine, for instance, provides the host program with the state vector that it uses internally to represent a register of qubits.</span></span>
<span data-ttu-id="9f626-115">Porovnáním je cílový počítač [simulátoru Toffoli](xref:microsoft.quantum.machines.toffoli-simulator) jediným klasickým bitem pro každou qubit.</span><span class="sxs-lookup"><span data-stu-id="9f626-115">By comparison, the [Toffoli simulator](xref:microsoft.quantum.machines.toffoli-simulator) target machine provides a single classical bit for each qubit.</span></span>

 <span data-ttu-id="9f626-116">Další informace o výstupu [simulátoru úplného stavu](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` najdete v části funkce výpisu paměti v našem [článku o testování a ladění](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span><span class="sxs-lookup"><span data-stu-id="9f626-116">To learn more about the [full state simulator's](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` output, take a look at the dump functions section of our [testing and debugging article](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span></span>


## <a name="facts-and-assertions"></a><span data-ttu-id="9f626-117">Fakta a kontrolní výrazy</span><span class="sxs-lookup"><span data-stu-id="9f626-117">Facts and Assertions</span></span> ##

<span data-ttu-id="9f626-118">Jak je popsáno v tématu [testování a ladění](xref:microsoft.quantum.guide.testingdebugging), funkce nebo operace s podpisem `Unit -> Unit` nebo v `Unit => Unit` uvedeném pořadí může být označena jako *Test jednotky*.</span><span class="sxs-lookup"><span data-stu-id="9f626-118">As discussed in [Testing and Debugging](xref:microsoft.quantum.guide.testingdebugging), a function or operation with signature `Unit -> Unit` or `Unit => Unit`, respectively, can be marked as a *unit test*.</span></span>
<span data-ttu-id="9f626-119">Každý test jednotek se obvykle skládá z malého programu v řádu a jedné nebo více podmínek, které kontrolují správnost tohoto programu.</span><span class="sxs-lookup"><span data-stu-id="9f626-119">Each unit test generally consists of a small quantum program, along with one or more conditions that check the correctness of that program.</span></span>
<span data-ttu-id="9f626-120">Tyto podmínky můžou být ve formě obou _skutečností_, které kontrolují hodnoty jejich vstupů nebo _kontrolních výrazů_, které kontrolují stavy jednoho nebo více qubits předaných jako vstup.</span><span class="sxs-lookup"><span data-stu-id="9f626-120">These conditions can come in the form of either _facts_, which check the values of their inputs, or _assertions_, which check the states of one or more qubits passed as input.</span></span>

<span data-ttu-id="9f626-121">Například `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` představuje matematický fakt, který $1 + 1 = $2, zatímco `AssertQubit(One, qubit)` představuje podmínku, kterou měření `qubit` vrátí `One` s jistotou.</span><span class="sxs-lookup"><span data-stu-id="9f626-121">For example, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` represents the mathematical fact that $1 + 1 = 2$, while `AssertQubit(One, qubit)` represents the condition that measuring `qubit` will return a `One` with certainty.</span></span>
<span data-ttu-id="9f626-122">V bývalém případě můžeme ověřit správnost podmínky, pokud jsou k disqubity jenom jeho hodnoty, ale v druhém případě je potřeba, abyste zjistili něco o stavu, abyste mohli kontrolní výraz vyhodnotit.</span><span class="sxs-lookup"><span data-stu-id="9f626-122">In the former case, we can check the correctness of the condition given only its values, while in the latter, we must know something about the state of the qubit in order to evaluate the assertion.</span></span>

<span data-ttu-id="9f626-123">Q#Standardní knihovny poskytují několik různých funkcí pro reprezentaci faktů, včetně:</span><span class="sxs-lookup"><span data-stu-id="9f626-123">The Q# standard libraries provide several different functions for representing facts, including:</span></span>

- <xref:Microsoft.Quantum.Diagnostics.Fact>
- <xref:Microsoft.Quantum.Diagnostics.EqualityWithinToleranceFact>
- <xref:Microsoft.Quantum.Diagnostics.NearEqualityFactC>
- <xref:Microsoft.Quantum.Diagnostics.EqualityFactI>


### <a name="testing-qubit-states"></a><span data-ttu-id="9f626-124">Testování stavů qubit</span><span class="sxs-lookup"><span data-stu-id="9f626-124">Testing Qubit States</span></span> ###

<span data-ttu-id="9f626-125">Kontrolní výrazy v praxi spoléhají na skutečnost, že klasické simulace [přívětach hodnot nevyžadují řízení bez klonování](https://arxiv.org/abs/quant-ph/9607018), takže můžeme při použití simulátoru pro náš cílový počítač udělat nefyzická měření a kontrolní výrazy.</span><span class="sxs-lookup"><span data-stu-id="9f626-125">In practice, assertions rely on the fact that classical simulations of quantum mechanics need not obey the [no-cloning theorem](https://arxiv.org/abs/quant-ph/9607018), such that we can make unphysical measurements and assertions when using a simulator for our target machine.</span></span>
<span data-ttu-id="9f626-126">Proto můžeme před nasazením na hardware otestovat jednotlivé operace na klasický simulátor.</span><span class="sxs-lookup"><span data-stu-id="9f626-126">Thus, we can test individual operations on a classical simulator before deploying on hardware.</span></span>
<span data-ttu-id="9f626-127">V cílových počítačích, které neumožňují vyhodnocování kontrolních výrazů, volání <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> lze bezpečně ignorovat.</span><span class="sxs-lookup"><span data-stu-id="9f626-127">On target machines which do not allow evaluation of assertions, calls to <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> can be safely ignored.</span></span>

<span data-ttu-id="9f626-128">Obecně platí, že operace vyhodnotí <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> , že měření daného qubits v dané Pauli základu bude mít vždy daný výsledek.</span><span class="sxs-lookup"><span data-stu-id="9f626-128">More generally, the <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> operation asserts that measuring the given qubits in the given Pauli basis will always have the given result.</span></span>
<span data-ttu-id="9f626-129">Pokud se kontrolní výraz nepovede, spuštění skončí voláním `fail` dané zprávy.</span><span class="sxs-lookup"><span data-stu-id="9f626-129">If the assertion fails, the run ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="9f626-130">Ve výchozím nastavení tato operace není implementována. simulátory, které ji mohou podporovat, by měly poskytnout implementaci, která provádí kontrolu za běhu.</span><span class="sxs-lookup"><span data-stu-id="9f626-130">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="9f626-131">`AssertMeasurement` má signaturu `((Pauli[], Qubit[], Result, String) -> ())` .</span><span class="sxs-lookup"><span data-stu-id="9f626-131">`AssertMeasurement` has signature `((Pauli[], Qubit[], Result, String) -> ())`.</span></span>
<span data-ttu-id="9f626-132">Vzhledem k tomu `AssertMeasurement` , že se jedná o funkci s prázdnou řazenou kolekcí členů jako svůj výstupní typ, `AssertMeasurement` nejsou v rámci programu pozorovatelé žádné účinky volání Q# .</span><span class="sxs-lookup"><span data-stu-id="9f626-132">Since `AssertMeasurement` is a function with an empty tuple as its output type, no effects from having called `AssertMeasurement` are observable within a Q# program.</span></span>

<span data-ttu-id="9f626-133"><xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability>Funkce Operation vyhodnotí, že měření daného qubits v daném Pauli základu bude mít daný výsledek s danou pravděpodobností v rámci určité tolerance.</span><span class="sxs-lookup"><span data-stu-id="9f626-133">The <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> operation function asserts that measuring the given qubits in the given Pauli basis will have the given result with the given probability, within some tolerance.</span></span>
<span data-ttu-id="9f626-134">Tolerance je aditivní (například `abs(expected-actual) < tol` ).</span><span class="sxs-lookup"><span data-stu-id="9f626-134">Tolerance is additive (for example, `abs(expected-actual) < tol`).</span></span>
<span data-ttu-id="9f626-135">Pokud se kontrolní výraz nepovede, spuštění skončí voláním `fail` dané zprávy.</span><span class="sxs-lookup"><span data-stu-id="9f626-135">If the assertion fails, the run ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="9f626-136">Ve výchozím nastavení tato operace není implementována. simulátory, které ji mohou podporovat, by měly poskytnout implementaci, která provádí kontrolu za běhu.</span><span class="sxs-lookup"><span data-stu-id="9f626-136">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="9f626-137">`AssertMeasurementProbability` má signaturu `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)` .</span><span class="sxs-lookup"><span data-stu-id="9f626-137">`AssertMeasurementProbability` has signature `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)`.</span></span> <span data-ttu-id="9f626-138">První z `Double` parametrů poskytuje požadovanou pravděpodobnost výsledku a druhou pro toleranci.</span><span class="sxs-lookup"><span data-stu-id="9f626-138">The first of `Double` parameters gives the desired probability of the result, and the second one the tolerance.</span></span>

<span data-ttu-id="9f626-139">Můžeme provést více než vyhodnotit jedno měření, a to pomocí klasických informací používaných simulátorem, které reprezentují vnitřní stav qubit, snadněji ke kopírování. to znamená, že pro otestování tohoto kontrolního výrazu není nutné skutečně provádět měření.</span><span class="sxs-lookup"><span data-stu-id="9f626-139">We can do more than assert a single measurement, using that the classical information used by a simulator to represent the internal state of a qubit is amenable to copying, such that we do not need to actually perform a measurement to test our assertion.</span></span>
<span data-ttu-id="9f626-140">Konkrétně to nám umožní důvod na *nekompatibilní* měření, která by nebyla možná na skutečném hardwaru.</span><span class="sxs-lookup"><span data-stu-id="9f626-140">In particular, this allows us to reason about *incompatible* measurements that would be impossible on actual hardware.</span></span>

<span data-ttu-id="9f626-141">Předpokládejme, že `P : Qubit => Unit` se jedná o operaci, která má za cíl připravit stav $ \ket{\psi} $, pokud je jeho vstup ve stavu $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="9f626-141">Suppose that `P : Qubit => Unit` is an operation intended to prepare the state $\ket{\psi}$ when its input is in the state $\ket{0}$.</span></span>
<span data-ttu-id="9f626-142">Pojďme $ \ket{\psi} $ být skutečným stavem, který připravil `P` .</span><span class="sxs-lookup"><span data-stu-id="9f626-142">Let $\ket{\psi'}$ be the actual state prepared by `P`.</span></span>
<span data-ttu-id="9f626-143">Pak $ \ket{\psi} = \ket{\psi '} $ IF a pouze pokud se měří $ \ket{\psi '} $ na ose popsané v $ \ket{\psi} $ Always vrátí `Zero` .</span><span class="sxs-lookup"><span data-stu-id="9f626-143">Then, $\ket{\psi} = \ket{\psi'}$ if and only if measuring $\ket{\psi'}$ in the axis described by $\ket{\psi}$ always returns `Zero`.</span></span>
<span data-ttu-id="9f626-144">To znamená, že \begin{align} \ket{\psi} = \ket{\psi '} \Text{if a pouze if} \braket{\psi | \psi '} = 1.</span><span class="sxs-lookup"><span data-stu-id="9f626-144">That is, \begin{align} \ket{\psi} = \ket{\psi'} \text{ if and only if } \braket{\psi | \psi'} = 1.</span></span>
<span data-ttu-id="9f626-145">\end{align} pomocí primitivních operací, které jsou definovány v předehru, můžeme přímo provést měření, které vrátí, `Zero` Pokud je $ \ket{\psi} $ eigenstate jedné z operátorů Pauli.</span><span class="sxs-lookup"><span data-stu-id="9f626-145">\end{align} Using the primitive operations defined in the prelude, we can directly perform a measurement that returns `Zero` if $\ket{\psi}$ is an eigenstate of one of the Pauli operators.</span></span>


<span data-ttu-id="9f626-146">Tato operace <xref:Microsoft.Quantum.Diagnostics.AssertQubit> poskytuje obzvláště užitečnou zkrácený zkrácený postup v případě, že chceme otestovat kontrolní výraz $ \ket{\psi} = \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="9f626-146">The operation <xref:Microsoft.Quantum.Diagnostics.AssertQubit> provides a particularly useful shorthand to do so in the case that we wish to test the assertion $\ket{\psi} = \ket{0}$.</span></span>
<span data-ttu-id="9f626-147">To je běžné, například když jsme nepočítali, aby vraceli ancilla qubits na $ \ket {0} $ před jejich uvolněním.</span><span class="sxs-lookup"><span data-stu-id="9f626-147">This is common, for instance, when we have uncomputed to return ancilla qubits to $\ket{0}$ before releasing them.</span></span>
<span data-ttu-id="9f626-148">Vystavování proti $ \ket {0} $ je také užitečné, když chceme uplatnit, že se dopravují dvě stavová Příprava `P` a `Q` operace připravují stejný stav a když `Q` podporuje `Adjoint` .</span><span class="sxs-lookup"><span data-stu-id="9f626-148">Asserting against $\ket{0}$ is also useful when we wish to assert that two state preparation `P` and `Q` operations both prepare the same state, and when `Q` supports `Adjoint`.</span></span>
<span data-ttu-id="9f626-149">Konkrétně</span><span class="sxs-lookup"><span data-stu-id="9f626-149">In particular,</span></span>

```qsharp
using (register = Qubit()) {
    P(register);
    Adjoint Q(register);

    AssertQubit(Zero, register);
}
```

<span data-ttu-id="9f626-150">Obecně řečeno, ale nemůžeme mít přístup k kontrolním hodnotám, které se neshodují s eigenstates operátorů Pauli.</span><span class="sxs-lookup"><span data-stu-id="9f626-150">More generally, however, we may not have access to assertions about states that do not coincide with eigenstates of Pauli operators.</span></span>
<span data-ttu-id="9f626-151">Například $ \ket{\psi} = (\ket {0} + e ^ {i \pi/8} \ket {1} )/\sqrt {2} $ není eigenstate žádného operátoru Pauli, takže nemůžeme použít <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> k jednoznačnému určení toho, že se stav $ \ket{\psi} $ rovná $ \ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="9f626-151">For example, $\ket{\psi} = (\ket{0} + e^{i \pi / 8} \ket{1}) / \sqrt{2}$ is not an eigenstate of any Pauli operator, such that we cannot use <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> to uniquely determine that a state $\ket{\psi'}$ is equal to $\ket{\psi}$.</span></span>
<span data-ttu-id="9f626-152">Místo toho je nutné vyhodnotit kontrolní výraz $ \ket{\psi} = \ket{\psi} $ na předpoklady, které mohou být přímo testovány pomocí primitivních hodnot, které podporuje náš simulátor.</span><span class="sxs-lookup"><span data-stu-id="9f626-152">Instead, we must decompose the assertion $\ket{\psi'} = \ket{\psi}$ into assumptions that can be directly tested using  the primitives supported by our simulator.</span></span>
<span data-ttu-id="9f626-153">Provedete to tak, že $ \ket{\psi} = \Alpha \ket {0} + \beta \ket {1} $ for Complex Numbers $ \Alpha = a \_ r + a \_ i $ a $ \beta $.</span><span class="sxs-lookup"><span data-stu-id="9f626-153">To do so, let $\ket{\psi} = \alpha \ket{0} + \beta \ket{1}$ for complex numbers $\alpha = a\_r + a\_i i$ and $\beta$.</span></span>
<span data-ttu-id="9f626-154">Všimněte si, že tento výraz vyžaduje čtyři reálné hodnoty $ \{ a \_ r, a \_ i, b \_ r, b \_ i \} $, aby bylo možné určit, že každé komplexní číslo může být vyjádřeno jako součet reálné a imaginární části.</span><span class="sxs-lookup"><span data-stu-id="9f626-154">Note that this expression requires four real numbers $\{a\_r, a\_i, b\_r, b\_i\}$ to specify, as each complex number can be expressed as the sum of a real and imaginary part.</span></span>
<span data-ttu-id="9f626-155">Z důvodu globální fáze si ale můžeme vybrat $a \_ i = $0, takže potřebujeme jenom tři reálné počty, abyste jednoznačně určili qubit stav.</span><span class="sxs-lookup"><span data-stu-id="9f626-155">Due to the global phase, however, we can choose $a\_i = 0$, such that we only need three real numbers to uniquely specify a single-qubit state.</span></span>

<span data-ttu-id="9f626-156">Proto je potřeba zadat tři kontrolní výrazy, které jsou vzájemně nezávislé, aby bylo možné vyhodnotit stav, který očekáváme.</span><span class="sxs-lookup"><span data-stu-id="9f626-156">Thus, we need to specify three assertions which are independent of each other in order to assert the state that we expect.</span></span>
<span data-ttu-id="9f626-157">Provedeme to tak, že `Zero` vyhledáme pravděpodobnost pozorování pro každé měření Pauliy uvedené na hodnotu $ \Alpha $ a $ \beta $ a každý nezávisle se vyhodnotí.</span><span class="sxs-lookup"><span data-stu-id="9f626-157">We do so by finding the probability of observing `Zero` for each Pauli measurement given $\alpha$ and $\beta$, and asserting each independently.</span></span>
<span data-ttu-id="9f626-158">`Result`Hodnoty pro Pauli $X $, $Y $ a $Z $ nechte $x $, $y $ a $z $.</span><span class="sxs-lookup"><span data-stu-id="9f626-158">Let $x$, $y$, and $z$ be `Result` values for Pauli $X$, $Y$, and $Z$ measurements respectively.</span></span>
<span data-ttu-id="9f626-159">Pak použijte funkci pravděpodobnosti pro měření doby využívání hodnoty \begin{align} \Pr (x = \texttt{Zero} | \Alpha, \beta) & = \frac12 + a \_ r b \_ r + a \_ i b \_ i \\ \\ \Pr (y = \texttt{Zero} | \Alpha, \beta) & = \frac12 + a \_ r b \_ i-a \_ i b \_ r \\ \\ \Pr (z = \texttt{Zero} | \Alpha, \beta) & = \frac12\left (1 + a \_ r ^ 2 + a \_ i ^ 2 + b \_ r ^ 2 + b \_ i ^ 2 \right).</span><span class="sxs-lookup"><span data-stu-id="9f626-159">Then, using the likelihood function for quantum measurements, \begin{align} \Pr(x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_r + a\_i b\_i \\\\ \Pr(y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_i - a\_i b\_r \\\\ \Pr(z = \texttt{Zero} | \alpha, \beta) & = \frac12\left( 1 + a\_r^2 + a\_i^2 + b\_r^2 + b\_i^2 \right).</span></span>
<span data-ttu-id="9f626-160">\end{align}</span><span class="sxs-lookup"><span data-stu-id="9f626-160">\end{align}</span></span>

<span data-ttu-id="9f626-161">Tato <xref:Microsoft.Quantum.Diagnostics.AssertQubitIsInStateWithinTolerance> operace implementuje tyto kontrolní výrazy s ohledem na reprezentace $ \Alpha $ a $ \beta $ jako hodnoty typu <xref:Microsoft.Quantum.Math.Complex> .</span><span class="sxs-lookup"><span data-stu-id="9f626-161">The <xref:Microsoft.Quantum.Diagnostics.AssertQubitIsInStateWithinTolerance> operation implements these assertions given representations of $\alpha$ and $\beta$ as values of type <xref:Microsoft.Quantum.Math.Complex>.</span></span>
<span data-ttu-id="9f626-162">To je užitečné, když se očekávaný stav dá vypočítat matematicky.</span><span class="sxs-lookup"><span data-stu-id="9f626-162">This is helpful when the expected state can be computed mathematically.</span></span>

### <a name="asserting-equality-of-quantum-operations"></a><span data-ttu-id="9f626-163">Vyhodnocení rovnosti operací s více podsebou</span><span class="sxs-lookup"><span data-stu-id="9f626-163">Asserting Equality of Quantum Operations</span></span> ###

<span data-ttu-id="9f626-164">Zatím jsme se zavedli k testování operací, které jsou určené k přípravě konkrétních stavů.</span><span class="sxs-lookup"><span data-stu-id="9f626-164">Thus far, we have been concerned with testing operations which are intended to prepare particular states.</span></span>
<span data-ttu-id="9f626-165">Často se ale zajímá, jak operace funguje pro libovolné vstupy, a ne pro jeden pevný vstup.</span><span class="sxs-lookup"><span data-stu-id="9f626-165">Often, however, we are interested in how an operation acts for arbitrary inputs rather than for a single fixed input.</span></span>
<span data-ttu-id="9f626-166">Předpokládejme například, že jsme implementovali operaci `U : ((Double, Qubit[]) => () : Adjoint)` odpovídající rodině operátorů s jednou $U (t) $ a místo použití byla poskytnuta explicitní `adjoint` blok `adjoint auto` .</span><span class="sxs-lookup"><span data-stu-id="9f626-166">For example, suppose we have implemented an operation `U : ((Double, Qubit[]) => () : Adjoint)` corresponding to a family of unitary operators $U(t)$, and have provided an explicit `adjoint` block instead of using `adjoint auto`.</span></span>
<span data-ttu-id="9f626-167">Můžeme vás zajímat, že $U ^ \dagger (t) = U (-t) $, jak je očekáváno, pokud $t $ představuje čas vývoje.</span><span class="sxs-lookup"><span data-stu-id="9f626-167">We may be interested in asserting that $U^\dagger(t) = U(-t)$, as expected if $t$ represents an evolution time.</span></span>

<span data-ttu-id="9f626-168">Obecně řečeno, existují dvě různé strategie, které můžeme použít při provádění kontrolního výrazu, který se shoduje se dvěma operacemi `U` a `V` jednají stejným způsobem.</span><span class="sxs-lookup"><span data-stu-id="9f626-168">Broadly speaking, there are two different strategies that we can follow in making the assertion that two operations `U` and `V` act identically.</span></span>
<span data-ttu-id="9f626-169">Nejprve můžeme kontrolovat, zda `U(target); (Adjoint V)(target);` zachovává každý stav na daném základě.</span><span class="sxs-lookup"><span data-stu-id="9f626-169">First, we can check that `U(target); (Adjoint V)(target);` preserves each state in a given basis.</span></span>
<span data-ttu-id="9f626-170">Za druhé můžeme ověřit, že `U(target); (Adjoint V)(target);` jednání na polovinu entangled stavu zachovává entanglement.</span><span class="sxs-lookup"><span data-stu-id="9f626-170">Second, we can check that `U(target); (Adjoint V)(target);` acting on half of an entangled state preserves that entanglement.</span></span>
<span data-ttu-id="9f626-171">Tyto strategie jsou implementované operacemi Canon <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlace> a v <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualReferenced> uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="9f626-171">These strategies are implemented by the canon operations <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlace> and <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualReferenced>, respectively.</span></span>

> [!NOTE]
> <span data-ttu-id="9f626-172">Odkazovaný kontrolní výraz uvedený výše funguje na základě [Choi – Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), matematického rozhraní, které souvisí s operacemi $n $ qubits až entangled stavy na $2N $ qubits.</span><span class="sxs-lookup"><span data-stu-id="9f626-172">The referenced assertion discussed above works based on the [Choi–Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), a mathematical framework which relates operations on $n$ qubits to entangled states on $2n$ qubits.</span></span>
> <span data-ttu-id="9f626-173">Konkrétně operace identity na $n $ qubits je představována $n $ kopie stavu entangled $ \ket{\ beta_ {00} } \mathrel{: =} (\ket {00} + \ket {11} )/\sqrt {2} $.</span><span class="sxs-lookup"><span data-stu-id="9f626-173">In particular, the identity operation on $n$ qubits is represented by $n$ copies of the entangled state $\ket{\beta_{00}} \mathrel{:=} (\ket{00} + \ket{11}) / \sqrt{2}$.</span></span>
> <span data-ttu-id="9f626-174">Tato operace <xref:Microsoft.Quantum.Preparation.PrepareChoiState> implementuje tuto isomorphism a připraví stav, který představuje danou operaci.</span><span class="sxs-lookup"><span data-stu-id="9f626-174">The operation <xref:Microsoft.Quantum.Preparation.PrepareChoiState> implements this isomorphism, preparing a state that represents a given operation.</span></span>

<span data-ttu-id="9f626-175">Zhruba tyto strategie jsou odlišené o kompromisech podle času.</span><span class="sxs-lookup"><span data-stu-id="9f626-175">Roughly, these strategies are distinguished by a time–space tradeoff.</span></span>
<span data-ttu-id="9f626-176">Iterace v každém vstupním stavu trvá delší dobu, zatímco použití entanglement jako odkazu vyžaduje uložení dalších qubits.</span><span class="sxs-lookup"><span data-stu-id="9f626-176">Iterating through each input state takes additional time, while using entanglement as a reference requires storing additional qubits.</span></span>
<span data-ttu-id="9f626-177">V případech, kdy operace implementuje vratné klasické operace, například zajímá Vás jenom o své chování při výpočetních intervalech, <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlaceCompBasis> testuje rovnost v této omezené sadě vstupů.</span><span class="sxs-lookup"><span data-stu-id="9f626-177">In cases where an operation implements a reversible classical operation, such that we are only interested in its behavior on computational basis states, <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlaceCompBasis> tests equality on this restricted set of inputs.</span></span>

> [!TIP]
> <span data-ttu-id="9f626-178">Iterace v rámci vstupních stavů je zpracována operacemi výčtu <xref:Microsoft.Quantum.Canon.IterateThroughCartesianProduct> a <xref:Microsoft.Quantum.Canon.IterateThroughCartesianPower> .</span><span class="sxs-lookup"><span data-stu-id="9f626-178">The iteration over input states is handled by the enumeration operations <xref:Microsoft.Quantum.Canon.IterateThroughCartesianProduct> and <xref:Microsoft.Quantum.Canon.IterateThroughCartesianPower>.</span></span>
> <span data-ttu-id="9f626-179">Tyto operace jsou obecně užitečné pro použití operace u každého prvku kartézském produktu mezi dvěma nebo více sadami.</span><span class="sxs-lookup"><span data-stu-id="9f626-179">These operations are useful more generally for applying an operation to each element of the Cartesian product between two or more sets.</span></span>

<span data-ttu-id="9f626-180">U těchto dvou přístupů se ale Nepostradatelně testují různé vlastnosti testovaných operací.</span><span class="sxs-lookup"><span data-stu-id="9f626-180">More critically, however, the two approaches test different properties of the operations under examination.</span></span>
<span data-ttu-id="9f626-181">Vzhledem k tomu, že místní kontrolní výraz volá každou operaci několikrát, jednou pro každý vstupní stav, jakékoli náhodné volby a výsledky měření mohou být mezi jednotlivými voláními změněny.</span><span class="sxs-lookup"><span data-stu-id="9f626-181">Since the in-place assertion calls each operation multiple times, once for each input state, any random choices and measurement results might change between calls.</span></span>
<span data-ttu-id="9f626-182">Naproti tomu odkazovaný kontrolní výraz volá každou operaci přesně jednou, takže kontroluje, zda se operace rovnají *v jednom snímku*.</span><span class="sxs-lookup"><span data-stu-id="9f626-182">By contrast, the referenced assertion calls each operation exactly once, such that it checks that the operations are equal *in a single shot*.</span></span>
<span data-ttu-id="9f626-183">Oba tyto testy jsou užitečné v případě, že jsou zajištěny správné množství programů.</span><span class="sxs-lookup"><span data-stu-id="9f626-183">Both of these tests are useful in ensuring the correctness of quantum programs.</span></span>


## <a name="further-reading"></a><span data-ttu-id="9f626-184">Další čtení</span><span class="sxs-lookup"><span data-stu-id="9f626-184">Further Reading</span></span> ##

- <xref:microsoft.quantum.guide.testingdebugging>
- <xref:Microsoft.Quantum.Diagnostics>
