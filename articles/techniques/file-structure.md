---
title: Úvod k technikům vývoje Microsoft Docs
description: Úvod k technikům vývoje
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 702d23293a1c340ddd3d7032d0e05294345469b2
ms.sourcegitcommit: aa5e6f4a2deb4271a333d3f1b1eb69b5bb9a7bad
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/02/2019
ms.locfileid: "73442553"
---
# <a name="q-program-overview"></a><span data-ttu-id="a104b-103">Přehled programu Q #</span><span class="sxs-lookup"><span data-stu-id="a104b-103">Q# program overview</span></span>

<span data-ttu-id="a104b-104">Q # je škálovatelný a víceúrovňový programovací jazyk specifický pro doménu pro náročné výpočty.</span><span class="sxs-lookup"><span data-stu-id="a104b-104">Q# is a scalable, multi-paradigm, domain-specific programming language for quantum computing.</span></span> <span data-ttu-id="a104b-105">Q # je programovací jazyk, ve kterém se dá použít k popisu způsobu, jakým se spouští instrukce na počítačích s více podsebou.</span><span class="sxs-lookup"><span data-stu-id="a104b-105">Q# is a quantum programming language in that it can be used to describe how instructions are executed on quantum machines.</span></span> <span data-ttu-id="a104b-106">Počítače, u kterých se může zaměřit rozsah z simulátorů na skutečný hardware na více než jednou.</span><span class="sxs-lookup"><span data-stu-id="a104b-106">The machines that can be targeted range from simulators to actual quantum hardware.</span></span> <span data-ttu-id="a104b-107">Q # je škálovatelný: dá se použít k psaní jednoduchých ukázkových programů, jako je teleport, které běží na několika qubits, ale podporuje také psaní velkých a propracovaných programů, jako jsou simulace složitých molekul, které budou vyžadovat velké počítače s miliony qubits.</span><span class="sxs-lookup"><span data-stu-id="a104b-107">Q# is scalable: it can be used to write simple demonstration programs like teleport that run on a few qubits, but also supports writing large, sophisticated programs such as simulations of complex molecules that will require large machines with millions of qubits.</span></span> <span data-ttu-id="a104b-108">I když jsou velké fyzické počítače stále v budoucnosti, Q # umožňuje programátorům programovat komplexní algoritmy pro všechna období.</span><span class="sxs-lookup"><span data-stu-id="a104b-108">Even though large physical machines are still in the future, Q# allows a programmer to program complex quantum algorithms now.</span></span> <span data-ttu-id="a104b-109">Co je více, Q # podporuje různé úkoly, jako je ladění, profilace, odhad prostředků a určité simulace pro zvláštní účely, škálovatelný způsob.</span><span class="sxs-lookup"><span data-stu-id="a104b-109">What is more, Q# supports various tasks such as debugging, profiling, resource estimation, and certain special-purpose simulations in a scalable way.</span></span> 

<span data-ttu-id="a104b-110">Z technického hlediska může být program pro práci s více částmi zobrazený jako konkrétní sada klasických funkcí, které při volání generují okruhy na sebe jako vedlejší účinky.</span><span class="sxs-lookup"><span data-stu-id="a104b-110">From a technical perspective, a quantum program can be seen as a particular set of classical functions which, when called, generate quantum circuits as their side effects.</span></span> <span data-ttu-id="a104b-111">Důležitým vlivem tohoto zobrazení je to, že program napsaný v Q # přímo nemodeluje qubits sám sebe, ale místo toho popisuje, jak počítač s klasickým ovládacím prvkem komunikuje s těmito qubits.</span><span class="sxs-lookup"><span data-stu-id="a104b-111">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="a104b-112">V rámci návrhu Q # proto nedefinuje stavy, které jsou na sobě nebo jiné vlastnosti, přímo, ale nepřímo prostřednictvím akce různých podprocesů definovaných v jazyce.</span><span class="sxs-lookup"><span data-stu-id="a104b-112">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly, but rather does so indirectly through the action of the various subroutines defined in the language.</span></span>
<span data-ttu-id="a104b-113">Například je třeba vzít v úvahu stav $ \ket{+} = \left (\ket{0} + \ket{1}\right)/\sqrt{2}$ popsaný v příručce k [koncepcím výpočetního](xref:microsoft.quantum.concepts.intro) stavu.</span><span class="sxs-lookup"><span data-stu-id="a104b-113">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="a104b-114">K přípravě tohoto stavu v Q # použijeme fakty, že se qubits inicializuje ve stavu $ \ket{0}$ a že $ \ket{+} = H\ket{0}$, kde $H $ je převod Hadamard:</span><span class="sxs-lookup"><span data-stu-id="a104b-114">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a><span data-ttu-id="a104b-115">Q # tranformations stavů</span><span class="sxs-lookup"><span data-stu-id="a104b-115">Q# tranformations of quantum states</span></span>

<span data-ttu-id="a104b-116">Při psaní výše uvedeného programu jsme v rámci tohoto programu explicitně neodkazovali na stav ve Q #, ale místo toho jsme popsali, jak byl stav *transformován* náš program.</span><span class="sxs-lookup"><span data-stu-id="a104b-116">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="a104b-117">Podobně podobný způsob, jakým program grafického shaderu shromažďuje popis transformací na každý vrchol, program v rámci Q # shromažďuje transformace na stavové stavy.</span><span class="sxs-lookup"><span data-stu-id="a104b-117">Thus, similar to how a graphics shader program accumulates a description of transformations to each vertex, a quantum program in Q# accumulates transformations to quantum states.</span></span>
<span data-ttu-id="a104b-118">To nám umožní zcela nezávislá informace o tom, co *je* stav bez nároku na každém cílovém počítači, což může mít různé interpretace v závislosti na počítači.</span><span class="sxs-lookup"><span data-stu-id="a104b-118">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="a104b-119">Z perspektivy programu Q # je qubit zcela neprůhledný odkaz na vnitřní strukturu cílového počítače.</span><span class="sxs-lookup"><span data-stu-id="a104b-119">From the perspective of a Q# program, a qubit is an entirely opaque reference to the internal structure of a target machine.</span></span>
<span data-ttu-id="a104b-120">Program Q # nemá žádnou schopnost introspect do stavu qubit, jeho reprezentace na cílovém počítači nebo i to, jestli se jedná o stejný qubit jako ostatní qubit k dispozici pro program.</span><span class="sxs-lookup"><span data-stu-id="a104b-120">A Q# program has no ability to introspect into the state of a qubit, its representation on a target machine, or even whether it is the same qubit as any other qubit available to the program.</span></span>
<span data-ttu-id="a104b-121">Program může spíše volat operace, jako je například `Measure`, k získání informací z qubit a volání operací, jako je `X` a `H`, aby fungovaly ve stavu qubit.</span><span class="sxs-lookup"><span data-stu-id="a104b-121">Rather, a program can call operations such as `Measure` to learn information from a qubit, and call operations such as `X` and `H` to act on the state of a qubit.</span></span>
<span data-ttu-id="a104b-122">Tyto operace nemají v rámci jazyka žádnou vnitřní definici a jsou provedeny pouze cílovým počítačem používaným ke spuštění konkrétního programu Q #.</span><span class="sxs-lookup"><span data-stu-id="a104b-122">These operations have no intrinsic definition within the language, and are made concrete only by the target machine used to run a particular Q# program.</span></span>
<span data-ttu-id="a104b-123">Program Q # znovu sloučí tyto operace, jak jsou definovány cílovým počítačem, a vytvoří tak nové operace vyšší úrovně, které budou vyjadřovat výpočetní procesory.</span><span class="sxs-lookup"><span data-stu-id="a104b-123">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="a104b-124">V tomto případě Q # usnadňuje vyjádření logiky podkladových a hybridních životních procesorů, a to i obecně s ohledem na strukturu cílového počítače nebo simulátoru.</span><span class="sxs-lookup"><span data-stu-id="a104b-124">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum-classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="a104b-125">Operace a funkce Q #</span><span class="sxs-lookup"><span data-stu-id="a104b-125">Q# operations and functions</span></span>

<span data-ttu-id="a104b-126">V betonu je program Q # tvořen jednou nebo více *operacemi*, jednou nebo více *funkcemi*a uživatelem definovanými typy.</span><span class="sxs-lookup"><span data-stu-id="a104b-126">Concretely, a Q# program is comprised of one or more *operations*, one or more *functions*, and user defined types.</span></span> <span data-ttu-id="a104b-127">Operace slouží k popisu transformací stavu počítačového provozu a jsou to nejzákladnější stavební blok programů Q #.</span><span class="sxs-lookup"><span data-stu-id="a104b-127">Operations are used to describe the transformations of the state of a quantum machine and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="a104b-128">Každá operace definovaná v rámci Q # může potom zavolat libovolný počet dalších operací, včetně integrovaných *vnitřních* operací implementovaných cílovým počítačem.</span><span class="sxs-lookup"><span data-stu-id="a104b-128">Each operation defined in Q# may then call any number of other operations, including the built-in *intrinsic* operations implemented by a target machine.</span></span>
<span data-ttu-id="a104b-129">Při kompilaci je každá operace reprezentována jako typ třídy .NET, který lze poskytnout cílovým počítačům.</span><span class="sxs-lookup"><span data-stu-id="a104b-129">When compiled, each operation is represented as a .NET class type that can be provided to target machines.</span></span>

<span data-ttu-id="a104b-130">Na rozdíl od operací se funkce používají k popisu čistě klasického chování a nemají žádné vlivy na výpočetní výkonové hodnoty v klasickém prostředí.</span><span class="sxs-lookup"><span data-stu-id="a104b-130">In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.</span></span> <span data-ttu-id="a104b-131">Q # je jazyk silného typu a je dodáván se sadou vestavěných primitivních typů, jakož i s podporou pro uživatelsky definované typy.</span><span class="sxs-lookup"><span data-stu-id="a104b-131">Q# is a strongly typed language and comes with a set of built-in primitive types as well as support for user defined types.</span></span> 

<span data-ttu-id="a104b-132">V celé zbývající části tohoto průvodce se dozvíte, jak používat různé jazykové koncepty a konstrukce, které nám pomůžou definovat složité programy v jádře prostřednictvím základních stavebních bloků operací, funkcí a typů.</span><span class="sxs-lookup"><span data-stu-id="a104b-132">Throughout the rest of this guide, we will see how to use different language concepts and constructs to help us define complex quantum programs through the basic building blocks of operations, functions, and types.</span></span> 

## <a name="structure-of-q-source-files"></a><span data-ttu-id="a104b-133">Struktura zdrojových souborů Q #</span><span class="sxs-lookup"><span data-stu-id="a104b-133">Structure of Q# Source Files</span></span>

<span data-ttu-id="a104b-134">Minimálně zdrojový soubor Q # se skládá z *deklarace oboru názvů*, která určuje obor názvů .NET, který bude obsahovat definice ve zdrojovém souboru.</span><span class="sxs-lookup"><span data-stu-id="a104b-134">Minimally, a Q# source file consists of a *namespace declaration*, which specifies a .NET namespace which will contain the definitions in the source file.</span></span>
<span data-ttu-id="a104b-135">Definice z jiných zdrojových souborů Q # a knihoven lze zahrnout pomocí příkazu `open`.</span><span class="sxs-lookup"><span data-stu-id="a104b-135">Definitions from other Q# source files and libraries can be included using the `open` statement.</span></span>
<span data-ttu-id="a104b-136">Například většina operací definujících základní brány je definována v oboru názvů <xref:microsoft.quantum.intrinsic>.</span><span class="sxs-lookup"><span data-stu-id="a104b-136">For instance, most of the operations defining fundamental gates are defined in the <xref:microsoft.quantum.intrinsic> namespace.</span></span>
<span data-ttu-id="a104b-137">Abychom to mohli zpřístupnit pro náš kód, jednoduše `open` tento obor názvů na začátku každého souboru:</span><span class="sxs-lookup"><span data-stu-id="a104b-137">To make this available to our code, we simply `open` that namespace at the top of each file:</span></span>

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

<span data-ttu-id="a104b-138">V rámci oboru názvů každý zdrojový soubor Q # může definovat libovolnou kombinaci *operací*, *funkcí*a *uživatelsky definovaných typů*.</span><span class="sxs-lookup"><span data-stu-id="a104b-138">Within a namespace, each Q# source file can define any combination of *operations*, *functions*, and *user-defined types*.</span></span>
<span data-ttu-id="a104b-139">Ve zbytku této části popíšeme každou z nich a nabídnou si příklady, jak je možné využít v praxi k zajištění užitečných programů pro užívání.</span><span class="sxs-lookup"><span data-stu-id="a104b-139">In the rest of this section, we will describe each in turn and provide examples of how they can be used in practice to make useful quantum programs.</span></span>
