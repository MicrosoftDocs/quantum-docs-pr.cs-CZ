---
title: Qubit ve výpočetním prostředí
description: Seznamte se s qubits, základní jednotkou informací v výpočetním prostředí.
author: QuantumWriter
uid: microsoft.quantum.concepts.qubit
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
no-loc:
- $
- $
- $
- $
- $
- $
- '\cdots'
- bmatrix
- '\ddots'
- '\equiv'
- '\sum'
- '\begin'
- '\end'
- '\sqrt'
- '\otimes'
- '{'
- '}'
- '\text'
- '\phi'
- '\kappa'
- '\psi'
- '\alpha'
- '\beta'
- '\gamma'
- '\delta'
- '\omega'
- '\bra'
- '\ket'
- '\boldone'
- '\\\\'
- '\\'
- =
- '\frac'
- '\text'
- '\mapsto'
- '\dagger'
- '\to'
- "\begin{cases}"
- "\end{cases}"
- '\operatorname'
- '\braket'
- '\id'
- '\expect'
- '\defeq'
- '\variance'
- '\dd'
- '&'
- "\begin{align}"
- "\end{align}"
- '\Lambda'
- '\lambda'
- '\Omega'
- '\mathrm'
- '\left'
- '\right'
- '\qquad'
- '\times'
- '\big'
- '\langle'
- '\rangle'
- '\bigg'
- '\Big'
- '|'
- '\mathbb'
- '\vec'
- '\in'
- '\texttt'
- '\ne'
- <
- '>'
- '\leq'
- '\geq'
- ~~
- "~"
- "\begin{bmatrix}"
- "\end{bmatrix}"
- '\_'
ms.openlocfilehash: 0b768190137aa4effe0fbac9c764dff60ec00e16
ms.sourcegitcommit: 0181e7c9e98f9af30ea32d3cd8e7e5e30257a4dc
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/23/2020
ms.locfileid: "85269571"
---
# <a name="the-qubit"></a><span data-ttu-id="0d1b2-103">Qubit</span><span class="sxs-lookup"><span data-stu-id="0d1b2-103">The Qubit</span></span>

<span data-ttu-id="0d1b2-104">Stejně jako bity jsou základními informacemi v klasickém výpočetním prostředí ( [*qubits*](https://en.wikipedia.org/wiki/Qubit) ) jsou základními informacemi v oblasti výpočetní služby.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-104">Just as bits are the fundamental object of information in classical computing, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (quantum bits) are the fundamental object of information in quantum computing.</span></span>  <span data-ttu-id="0d1b2-105">Pro pochopení tohoto způsobu korespondence se podívejme na Nejjednodušší příklad: jeden qubit.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-105">To understand this correspondence, let's look at the simplest example: a single qubit.</span></span>

## <a name="representing-a-qubit"></a><span data-ttu-id="0d1b2-106">Reprezentace qubit</span><span class="sxs-lookup"><span data-stu-id="0d1b2-106">Representing a Qubit</span></span>

<span data-ttu-id="0d1b2-107">Zatímco bitová nebo binární číslice může mít hodnotu buď $0 $ , nebo $1 $ , qubit může mít hodnotu, která je buď z těchto hodnot, nebo z nadmnožiny na základě doby platnosti $0 $ a $1 $ .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-107">While a bit, or binary digit, can have value either $0$ or $1$, a qubit can have a value that is either of these or a quantum superposition of $0$ and $1$.</span></span>

<span data-ttu-id="0d1b2-108">Stav jednoho qubit může být popsán dvourozměrným vektorem sloupce Jednotková norma, tj. Velikost čtverce jeho položek musí být součtem $1 $ .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-108">The state of a single qubit can be described by a two-dimensional column vector of unit norm, that is, the magnitude squared of its entries must sum to $1$.</span></span> <span data-ttu-id="0d1b2-109">Tento vektor, označovaný jako vektor stavu, obsahuje všechny informace potřebné k popisu qubit systému, stejně jako jeden bit obsahuje všechny informace potřebné k popisu stavu binární proměnné.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-109">This vector, called the quantum state vector, holds all the information needed to describe the one-qubit quantum system just as a single bit holds all of the information needed to describe the state of a binary variable.</span></span>

<span data-ttu-id="0d1b2-110">Libovolný dvourozměrný vektor sloupce reálných nebo komplexních čísel s normou $1 $ představuje možný stav, který uchovává qubit.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-110">Any two-dimensional column vector of real or complex numbers with norm $1$ represents a possible quantum state held by a qubit.</span></span> <span data-ttu-id="0d1b2-111">Takže $ \begin{ bmatrix } \Alpha \\ \\ \beta \end{ bmatrix } $ představuje stav qubit, pokud jsou $ \Alpha $ a $ \beta $ komplexní čísla splňující $ | \Alpha | ^ 2 + | \beta | ^ 2 = 1 $ .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-111">Thus $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ represents a qubit state if $\alpha$ and $\beta$ are complex numbers satisfying $|\alpha|^2 + |\beta|^2 = 1$.</span></span> <span data-ttu-id="0d1b2-112">Některé příklady platných vektorů stavu, které představují qubits include</span><span class="sxs-lookup"><span data-stu-id="0d1b2-112">Some examples of valid quantum state vectors representing qubits include</span></span>

<span data-ttu-id="0d1b2-113">$ $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } , \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } , \begin{ bmatrix } \frac{1 } {\sqrt{2 } } \\ \\ \frac{1 } {\sqrt{2 } } \end{ bmatrix } , \begin{ bmatrix } \frac{1 } {\sqrt{2 } } \\ \\ \frac { -1 } {\sqrt{2 } } \end{ bmatrix } , \Text { a} \begin{\frac{1 bmatrix } } {\sqrt{2} \frac{i } \\ \\ } {\sqrt{2 } } \end{ bmatrix } . $ $</span><span class="sxs-lookup"><span data-stu-id="0d1b2-113">$$\begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \begin{bmatrix} 0 \\\\  1 \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{1}{\sqrt{2}} \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{-1}{\sqrt{2}} \end{bmatrix}, \text{ and }\begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{i}{\sqrt{2}} \end{bmatrix}.$$</span></span>

<span data-ttu-id="0d1b2-114">Hodnota "Vector State State" $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $ a $ \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $ proveďte speciální roli.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-114">The quantum state vectors $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ and $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$ take a special role.</span></span> <span data-ttu-id="0d1b2-115">Tyto dva vektory tvoří základ pro vektorový prostor, který popisuje stav qubit.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-115">These two vectors form a basis for the vector space that describes the qubit's state.</span></span> <span data-ttu-id="0d1b2-116">To znamená, že každý objekt pro každý stav se může zapsat jako součet těchto základních vektorů.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-116">This means that any quantum state vector can be written as a sum of these basis vectors.</span></span> <span data-ttu-id="0d1b2-117">Konkrétně je možné zapsat vektor $ \begin{ bmatrix } x \\ \\ y \end{ bmatrix } $ jako $x \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } + y \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-117">Specifically, the vector $\begin{bmatrix} x \\\\  y \end{bmatrix}$ can be written as $x \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="0d1b2-118">I když by jakékoli rotace těchto vektorů sloužily jako naprosto platnému základu pro qubit, rozhodli jsme se pro ni toto oprávnění, a to voláním *výpočetního základu*.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-118">While any rotation of these vectors would serve as a perfectly valid basis for the qubit, we choose to privilege this one, by calling it the *computational basis*.</span></span>

<span data-ttu-id="0d1b2-119">Tyto dva stavy dobereme, aby odpovídaly dvěma stavům klasického bitu, konkrétně $0 $ a $1 $ .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-119">We take these two quantum states to correspond to the two states of a classical bit, namely $0$ and $1$.</span></span> <span data-ttu-id="0d1b2-120">Standardní konvence je výběr</span><span class="sxs-lookup"><span data-stu-id="0d1b2-120">The standard convention is to choose</span></span>

<span data-ttu-id="0d1b2-121">$ $0 \equiv \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } , \qquad 1 \equiv \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } , $ $</span><span class="sxs-lookup"><span data-stu-id="0d1b2-121">$$0\equiv \begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \qquad 1 \equiv \begin{bmatrix} 0 \\\\  1 \end{bmatrix},$$</span></span>

<span data-ttu-id="0d1b2-122">i když opačná volba by mohla být zároveň zavedená.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-122">although the opposite choice could equally well be taken.</span></span> <span data-ttu-id="0d1b2-123">Proto z nekonečného počtu možných qubitch stavových procesorů, pouze dva odpovídají stavům klasických bitů; všechny ostatní stavy neexistují.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-123">Thus, out of the infinite number of possible single-qubit quantum state vectors, only two correspond to states of classical bits; all other quantum states do not.</span></span>

## <a name="measuring-a-qubit"></a><span data-ttu-id="0d1b2-124">Měření qubit</span><span class="sxs-lookup"><span data-stu-id="0d1b2-124">Measuring a Qubit</span></span>

<span data-ttu-id="0d1b2-125">Teď, když víme, jak vyjádřit qubit, můžeme získat některé Intuition pro to, co tyto stavy reprezentují, a to tak, že se podíváme na koncept [*měření*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span><span class="sxs-lookup"><span data-stu-id="0d1b2-125">Now that we know how to represent a qubit, we can gain some intuition for what these states represent by discussing the concept of [*measurement*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span></span> <span data-ttu-id="0d1b2-126">Měření odpovídá neformálnímu designu "hledání" na qubit, který okamžitě sbalí stav u jednoho ze dvou klasických stavů $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $ nebo $ \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-126">A measurement corresponds to the informal idea of “looking” at a qubit, which immediately collapses the quantum state to one of the two classical states  $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ or  $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="0d1b2-127">Když se měří qubit, který je dán příslušnou hodnotu Vector $ \begin{ bmatrix } \Alpha \\ \\ \beta \end{ bmatrix } $, získáme výsledek $0 $ s pravděpodobností $ | \Alpha | ^ 2 $ a výsledek $1 $ s pravděpodobností $ | \beta | ^ 2 $ .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-127">When a qubit given by the quantum state vector  $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ is measured, we obtain the outcome $0$ with probability $|\alpha|^2$ and the outcome $1$  with probability $|\beta|^2$.</span></span> <span data-ttu-id="0d1b2-128">Na výsledku $0 $ je nový stav qubit $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $; na výsledku $1 $ jeho stav je $ \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-128">On outcome $0$, the qubit's new state is $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$; on outcome $1$ its state is $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="0d1b2-129">Všimněte si, že tyto pravděpodobnosti se sčítají až $1 $ z důvodu normalizační podmínky $ | \Alpha | ^ 2 + | \beta | ^ 2 = 1 $ .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-129">Note that these probabilities sum up to $1$ because of the normalization condition $|\alpha|^2 + |\beta|^2 = 1$.</span></span>

<span data-ttu-id="0d1b2-130">Vlastnosti měření také znamenají, že celkové znaménko vektoru stavu se nevýznamně nepoužívá.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-130">The properties of measurement also mean that the overall sign of the quantum state vector is irrelevant.</span></span> <span data-ttu-id="0d1b2-131">Negace vektoru je ekvivalentem $ \Alpha \rightarrow-\Alpha $ and $ \beta \rightarrow-\beta $ .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-131">Negating a vector is equivalent to $\alpha \rightarrow -\alpha$ and $\beta \rightarrow -\beta$.</span></span> <span data-ttu-id="0d1b2-132">Vzhledem k tomu, že pravděpodobnost měření $0 $ a $1 $ závisí na velikosti na čtverci podmínek, vložením těchto značek nedojde ke změně pravděpodobností.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-132">Because the probability of measuring $0$ and $1$ depends on the magnitude squared of the terms, inserting such signs does not change the probabilities whatsoever.</span></span> <span data-ttu-id="0d1b2-133">Tyto fáze se často nazývají [ \`\` *globální fáze*](https://en.wikipedia.org/wiki/Phase_factor) a obecně můžou mít tvar $e ^ {i \phi } $ místo pouze $ \Pm 1 $ .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-133">Such phases are commonly called [\`\`*global phases*''](https://en.wikipedia.org/wiki/Phase_factor) and more generally can be of the form $e^{i \phi}$ rather than just $\pm 1$.</span></span>

<span data-ttu-id="0d1b2-134">Poslední důležitou vlastností měření je, že neznamená poškození všech vektorů stavu.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-134">A final important property of measurement is that it does not necessarily damage all quantum state vectors.</span></span> <span data-ttu-id="0d1b2-135">Pokud začínáte s qubit ve stavu $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $, který odpovídá klasickému stavu $0 $ , měření tohoto stavu vždy vrátí výsledek $0 $ a ponechá stav bez změny.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-135">If we start with a qubit in the state $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$, which corresponds to the classical state $0$, measuring this state will always yield the outcome $0$ and leave the quantum state unchanged.</span></span> <span data-ttu-id="0d1b2-136">Pokud je v tomto smyslu jenom klasický počet bitů (tj. qubits, které jsou buď $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $ nebo $ \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $), pak měření neškodí systém.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-136">In this sense, if we only have classical bits (i.e., qubits that are either $\begin{bmatrix}1 \\\\  0 \end{bmatrix}$ or $\begin{bmatrix}0 \\\\  1 \end{bmatrix}$) then measurement does not damage the system.</span></span> <span data-ttu-id="0d1b2-137">To znamená, že můžeme replikovat klasická data a manipulovat s nimi na počítači se systémem na více počítačů, a to stejně jako na klasický počítač.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-137">This means that we can replicate classical data and manipulate it on a quantum computer just as one could do on a classical computer.</span></span> <span data-ttu-id="0d1b2-138">Schopnost ukládat informace v obou stavech najednou je to, co zvyšuje množství procesorů nad rámec toho, co je možné v klasickém prostředí, a další robsí počítačů s možností kopírování dat do nerozlišené oblasti. Další informace najdete také [v větau No-klonování](https://en.wikipedia.org/wiki/No-cloning_theorem).</span><span class="sxs-lookup"><span data-stu-id="0d1b2-138">The ability, however, to store information in both states at once is what elevates quantum computing beyond what is possible classically and further robs quantum computers of the ability to copy quantum data indiscriminately, see also [the no-cloning theorem](https://en.wikipedia.org/wiki/No-cloning_theorem).</span></span>

## <a name="visualizing-qubits-and-transformations-using-the-bloch-sphere"></a><span data-ttu-id="0d1b2-139">Vizualizace Qubits a transformací pomocí koule Bloch</span><span class="sxs-lookup"><span data-stu-id="0d1b2-139">Visualizing Qubits and Transformations using the Bloch Sphere</span></span>

<span data-ttu-id="0d1b2-140">Qubits může být také pokryta v $3 $ D pomocí reprezentace [*koule Bloch*](https://en.wikipedia.org/wiki/Bloch_sphere) .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-140">Qubits may also be pictured in $3$D using the [*Bloch sphere*](https://en.wikipedia.org/wiki/Bloch_sphere) representation.</span></span>  <span data-ttu-id="0d1b2-141">Koule Bloch poskytuje způsob, jak popsat qubit stav s jednou (což je dvourozměrný komplexní vektor) jako trojrozměrný vektor reálného čísla.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-141">The Bloch sphere gives a way of describing a single-qubit quantum state (which is a two-dimensional complex vector) as a three-dimensional real-valued vector.</span></span>  <span data-ttu-id="0d1b2-142">To je důležité, protože nám umožňuje vizualizovat qubit stavy a následně rozvíjet důvod, který může být nevýznamný v porozumění qubitch stavech (kde bohužel Bloch reprezentace sféry).</span><span class="sxs-lookup"><span data-stu-id="0d1b2-142">This is important because it allows us to visualize single-qubit states and thereby develop reasoning that can be invaluable in understanding multi-qubit states (where sadly the Bloch sphere representation breaks down).</span></span>  <span data-ttu-id="0d1b2-143">Koule Bloch se dá vizuálně rozlišit takto:</span><span class="sxs-lookup"><span data-stu-id="0d1b2-143">The Bloch sphere can be visualized as follows:</span></span>

<!--- ![](.\media\bloch.svg){ width=50% } --->
<span data-ttu-id="0d1b2-144">![Koule Bloch](~/media/concepts_bloch.png)</span><span class="sxs-lookup"><span data-stu-id="0d1b2-144">![Bloch sphere](~/media/concepts_bloch.png)</span></span>

<span data-ttu-id="0d1b2-145">Šipky v tomto diagramu ukazují směr, ve kterém je vektor stavu, který ukazuje, a každou transformaci šipky lze představit jako rotaci kolem jedné z OS mohutnosti.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-145">The arrows in this diagram show the direction in which the quantum state vector is pointing and each transformation of the arrow can be thought of as a rotation about one of the cardinal axes.</span></span>
<span data-ttu-id="0d1b2-146">Při zvažování výpočetních hodnot za běhu jako sekvence rotací je to náročné Intuition, ale tento Intuition je obtížné použít k návrhu a popisu algoritmů.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-146">While thinking about a quantum computation as a sequence of rotations is a powerful intuition, it is challenging to use this intuition to design and describe algorithms.</span></span> <span data-ttu-id="0d1b2-147">Q # tento problém vyřeší tím, že poskytuje jazyk pro popis takových otočení.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-147">Q# alleviates this issue by providing a language for describing such rotations.</span></span>

## <a name="single-qubit-operations"></a><span data-ttu-id="0d1b2-148">Operace s jedním qubit</span><span class="sxs-lookup"><span data-stu-id="0d1b2-148">Single-Qubit Operations</span></span>

<span data-ttu-id="0d1b2-149">Nastavování počítačů zpracovává data pomocí univerzální sady bran pro plnění, které mohou emulovat jakékoli otočení vektoru stavu.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-149">Quantum computers process data by applying a universal set of quantum gates that can emulate any rotation of the quantum state vector.</span></span>
<span data-ttu-id="0d1b2-150">Tato pojem obecnosti se podobají na pojem univerzální pro tradiční (tj. klasický) výpočet, kde je sada brány považována za univerzální, pokud je možné provést každou transformaci vstupních bitů pomocí omezeného okruhu délky.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-150">This notion of universality is akin to the notion of universality for traditional (i.e., classical) computing where a gate set is considered to be universal if every transformation of the input bits can be performed using a finite length circuit.</span></span>
<span data-ttu-id="0d1b2-151">Ve výpočetním prostředí jsou platné transformace, které můžeme provádět na qubit, jednotnou transformaci a měření.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-151">In quantum computing, the valid transformations that we are allowed to perform on a qubit are unitary transformations and measurement.</span></span>
<span data-ttu-id="0d1b2-152">*Operace souseda* nebo složitá sdružená transformace má zásadní význam pro náročné na výpočetní výkon, protože je potřeba pro invertování transformací za sebou.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-152">The *adjoint operation* or the complex conjugate transpose is of crucial importance to quantum computing because it is needed to invert quantum transformations.</span></span>
<span data-ttu-id="0d1b2-153">Q # odráží to tím, že poskytuje metody pro automatické kompilování sekvencí brány do jejich sousedících, které v mnoha případech uloží programátora z nutnosti ručního nastavování kódu adjoints.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-153">Q# reflects this by providing methods to automatically compile gate sequences to their adjoint, which saves the programmer from having to hand code adjoints in many cases.</span></span> <span data-ttu-id="0d1b2-154">Příklad najdete tady:</span><span class="sxs-lookup"><span data-stu-id="0d1b2-154">An example of this is shown below:</span></span>

```qsharp
operation PrepareSuperposition(qubit : Qubit) : Unit
is Adj { // Auto-generate the adjoint of the operation
    H(qubit);
}
```

<span data-ttu-id="0d1b2-155">I když se jedná o triviální příklad (jako <xref:microsoft.quantum.intrinsic.h> ), jedná se o samostatně sousedící objekt), vidíte, jak se to bude nevýznamné pro složitější operace qubit.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-155">Although this is a trivial example (as the <xref:microsoft.quantum.intrinsic.h[!OP.NO-LOC(> operation is self-adjoint), you can see how this becomes invaluable for more complicated qubit operations.</span></span>
<span data-ttu-id="0d1b2-156">Další informace najdete v tématu [operace a funkce](xref:microsoft.quantum.guide.operationsfunctions).</span><span class="sxs-lookup"><span data-stu-id="0d1b2-156">For more information, see [Operations and Functions](xref:microsoft.quantum.guide.operationsfunctions).</span></span>

<span data-ttu-id="0d1b2-157">K dispozici jsou pouze čtyři funkce namapované na jeden bit na klasický počítač.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-157">There are only four functions that map one bit to one bit on a classical computer.</span></span> <span data-ttu-id="0d1b2-158">Naproti tomu existuje nekonečný počet jednotkových transformací na jednom qubit počítače.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-158">In contrast, there are an infinite number of unitary transformations on a single qubit on a quantum computer.</span></span> <span data-ttu-id="0d1b2-159">Proto žádná konečná sada primitivních operací s názvem, která se označuje jako [*brány*](https://en.wikipedia.org/wiki/Quantum_logic_gate), může přesně replikovat nekonečnou sadu základních transformací, které jsou povolené při práci.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-159">Therefore, no finite set of primitive quantum operations, called [*gates*](https://en.wikipedia.org/wiki/Quantum_logic_gate), can exactly replicate the infinite set of unitary transformations allowed in quantum computing.</span></span> <span data-ttu-id="0d1b2-160">To znamená, že na rozdíl od klasického výpočetního prostředí není možné, aby počítač bez nároků implementoval každý možný program na více systémů, a to přesně pomocí omezeného počtu bran.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-160">This means, unlike classical computing, it is impossible for a quantum computer to implement every possible quantum program exactly using a finite number of gates.</span></span> <span data-ttu-id="0d1b2-161">Proto by počítače nemohly být univerzální ve stejném smyslu klasických počítačů.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-161">Thus quantum computers cannot be universal in the same sense of classical computers.</span></span> <span data-ttu-id="0d1b2-162">V důsledku toho znamenáme, že sada bran je *univerzální* pro výpočetní výkon, ale ve skutečnosti se jedná o trochu slabší, než je u klasického výpočetního prostředí.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-162">As a result, when we say that a set of gates is *universal* for quantum computing we actually mean something slightly weaker than we mean with classical computing.</span></span>
<span data-ttu-id="0d1b2-163">V případě obecnosti vyžadujeme, aby počítač s více podsítěmi v rámci omezené velikosti *používal jenom každou* jednotkovou matici s omezenou délkou.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-163">For universality, we require that a quantum computer only *approximate* every unitary matrix within a finite error using a finite length gate sequence.</span></span>
<span data-ttu-id="0d1b2-164">Jinými slovy, sada bran je univerzální branou, pokud může být jakákoli Jednotková transformace přibližně zapsaná jako produkt z brány z této sady.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-164">In other words, a set of gates is a universal gate set if any unitary transformation can be approximately written as a product of gates from this set.</span></span> <span data-ttu-id="0d1b2-165">Vyžadujeme, aby pro všechny předepsané chyby byly brány $G _ {1 } , G_ {2 } , \ldots, G_N $ ze sady brány.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-165">We require that for any prescribed error bound, there exist gates $G_{1}, G_{2},\ldots, G_N$ from the gate set such that</span></span>

<span data-ttu-id="0d1b2-166">$ $ G_N G_ {N-1 } \cdots G_2 G_1 \Approx U. $ $</span><span class="sxs-lookup"><span data-stu-id="0d1b2-166">$$ G_N G_{N-1} \cdots G_2 G_1 \approx U. $$</span></span>

<span data-ttu-id="0d1b2-167">Vzhledem k tomu, že konvence násobení matice je vynásobit zprava doleva první operace brány v této sekvenci, $G _N $ je vlastně poslední použitou pro vektor stavu.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-167">Note that because the convention for matrix multiplication is to multiply from right to left the first gate operation in this sequence, $G_N$, is actually the last one applied to the quantum state vector.</span></span> <span data-ttu-id="0d1b2-168">Řekněme, že taková sada brány je univerzální, pokud pro každou odolnost proti chybám $ \epsilon>0 $ existuje $G _1, \ldots G_N $ tak, že vzdálenost mezi $G _N \ldots G_1 $ a $U $ je nejvíce $ \epsilon $ .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-168">More formally, we say that such a gate set is universal if for every error tolerance $\epsilon>0$ there exists $G_1,\ldots, G_N$ such that  the distance between $G_N\ldots G_1$ and $U$ is at most $\epsilon$.</span></span> <span data-ttu-id="0d1b2-169">V ideálním případě $ musí být hodnota $N potřebná k dosažení této vzdálenosti $ \epsilon, $ Poly-logarithmically s $1/\ Epsilon $ .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-169">Ideally the value of $N$ needed to reach this distance of $\epsilon$ should scale poly-logarithmically with $1/\epsilon$.</span></span>

<span data-ttu-id="0d1b2-170">Jak vypadá tato univerzální sada brány jako v praxi?</span><span class="sxs-lookup"><span data-stu-id="0d1b2-170">What does such a universal gate set look like in practice?</span></span>  <span data-ttu-id="0d1b2-171">Nejjednodušší taková univerzální brána pro qubit brány se skládá jenom ze dvou bran: bránu Hadamard $H $ a bránu $T-incalled, která se označuje $ taky jako brána $ \ PI/8 $ ):</span><span class="sxs-lookup"><span data-stu-id="0d1b2-171">The simplest such universal gate set for single-qubit gates consists of only two gates: the Hadamard gate $H$ and the so-called $T$-gate (also known as the $\pi/8$ gate):</span></span>

<span data-ttu-id="0d1b2-172">$ $ H = \frac{1 } {\sqrt{2 } } \begin{ bmatrix } 1 & 1 \\ \\ 1 &-1 \end{ bmatrix } , \qquad T = \begin{ bmatrix } 1 & 0 \\ \\ 0 & e ^ {i \ PI/4 } \end{ bmatrix } .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-172">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix},\qquad T=\begin{bmatrix} 1 & 0 \\\\  0 & e^{i\pi/4} \end{bmatrix}.</span></span>
$$

<span data-ttu-id="0d1b2-173">Z praktických důvodů vztahujících se k opravám chybných stavů ale může být pohodlnější zvážit větší sadu bran, konkrétně jednu, kterou je možné vygenerovat pomocí $H $ a $T $ .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-173">However, for practical reasons related to quantum error correction it can be more convenient to consider a larger gate set, namely one that can be generated using $H$ and $T$.</span></span>
<span data-ttu-id="0d1b2-174">Pro každou z těchto bran můžeme klasifikovat dvě kategorie: Clifford a brány $T $ .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-174">We can classify the quantum gates into two categories: Clifford gates and the $T$-gate.</span></span>
<span data-ttu-id="0d1b2-175">Toto rozdělení je užitečné, protože v mnoha schématech oprav chyb se říká Clifford, že se pro ně snadno implementují brány, které vyžadují velmi málo prostředků v souvislosti s operacemi a qubits k implementaci odolnosti proti chybám. to znamená, že non-Clifford brány jsou poměrně nákladné při vyžadování odolnosti proti chybám.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-175">This subdivision is useful because in many quantum error correction schemes the so-called Clifford gates are easy to implement, that is they require very few resources in terms of operations and qubits to implement fault tolerantly, whereas non-Clifford gates are quite costly when requiring fault tolerance.</span></span> <span data-ttu-id="0d1b2-176">Standardní sada bran s jedním qubit Clifford, která je ve [výchozím nastavení součástí Q #](xref:microsoft.quantum.libraries.standard.prelude), zahrnuje</span><span class="sxs-lookup"><span data-stu-id="0d1b2-176">The standard set of single-qubit Clifford gates, [included by default in Q#](xref:microsoft.quantum.libraries.standard.prelude), include</span></span>

<span data-ttu-id="0d1b2-177">$ $ H = \frac{1 } {\sqrt{2 } } \begin{ bmatrix } 1 & 1 \\ \\ 1 &-1 \end{ bmatrix } , \qquad S = \begin{ bmatrix } 1 & 0 \\ \\ 0 & i \end{ bmatrix } = T ^ 2, \qquad X = \begin{ bmatrix } 0 &1 \\ \\ 1 & 0 \end{ bmatrix } = HT ^ 4, $ $</span><span class="sxs-lookup"><span data-stu-id="0d1b2-177">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix} ,\qquad S =\begin{bmatrix} 1 & 0 \\\\  0 & i \end{bmatrix}= T^2,\qquad X=\begin{bmatrix} 0 &1 \\\\  1& 0 \end{bmatrix}= HT^4H, $$</span></span>

<span data-ttu-id="0d1b2-178">$ $ Y = \begin{ bmatrix } 0 &-i \\ \\ i & 0 \END{ bmatrix } = T ^ 2HT ^ 4 HT ^ 6, \qquad Z = \begin{ bmatrix } 1&0 \\\\ 0 & -1 \end{ bmatrix } = T ^ 4.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-178">$$ Y = \begin{bmatrix} 0 & -i \\\\  i & 0 \end{bmatrix}=T^2HT^4  HT^6, \qquad Z=\begin{bmatrix}1&0\\\\ 0&-1 \end{bmatrix}=T^4.</span></span>
$$

<span data-ttu-id="0d1b2-179">V tomto případě se operace $X $ $Y $ a $Z $ používají hlavně často a jsou pojmenovány jako [*operátory Pauli*](https://en.wikipedia.org/wiki/Pauli_matrices) po jejich autorovi Wolfgang Pauli.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-179">Here the operations $X$, $Y$ and $Z$ are used especially frequently and are named [*Pauli operators*](https://en.wikipedia.org/wiki/Pauli_matrices) after their creator Wolfgang Pauli.</span></span>
<span data-ttu-id="0d1b2-180">Spolu s bránou Clifford ( $ bránu $T) se tyto operace dají sestavit tak, aby se v jednom qubit přibližné měněné transformaci.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-180">Together with the non-Clifford gate (the $T$-gate), these operations can be composed to approximate any unitary transformation on a single qubit.</span></span>

<span data-ttu-id="0d1b2-181">Další informace o těchto operacích, jejich reprezentujes Bloch a implementace Q # najdete v tématu [vnitřní operace a funkce](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span><span class="sxs-lookup"><span data-stu-id="0d1b2-181">For more information on these operations, their Bloch sphere representations and Q# implementations, see [Intrinsic Operations and Functions](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span></span>

<span data-ttu-id="0d1b2-182">Jako příklad, jak lze z těchto primitivních typů sestavovat jednotnou transformaci, odpovídají tři transformace, které jsou znázorněné v Blochch oblastech, do sekvence brány $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } \mapsto HZH \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } = \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-182">As an example of how unitary transformations can be built from these primitives, the three transformations pictured in the Bloch spheres above correspond to the gate sequence $\begin{bmatrix} 1 \\\\  0 \end{bmatrix} \mapsto HZH \begin{bmatrix} 1 \\\\  0 \end{bmatrix} = \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span>

<span data-ttu-id="0d1b2-183">Zatímco předchozí představuje nejoblíbenější primitivní brány pro popis operací na logické úrovni zásobníku (představit na logické úrovni jako úroveň algoritmu nečinnosti), je často vhodné zvážit méně základních operací na úrovni algoritmu, například operace blíž k úrovni popisu funkce.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-183">While the previous constitute the most popular primitive gates for describing operations on the logical level of the stack (think of the logical level as the level of the quantum algorithm), it is often convenient to consider less basic operations at the algorithmic level, for example operations closer to a function description level.</span></span> <span data-ttu-id="0d1b2-184">Naštěstí, Q # také obsahuje metody, které jsou k dispozici pro implementaci unitaries na vyšší úrovni, který umožňuje implementovat algoritmy vysoké úrovně bez explicitního rozkládání všeho do Clifford a $T $ -bran.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-184">Fortunately, Q# also has methods available for implementing higher-level unitaries, which in turn allow high-level algorithms to be implemented without explicitly decomposing everything down to Clifford and $T$-gates.</span></span>

<span data-ttu-id="0d1b2-185">Nejjednodušší taková primitivní jednoduchá rotace je qubit.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-185">The simplest such primitive is the single qubit-rotation.</span></span> <span data-ttu-id="0d1b2-186">Obvykle se berou v úvahu tři rotace s jedním qubit: $R _x $ $R _Y $ a $R _Z $ .</span><span class="sxs-lookup"><span data-stu-id="0d1b2-186">Three single-qubit rotations are typically considered: $R_x$, $R_y$ and $R_z$.</span></span> <span data-ttu-id="0d1b2-187">Chcete-li vizualizovat akci $R otáčení _x (\theta) $, například Představte si, že jste natáhli správnou dlaždici podél směru $x $ osy Bloch a svůj vektor jste natáhli pomocí úhlu kolem výrazu $ \ théta/2 $ radiánů.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-187">To visualize the action of the rotation $R_x(\theta)$, for example, imagine pointing your right thumb along the direction of the $x$-axis of the Bloch sphere and rotating the vector with your hand through an angle of $\theta/2$ radians.</span></span> <span data-ttu-id="0d1b2-188">Tento faktor odmítnutí $2 $ vzniká od faktu, že kolmé vektory jsou $ po rozkreslení na \circou koule v Bloch, ale ve skutečnosti jsou v podstatě $90 ^ \circ $ stupňů od sebe.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-188">This confusing factor of $2$ arises from the fact that orthogonal vectors are $180^\circ$ apart when plotted on the Bloch sphere, yet are actually $90^\circ$ degrees apart geometrically.</span></span> <span data-ttu-id="0d1b2-189">Odpovídající jednotkové matrice jsou:</span><span class="sxs-lookup"><span data-stu-id="0d1b2-189">The corresponding unitary matrices are:</span></span>

<span data-ttu-id="0d1b2-190">\begin{align *} &R_z (\theta) = e ^ {-i\theta z/2 } = \begin{ bmatrix } e ^ {-i \ théta/2 } & 0 \\\\ 0 & e ^ {i \ théta/2 } \end{ bmatrix } , \\ \\ &R_x (\theta) = e ^ {-i\theta x/2 } = HR_z (\theta) H = \begin{ bmatrix } \cos (\ théta/2) &-i\sin (\ théta/2) \\ \\ -i\sin (\ théta/2) & \cos (\ théta/2) \end{ bmatrix } , \\ \\ &R_y (\theta) = e ^ {-i\theta y/2 } = SHR_z (\theta) HS ^ \dagger = \begin{ bmatrix } \cos (\ théta/2) &-\sin (\ théta/2) \\ \\ \sin (\ théta/2) & \cos (\ théta/2) \end{ bmatrix } . \end{align*}</span><span class="sxs-lookup"><span data-stu-id="0d1b2-190">\begin{align *} &R_z(\theta) = e^{-i\theta Z/2} = \begin{bmatrix} e^{-i\theta/2} & 0\\\\  0& e^{i\theta/2} \end{bmatrix}, \\\\ &R_x(\theta) = e^{-i\theta X/2} = HR_z(\theta)H = \begin{bmatrix} \cos(\theta/2) & -i\sin(\theta/2)\\\\  -i\sin(\theta/2) & \cos(\theta/2) \end{bmatrix}, \\\\ &R_y(\theta) = e^{-i\theta Y/2} = SHR_z(\theta)HS^\dagger = \begin{bmatrix} \cos(\theta/2) & -\sin(\theta/2)\\\\  \sin(\theta/2) & \cos(\theta/2) \end{bmatrix}. \end{align*}</span></span>

<span data-ttu-id="0d1b2-191">Stejně jako jakékoli tři rotace je možné kombinovat tak, aby prováděly libovolné otočení ve třech dimenzích, je možné vidět z reprezentace Bloch koule, kterou je možné zapsat do jakékoli jednotkové matice jako sekvence tří otočení.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-191">Just as any three rotations can be combined together to perform an arbitrary rotation in three dimensions, it can be seen from the Bloch sphere representation that any unitary matrix can be written as a sequence of three rotations as well.</span></span> <span data-ttu-id="0d1b2-192">Konkrétně pro každou jednotnou matrici $U $ existuje $ \Alpha, \beta, \gamma, \delta $ tak, že $U = e ^ {i \alpha } R_x (\beta) R_z (\gamma) R_x (\delta) $.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-192">Specifically, for every unitary matrix $U$ there exists $\alpha,\beta,\gamma,\delta$ such that $U= e^{i\alpha} R_x(\beta)R_z(\gamma)R_x(\delta)$.</span></span> <span data-ttu-id="0d1b2-193">Proto $R _z (\theta) $ a $H $ také tvoří univerzální sadu brány, i když se nejedná o diskrétní sadu, protože $ \theta $ může mít libovolnou hodnotu.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-193">Thus $R_z(\theta)$ and $H$ also form a universal gate set although it is not a discrete set because $\theta$ can take any value.</span></span> <span data-ttu-id="0d1b2-194">Z tohoto důvodu a kvůli aplikacím v simulaci nenáročného kódu jsou takové nepřetržité brány zásadní pro výpočet po sobě náročné na výpočetní výkon, zejména na úrovni návrhu algoritmu.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-194">For this reason, and due to applications in quantum simulation, such continuous gates are crucial for quantum computation, especially at the quantum algorithm design level.</span></span> <span data-ttu-id="0d1b2-195">Aby byla zajištěna hardwarová implementace odolná proti chybám, bude nakonec zkompilována do diskrétních sekvencí brány, které tyto rotace důkladně nasadí.</span><span class="sxs-lookup"><span data-stu-id="0d1b2-195">To achieve fault-tolerant hardware implementation, they will ultimately be compiled into discrete gate sequences that closely approximate these rotations.</span></span>
