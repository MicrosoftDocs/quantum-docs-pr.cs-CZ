---
title: Softwarový zásobník | Microsoft Docs
description: Softwarový zásobník
author: QuantumWriter
uid: microsoft.quantum.concepts.software-stack
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f97dfacf6cde5fa92e1f368efaae36554a5c944d
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/28/2019
ms.locfileid: "73184725"
---
# <a name="software-stack-for-quantum-computing"></a><span data-ttu-id="b9812-103">Softwarový zásobník pro výpočetní výkon</span><span class="sxs-lookup"><span data-stu-id="b9812-103">Software stack for quantum computing</span></span>
<span data-ttu-id="b9812-104">Když si myslíme, že se jedná o počítač, který je v jednom zařízení, na kterém je spuštěná aplikace, ale moderní výpočetní prostředí jsou mnohem složitější a pokročilé.</span><span class="sxs-lookup"><span data-stu-id="b9812-104">Normally when we think of a computer we envision a single device running an application, but modern computing environments are much more complex and advanced.</span></span> <span data-ttu-id="b9812-105">Aplikace, která se obvykle používá, se obvykle nachází na více vrstvách softwaru, které poskytují provádění aplikace na úrovni hardwaru.</span><span class="sxs-lookup"><span data-stu-id="b9812-105">The application we interact with typically rests on multiple layers of software that provide for the application's execution down to the hardware level.</span></span> <span data-ttu-id="b9812-106">Tyto softwarové vrstvy jsou nezbytné k abstrakci vývoje řešení aplikace z základní složitosti kompletního výpočetního systému.</span><span class="sxs-lookup"><span data-stu-id="b9812-106">These software layers are necessary to abstract the development of an application solution from the underlying complexity of the complete computing system.</span></span> <span data-ttu-id="b9812-107">Pokud se vývojář musel představit o sběrnici, architekturách mezipaměti, komunikačních protokolech a dalších při psaní jednoduché aplikace smartphone, úloha by se stala mnohem složitější.</span><span class="sxs-lookup"><span data-stu-id="b9812-107">If a developer had to think about bus, cache architectures, communication protocols, and more while writing a simple smartphone app, the task would become much more complex.</span></span>  <span data-ttu-id="b9812-108">Koncept *softwarového zásobníku* byl vyvinutý v klasickém výpočetním prostředí, aby bylo možné tyto problémy vyřešit.</span><span class="sxs-lookup"><span data-stu-id="b9812-108">The concept of a *software stack* was developed in classical computing to address these issues.</span></span>  <span data-ttu-id="b9812-109">Z hlediska klasického konceptu je softwarový zásobník také klíčovou součástí výhledu za sebou – výpočetní výkon s Q #.</span><span class="sxs-lookup"><span data-stu-id="b9812-109">Borrowing from the classical concept, a software stack is also a key part of the vision behind quantum computing with Q#.</span></span>

## <a name="conventional-stack"></a><span data-ttu-id="b9812-110">Konvenční zásobník</span><span class="sxs-lookup"><span data-stu-id="b9812-110">Conventional stack</span></span>
<span data-ttu-id="b9812-111">Klíčový nápad za softwarový zásobník je rekurze.</span><span class="sxs-lookup"><span data-stu-id="b9812-111">The key idea behind a software stack is recursion.</span></span>  <span data-ttu-id="b9812-112">Skládá se z několika vnořených vrstev rozhraní, které z vývojářů zahodily podrobnosti o nižších úrovních zařízení.</span><span class="sxs-lookup"><span data-stu-id="b9812-112">It consists of several nested layers of interfaces that abstract the details of the lower levels of the device away from the developer.</span></span>  <span data-ttu-id="b9812-113">Často používaný softwarový zásobník například zahrnuje spuštění ASP.NET (programovací jazyk), nad SQL serverem (systém pro správu relačních databází), který běží na Internetová informační služba (webový server), který běží na Windows serveru ( operační systém), který řídí hardware počítače.</span><span class="sxs-lookup"><span data-stu-id="b9812-113">For example, a commonly used software stack involves running ASP.NET (a programming language), on top of SQL server (a relational database management system), which runs on top of Internet Information Services (a web server), which runs on top of Windows server (an operating system), which drives the computer hardware.</span></span>  <span data-ttu-id="b9812-114">Když si vyhledáte software jako hierarchii, může jeden psát software v ASP.NET, aniž by bylo nutné porozumět podrobnostem o nízké úrovni veškerého softwaru pod ním.</span><span class="sxs-lookup"><span data-stu-id="b9812-114">By looking at software as a hierarchy, one can write software in ASP.NET without needing to understand the low-level details of all the software below it.</span></span>

## <a name="quantum-stack"></a><span data-ttu-id="b9812-115">Zásobník pro všechna množství</span><span class="sxs-lookup"><span data-stu-id="b9812-115">Quantum stack</span></span>

<span data-ttu-id="b9812-116">Softwarový zásobník v množstvích výpočetních prostředí není v zásadě odlišný a v praxi se chová na nižší úrovni než tradiční zásobníky.</span><span class="sxs-lookup"><span data-stu-id="b9812-116">The software stack in quantum computing is no different in principle, and in practice operates at a lower level than traditional stacks.</span></span>  <span data-ttu-id="b9812-117">Jak vypadá zásobník pro nečinnosti?</span><span class="sxs-lookup"><span data-stu-id="b9812-117">What does a quantum stack look like?</span></span>  <span data-ttu-id="b9812-118">Počítač s více než jednou z nich není náhradou za tradiční (často označované jako klasické) počítače.</span><span class="sxs-lookup"><span data-stu-id="b9812-118">A quantum computer is not a replacement for traditional (often called classical) computers.</span></span>  <span data-ttu-id="b9812-119">Ve skutečnosti budou počítače se systémem téměř určitě spolupracovat s klasickými počítači a řešit tak výpočetní problémy.</span><span class="sxs-lookup"><span data-stu-id="b9812-119">In fact, quantum computers will almost certainly work in tandem with classical computers to solve computational problems.</span></span>  <span data-ttu-id="b9812-120">V některých případech to vznikne z důvodu nekřehkosti dat.</span><span class="sxs-lookup"><span data-stu-id="b9812-120">In part, this arises because of the fragility of quantum data.</span></span>  <span data-ttu-id="b9812-121">Data o době nezáleží na tom, že pokud si to ještě nejste poznamenali, je to u nich skoro jistě poškození informací.</span><span class="sxs-lookup"><span data-stu-id="b9812-121">Quantum data is so fragile that if you even look at it you almost certainly damage the information being observed.</span></span>  <span data-ttu-id="b9812-122">Počítače s příznačnými údaji budou muset být navržené tak, aby se opravily chyby. to znamená, že osamocené interakce z jejího fyzického prostředí neúmyslně poškozují informace a výpočty.</span><span class="sxs-lookup"><span data-stu-id="b9812-122">Quantum computers will thus need to be designed with quantum error correction in mind so that stray interactions from its physical environment do not inadvertently damage the information and computation.</span></span> <span data-ttu-id="b9812-123">Z tohoto důvodu je přirozený cíl pro Q # chybně opravený počítač (často označovaný jako počítač se *selháním, který je odolný vůči chybám* ), který přijímá seznam instrukcí na základě počtu procesorů (nazývaných brány nebo operace s bránou) a tyto pokyny aplikuje na stav. data, která jsou v něm uložená.</span><span class="sxs-lookup"><span data-stu-id="b9812-123">For this reason, a natural target for Q# is an error-corrected quantum computer (often called a *fault-tolerant* quantum computer) that accepts a list of quantum instructions (called gates or gate operations) and applies those instructions to the quantum data stored within it.</span></span>  <span data-ttu-id="b9812-124">Počítejte s tím, že pokud je počet operací qubits a hradlo v algoritmu nebo programu dostatečně malý, oprava chyb nemusí být nezbytně nutná.</span><span class="sxs-lookup"><span data-stu-id="b9812-124">Note that if the number of qubits and gate operations in a quantum algorithm or program is small enough, error correction may not be absolutely necessary.</span></span>  <span data-ttu-id="b9812-125">Jelikož se ale zvýší počet qubits a provozních operací, bude se vám tento požadavek lišit, takže jsme si náš softwarový zásobník a Q # napravili na aptly a efektivně zavedli opravy chyb a umožnili škálovatelnou výpočetní výkon, který je odolný proti chybám.</span><span class="sxs-lookup"><span data-stu-id="b9812-125">However as the number of qubits and gate operations grow, it will more certainly be a requirement, thus we architect our software stack and Q# to aptly and efficiently handle error correction and enable scalable, fault-tolerant quantum computing.</span></span>

### <a name="error-correction"></a><span data-ttu-id="b9812-126">Oprava chyb</span><span class="sxs-lookup"><span data-stu-id="b9812-126">Error correction</span></span>
<span data-ttu-id="b9812-127">Korekce chyb vyžaduje rychlý a spolehlivý klasický počítač, který je možné spustit v součinnosti s počítačem s více operačními systémy, aby opravil chyby, jak se objevují při výpočtu.</span><span class="sxs-lookup"><span data-stu-id="b9812-127">Error correction requires a fast and reliable classical computer to be run in concert with the quantum computer to correct errors as they appear in the quantum computation.</span></span>  <span data-ttu-id="b9812-128">V praxi může být potřeba, aby komponenty, jako jsou pole programovatelné brány (FPGA) nebo procesory Fast Cryogenic, mohly identifikovat a opravit chyby rychleji než přirozeně nahromadění v počítači s procesorem.</span><span class="sxs-lookup"><span data-stu-id="b9812-128">In practice, components such as field-programmable gate arrays (FPGAs) or fast cryogenic processors may be needed to identify and correct the errors faster than they naturally accumulate in the quantum computer.</span></span>  <span data-ttu-id="b9812-129">V důsledku toho je počítač s velkým množstvím hybridním počítačem, který se skládá z několika různých výpočetních zařízení, která fungují v rámci široké škály teplot.</span><span class="sxs-lookup"><span data-stu-id="b9812-129">As a result, a quantum computer is a hybrid machine comprised of several different computational devices that operate over a wide range of temperatures.</span></span>  <span data-ttu-id="b9812-130">Z tohoto důvodu je mnohem užitečnější, abyste si myslíte o programování počítače s velkým množstvím pomocí objektivu softwarového zásobníku, protože je potřeba mít k dispozici spoustu hardwarových a softwarových (klasických) a softwaru, který je nezbytný k tomu, aby se zajistila implementace. algoritmus v počítači se systémem na více počítačů.</span><span class="sxs-lookup"><span data-stu-id="b9812-130">For this reason, it is much more helpful to think about programming a quantum computer through the lens of a software stack, as there are many layers of hardware and software (classical and quantum) required to ultimately achieve the implementation of a quantum algorithm on a quantum computer.</span></span>

### <a name="quantum-conceptual-stack"></a><span data-ttu-id="b9812-131">Koncepční zásobník</span><span class="sxs-lookup"><span data-stu-id="b9812-131">Quantum conceptual stack</span></span>
<span data-ttu-id="b9812-132">Koncepční zásobník, který ilustruje funkční tok faktoringu 8704143553785700723 v výpočetních prostředích, je uvedený níže:</span><span class="sxs-lookup"><span data-stu-id="b9812-132">A conceptual stack that illustrates the functional flow of factoring 8704143553785700723 in a quantum computing environment is shown below:</span></span>

![Softwarový zásobník](~/media/concepts_stack.png)

### <a name="specification-and-algorithm"></a><span data-ttu-id="b9812-134">Specifikace a algoritmus</span><span class="sxs-lookup"><span data-stu-id="b9812-134">Specification and algorithm</span></span>
<span data-ttu-id="b9812-135">Existuje několik hlavních fází programování, jako je výpočet.</span><span class="sxs-lookup"><span data-stu-id="b9812-135">There are several broad stages of programming such a quantum computation.</span></span>  <span data-ttu-id="b9812-136">První a pravděpodobně nejnáročnější fáze určuje problém, který si přejeme vyřešit.</span><span class="sxs-lookup"><span data-stu-id="b9812-136">The first, and arguably most challenging phase, is specifying the problem that one wishes to solve.</span></span>  <span data-ttu-id="b9812-137">V takovém případě se jedná o problém s číslem 8704143553785700723 na součin dvou apostrofových čísel.</span><span class="sxs-lookup"><span data-stu-id="b9812-137">In this case, the problem is to factor the number 8704143553785700723  into a product of two prime numbers.</span></span>  <span data-ttu-id="b9812-138">Další krok zahrnuje návrh algoritmu pro řešení tohoto výpočetního problému.</span><span class="sxs-lookup"><span data-stu-id="b9812-138">The next step involves designing an algorithm for solving this computational problem.</span></span>  <span data-ttu-id="b9812-139">V takovém případě je možné pomocí algoritmu Shor slavných pro hledání faktorů použít algoritmus pro vynásobení.</span><span class="sxs-lookup"><span data-stu-id="b9812-139">In this case, Shor's famous quantum factoring algorithm can be used to find the factors.</span></span>  <span data-ttu-id="b9812-140">Tento algoritmus je vyjádřený v Q # a pak sekvence operací s více procesory je výstupem, který se dá spustit na ideálním počítači s bezplatnými chybami.</span><span class="sxs-lookup"><span data-stu-id="b9812-140">This algorithm is expressed in Q# and then a sequence of quantum operations is output that could be run on an idealized error-free quantum computer.</span></span>  

### <a name="physical-gates"></a><span data-ttu-id="b9812-141">Fyzické brány</span><span class="sxs-lookup"><span data-stu-id="b9812-141">Physical gates</span></span>
<span data-ttu-id="b9812-142">V tomto příkladu se předpokládá, že povaha není tak, aby poskytovala chybový počítač bez chyb, takže následný krok provede operace vygenerované v Q # a překládá je pomocí šablon určených metodou opravy chyb pro incidenty zvolené na fyzické brány, které základní hardware může být spuštěn.</span><span class="sxs-lookup"><span data-stu-id="b9812-142">In this example, assume nature is not so kind as to provide an error-free quantum computer so the subsequent step takes the operations emitted by Q# and translates them using templates specified by the quantum error correction method chosen into physical gates that the basic hardware can execute.</span></span>  <span data-ttu-id="b9812-143">Tento proces zahrnuje nahrazení všech logických qubit popsaných v předchozím modelu s hostitelem fyzických qubits, které se používají k ukládání a ochraně informací v jednom qubit redundantním způsobem, který může odolat místním chybám u fyzického prvku. qubits dostatečně dlouho, aby se tyto chyby zjistily a opravily.</span><span class="sxs-lookup"><span data-stu-id="b9812-143">This process involves replacing every logical qubit described in the previous model with a host of physical qubits that are used to store and protect the information within a single qubit in a redundant fashion that can resist local errors on the constituent physical qubits long enough for such errors to be detected and corrected.</span></span>  <span data-ttu-id="b9812-144">Stejně jako logické qubits popsané v kódu Q # musí být nahrazeno velkým počtem fyzických qubits, podobně každou bránu pro práci s poli, která je popsána ve výstupu, se musí přeložit do sekvence fyzických bran, které fungují na fyzickém qubits.</span><span class="sxs-lookup"><span data-stu-id="b9812-144">Just as the logical qubits described by the Q# code need to be replaced with many physical qubits, similarly each quantum gate described in the output needs to be translated into a sequence of physical gates that act upon the physical qubits.</span></span>  <span data-ttu-id="b9812-145">Z tohoto důvodu je výstup Q # jenom v konečném cíli pro výpočetní výkon a další úrovně abstrakce je potřeba ke spuštění kódu na hardwaru oblivious způsobem.</span><span class="sxs-lookup"><span data-stu-id="b9812-145">For this reason, the output of Q# is seldom the final target for quantum computing and further levels of abstraction are needed to execute the code on hardware in an oblivious fashion.</span></span>

### <a name="control-computer"></a><span data-ttu-id="b9812-146">Řídicí počítač</span><span class="sxs-lookup"><span data-stu-id="b9812-146">Control computer</span></span>
<span data-ttu-id="b9812-147">Fyzická sekvence brány se pak načte do obyčejného počítače, který tyto pokyny pošle do řídicího počítače, který rozhraní přímo s počítačem s taktem.</span><span class="sxs-lookup"><span data-stu-id="b9812-147">The physical gate sequence is then loaded into an ordinary computer that sends these instructions down to a control computer that interfaces directly with the quantum computer.</span></span>  <span data-ttu-id="b9812-148">Tato vrstva v softwarovém zásobníku se často zpracovává pomocí experimentálního řídicího softwaru, jako je [QCoDeS](http://qcodes.github.io/Qcodes/).</span><span class="sxs-lookup"><span data-stu-id="b9812-148">This layer within the software stack is often handled by experimental control software such as [QCoDeS](http://qcodes.github.io/Qcodes/).</span></span>

### <a name="interface-computer"></a><span data-ttu-id="b9812-149">Počítač rozhraní</span><span class="sxs-lookup"><span data-stu-id="b9812-149">Interface computer</span></span>
<span data-ttu-id="b9812-150">Poslední krok tohoto procesu zahrnuje počítač rozhraní, který je nejdřív vysílaný jako potřebný pro počítač s rychlým ovládáním.</span><span class="sxs-lookup"><span data-stu-id="b9812-150">The final step in this process involves the interface computer first streaming the gates as needed to a fast control computer.</span></span> <span data-ttu-id="b9812-151">Pak počítač s rychlým ovládáním aplikuje potřebné napětí (obvykle nazývané Pulse) k implementaci požadovaných bran na qubits.</span><span class="sxs-lookup"><span data-stu-id="b9812-151">Then the fast control computer applies the voltages needed (commonly called pulses) to implement the required gates on qubits.</span></span> <span data-ttu-id="b9812-152">To je potřeba udělat při opravě chyb, které jsou pozorovány prostřednictvím opravy chyb.</span><span class="sxs-lookup"><span data-stu-id="b9812-152">This has to be done while correcting any errors that are observed through quantum error correction.</span></span>  <span data-ttu-id="b9812-153">Cryogenic FPGA nebo jiný exotický hardware může být potřeba k provedení těchto kroků v rámci přísných časových požadavků stanovených rychlostí, při které se zobrazí chyby v počítači s nárokem na tento počítač.</span><span class="sxs-lookup"><span data-stu-id="b9812-153">Cryogenic FPGAs or other exotic hardware may be needed to perform these steps within the stringent time requirements imposed by the rate at which errors appear in the quantum computer.</span></span>  <span data-ttu-id="b9812-154">Cílový jazyk na této úrovni je často [VHDL](https://en.wikipedia.org/wiki/VHDL), což vyžaduje odlišný způsob, který je třeba uvažovat od toho, který se používá v horním konci zásobníku k analýze popisu pro tento algoritmus.</span><span class="sxs-lookup"><span data-stu-id="b9812-154">The target language on this level is often [VHDL](https://en.wikipedia.org/wiki/VHDL), which requires a distinct way of thinking from that which is used at the top end of the stack to parse a description of a quantum algorithm.</span></span>

### <a name="the-q-quantum-programming-language"></a><span data-ttu-id="b9812-155">Jazyk programovacího jazyka Q #</span><span class="sxs-lookup"><span data-stu-id="b9812-155">The Q# quantum programming language</span></span>
<span data-ttu-id="b9812-156">Cílem Q # je poskytnout jednoduchý jazyk, který vývojářům umožňuje psát kód, který se zaměřuje na širokou spoustu výpočetních platforem a rozhraní, s využitím vrstev softwaru, který stojí mezi uživatelem a zařízením.</span><span class="sxs-lookup"><span data-stu-id="b9812-156">The aim of Q# is to provide a simple language that allows developers to write code that targets a wealth of quantum computing platforms and interface with the intervening layers of software that stand between the user and the quantum device.</span></span>  <span data-ttu-id="b9812-157">Tento jazyk to usnadňuje tím, že přechodu pojem softwarový zásobník a abstrakce spousty podrobností o podkladovém počítači s velkým stavem a zároveň umožňuje další úrovně zásobníku zveřejněné prostřednictvím jazyka C#, jako je, k provedení potřebného překlady z kódu Q # k základním operacím.</span><span class="sxs-lookup"><span data-stu-id="b9812-157">The language facilitates this by embracing the notion of a software stack and abstracting many of the details of the underlying quantum computer while allowing other levels of the stack, exposed through a language such as C#, to perform the necessary translations from Q# code to fundamental operations.</span></span>  <span data-ttu-id="b9812-158">To umožňuje vývojářům soustředit se na to, co je nejlepší: návrh algoritmů a řešení problémů.</span><span class="sxs-lookup"><span data-stu-id="b9812-158">This allows the developer to focus on what they do best: designing algorithms and solving problems.</span></span>
